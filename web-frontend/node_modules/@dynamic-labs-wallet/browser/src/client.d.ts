import { AuthMode, BackupLocation, type BackupLocationWithExternalKeyShareId, DynamicApiClient, type DynamicWalletClientProps, type FeatureFlags, type InitializeResult, type KeyShareBackupInfo, ThresholdSignatureScheme, WalletOperation } from '@dynamic-labs-wallet/core';
import { BIP340KeygenResult, EcdsaKeygenResult, type EcdsaPublicKey, type EcdsaSignature, ExportableEd25519KeygenResult } from '#internal/web';
import type { SignMessageContext } from '@dynamic-labs/sdk-api-core';
import type { ClientInitKeygenResult, ClientKeyShare } from './mpc/types.js';
import { type SupportedStorage } from './services/localStorage.js';
import type { WalletProperties } from './types.js';
export declare class DynamicWalletClient {
    environmentId: string;
    storageKey: string;
    debug: boolean;
    protected userId: string | undefined;
    protected sessionId: string | undefined;
    protected initializePromise: Promise<InitializeResult> | null;
    protected logger: import("@dynamic-labs/logger").Logger;
    protected apiClient: DynamicApiClient;
    protected walletMap: Record<string, WalletProperties>;
    protected storage: SupportedStorage;
    protected memoryStorage: {
        [key: string]: string;
    } | null;
    protected baseMPCRelayApiUrl?: string;
    protected iframe: HTMLIFrameElement | null;
    readonly instanceId: string;
    readonly iframeDomain: string;
    readonly featureFlags: FeatureFlags;
    protected authMode: AuthMode;
    protected sdkVersion?: string;
    constructor({ environmentId, baseApiUrl, baseMPCRelayApiUrl, storageKey, debug, featureFlags, authMode, authToken, sdkVersion, }: DynamicWalletClientProps);
    getAuthMode(): AuthMode;
    /**
     * Check if the SDK version meets the requirement for signed session ID
     * Uses namespace-specific version requirements when available
     * @returns boolean indicating if requireSignedSessionId should be set to true
     */
    private requiresSignedSessionId;
    initLoggerContext(authToken: string): Promise<void>;
    initialize(): Promise<InitializeResult>;
    /**
     * Client initialization logic
     */
    protected _initialize(): Promise<InitializeResult>;
    serverInitializeKeyGen({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        chainName: string;
        clientKeygenIds: string[];
        dynamicRequestId: string;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<import("@dynamic-labs-wallet/core").KeygenCompleteResponse>;
    clientInitializeKeyGen({ chainName, thresholdSignatureScheme, }: {
        chainName: string;
        thresholdSignatureScheme: ThresholdSignatureScheme;
    }): Promise<ClientInitKeygenResult[]>;
    derivePublicKey({ chainName, keyShare, derivationPath, }: {
        chainName: string;
        keyShare: ClientKeyShare;
        derivationPath: Uint32Array | undefined;
    }): Promise<EcdsaPublicKey | Uint8Array | string | undefined>;
    clientKeyGen({ chainName, roomId, serverKeygenIds, clientKeygenInitResults, thresholdSignatureScheme, }: {
        chainName: string;
        roomId: string;
        serverKeygenIds: string[];
        clientKeygenInitResults: ClientInitKeygenResult[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
    }): Promise<{
        rawPublicKey: EcdsaPublicKey | Uint8Array | string | undefined;
        clientKeygenResults: ClientKeyShare[];
    }>;
    keyGen({ chainName, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        chainName: string;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<{
        rawPublicKey: EcdsaPublicKey | Uint8Array | string | undefined;
        clientKeyShares: ClientKeyShare[];
    }>;
    importRawPrivateKey({ chainName, privateKey, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        chainName: string;
        privateKey: string;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<{
        rawPublicKey: EcdsaPublicKey | Uint8Array | string | undefined;
        clientKeyShares: ClientKeyShare[];
    }>;
    serverSign({ walletId, message, isFormatted, mfaToken, context, onError, dynamicRequestId, }: {
        walletId: string;
        message: string | Uint8Array;
        dynamicRequestId: string;
        isFormatted?: boolean;
        mfaToken?: string;
        context?: SignMessageContext;
        onError?: (error: Error) => void;
    }): Promise<import("@dynamic-labs-wallet/core").OpenRoomResponse>;
    clientSign({ chainName, message, roomId, keyShare, derivationPath, isFormatted, dynamicRequestId, }: {
        chainName: string;
        message: string | Uint8Array;
        roomId: string;
        dynamicRequestId: string;
        keyShare: ClientKeyShare;
        derivationPath: Uint32Array | undefined;
        isFormatted?: boolean;
    }): Promise<Uint8Array | EcdsaSignature>;
    sign({ accountAddress, message, chainName, password, isFormatted, signedSessionId, mfaToken, context, onError, }: {
        accountAddress: string;
        message: string | Uint8Array;
        chainName: string;
        password?: string;
        isFormatted?: boolean;
        signedSessionId: string;
        mfaToken?: string;
        context?: SignMessageContext;
        onError?: (error: Error) => void;
    }): Promise<Uint8Array | EcdsaSignature>;
    refreshWalletAccountShares({ accountAddress, chainName, password, signedSessionId, mfaToken, }: {
        accountAddress: string;
        chainName: string;
        password?: string;
        signedSessionId: string;
        mfaToken?: string;
    }): Promise<void>;
    getExportId({ chainName, clientKeyShare, }: {
        chainName: string;
        clientKeyShare: EcdsaKeygenResult | ExportableEd25519KeygenResult | BIP340KeygenResult;
    }): Promise<string>;
    /**
     * Helper function to create client shares required to complete a reshare ceremony.
     * @param {string} chainName - The chain to create shares for
     * @param {WalletProperties} wallet - The wallet to reshare
     * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
     * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
     * @returns {Promise<{
     *   newClientInitKeygenResults: ClientInitKeygenResult[],
     *   newClientKeygenIds: string[],
     *   existingClientKeygenIds: string[],
     *   existingClientKeyShares: ClientKeyShare[]
     * }>} Object containing new and existing client keygen results, IDs and shares
     * @todo Support higher to lower reshare strategies
     */
    reshareStrategy({ chainName, wallet, accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, }: {
        chainName: string;
        wallet: WalletProperties;
        accountAddress: string;
        oldThresholdSignatureScheme: ThresholdSignatureScheme;
        newThresholdSignatureScheme: ThresholdSignatureScheme;
    }): Promise<{
        newClientInitKeygenResults: ClientInitKeygenResult[];
        newClientKeygenIds: string[];
        existingClientKeygenIds: string[];
        existingClientKeyShares: ClientKeyShare[];
    }>;
    reshare({ chainName, accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password, signedSessionId, backupToGoogleDrive, delegateToProjectEnvironment, mfaToken, }: {
        chainName: string;
        accountAddress: string;
        oldThresholdSignatureScheme: ThresholdSignatureScheme;
        newThresholdSignatureScheme: ThresholdSignatureScheme;
        password?: string;
        signedSessionId: string;
        backupToGoogleDrive?: boolean;
        delegateToProjectEnvironment?: boolean;
        mfaToken?: string;
    }): Promise<void>;
    delegateKeyShares({ accountAddress, password, signedSessionId, mfaToken, }: {
        accountAddress: string;
        password?: string;
        signedSessionId: string;
        mfaToken?: string;
    }): Promise<BackupLocationWithExternalKeyShareId[]>;
    exportKey({ accountAddress, chainName, password, signedSessionId, mfaToken, }: {
        accountAddress: string;
        chainName: string;
        password?: string;
        signedSessionId: string;
        mfaToken?: string;
    }): Promise<{
        derivedPrivateKey: string | undefined;
    }>;
    offlineExportKey({ chainName, keyShares, derivationPath, }: {
        chainName: string;
        keyShares: ClientKeyShare[];
        derivationPath?: string;
    }): Promise<{
        derivedPrivateKey: string | undefined;
        rawPublicKey: EcdsaPublicKey | Uint8Array | string | undefined;
    }>;
    encryptKeyShare({ keyShare, password, }: {
        keyShare: ClientKeyShare;
        password?: string;
    }): Promise<string>;
    /**
     * helper function to store encrypted backup by wallet from iframe local storage
     */
    getClientKeySharesFromLocalStorage({ accountAddress, }: {
        accountAddress: string;
    }): Promise<ClientKeyShare[]>;
    /**
     * helper function to store encrypted backup by wallet from iframe local storage
     */
    setClientKeySharesToLocalStorage({ accountAddress, clientKeyShares, overwriteOrMerge, }: {
        accountAddress: string;
        clientKeyShares: ClientKeyShare[];
        overwriteOrMerge?: 'overwrite' | 'merge';
    }): Promise<void>;
    /**
     * Central backup orchestrator that encrypts and stores wallet key shares.
     *
     * This method serves as the main backup coordinator, handling the distribution of encrypted
     * key shares between Dynamic's backend and Google Drive based on the wallet's threshold scheme.
     * It is used by multiple operations including reshare, refresh, and manual backup requests.
     *
     * **Backup Distribution Strategy:**
     * - **Single share wallets**: All shares stored on Dynamic's backend only
     * - **Multi-share wallets (2+)**: When backing up to Google Drive, N-1 shares on Dynamic's backend, 1 share on Google Drive
     * - **Multi-share wallets (2+)**: When not backing up to Google Drive, all shares on Dynamic's backend
     *
     * **Process Flow:**
     * 1. Encrypts all client key shares with the provided password (or environment ID if no password)
     * 2. For multi-share wallets (2+): conditionally distributes N-1 to backend, 1 to Google Drive
     * 3. For other configurations: stores all shares on Dynamic's backend
     * 4. Updates backup metadata and synchronizes wallet state
     * 5. Persists the updated wallet map to local storage
     *
     * @param params - The backup operation parameters
     * @param params.accountAddress - The account address of the wallet to backup
     * @param params.clientKeyShares - Optional specific key shares to backup (uses localStorage if not provided)
     * @param params.password - Optional password for encryption (uses environment ID if not provided)
     * @param params.signedSessionId - Optional signed session ID for authentication
     * @param params.backupToGoogleDrive - Whether to backup to Google Drive (defaults to false)
     * @returns Promise with backup metadata including share locations and IDs
     */
    storeEncryptedBackupByWallet({ accountAddress, clientKeyShares, password, signedSessionId, backupToGoogleDrive, delegatedLocations, }: {
        accountAddress: string;
        clientKeyShares?: ClientKeyShare[];
        password?: string;
        signedSessionId: string;
        backupToGoogleDrive?: boolean;
        delegatedLocations?: any[];
    }): Promise<any>;
    storeEncryptedBackupByWalletWithRetry({ accountAddress, clientKeyShares, password, signedSessionId, }: {
        accountAddress: string;
        clientKeyShares?: ClientKeyShare[];
        password?: string;
        signedSessionId: string;
    }): Promise<void>;
    updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId, }: {
        accountAddress: string;
        existingPassword?: string;
        newPassword?: string;
        signedSessionId: string;
    }): Promise<void>;
    decryptKeyShare({ keyShare, password, }: {
        keyShare: string;
        password?: string;
    }): Promise<ClientKeyShare>;
    /**
     * Helper function to get Google OAuth Account ID or throw an error if not found.
     * @param accountAddress - The account address for logging purposes
     * @returns The Google OAuth Account ID
     * @throws Error if no Google OAuth account ID is found
     */
    private getGoogleOauthAccountIdOrThrow;
    /**
     * Helper function to determine keyshare recovery strategy for dynamic shares.
     * For REFRESH operations, retrieves enough shares to meet the client threshold.
     * For all other operations, retrieves just 1 share.
     *
     * @param clientKeyShareBackupInfo - Information about backed up key shares
     * @param thresholdSignatureScheme - The signature scheme being used (2-of-2, 2-of-3, etc)
     * @param walletOperation - The operation being performed (REFRESH, SIGN_MESSAGE, etc)
     * @param shareCount - The number of shares to recover if specified for reshare operations
     * @returns @shares: Object mapping backup locations to arrays of share IDs to recover
     * @returns @requiredShareCount: The number of shares required to recover
     */
    recoverStrategy({ clientKeyShareBackupInfo, thresholdSignatureScheme, walletOperation, shareCount, }: {
        clientKeyShareBackupInfo: KeyShareBackupInfo;
        thresholdSignatureScheme: ThresholdSignatureScheme;
        walletOperation: WalletOperation;
        shareCount?: number;
    }): {
        shares: Partial<Record<BackupLocation, string[]>>;
        requiredShareCount: number;
    };
    recoverEncryptedBackupByWallet({ accountAddress, password, walletOperation, signedSessionId, shareCount, storeRecoveredShares, mfaToken, }: {
        accountAddress: string;
        password?: string;
        walletOperation: WalletOperation;
        signedSessionId: string;
        shareCount?: number;
        storeRecoveredShares?: boolean;
        mfaToken?: string;
    }): Promise<any[]>;
    restoreWallets(): Promise<void>;
    /**
     * This method handles the complete flow for ensuring wallet key shares are backed up to Google Drive:
     * - For 2-of-2 wallets: Automatically reshares to 2-of-3 threshold, then distributes shares (1 to backend, 1 to Google Drive)
     * - For 2-of-3 wallets: Call storeEncryptedBackupByWallet to backup for backend and Google Drive
     *
     * @param params - The backup parameters
     * @param params.accountAddress - The wallet account address to backup
     * @param params.password - Optional password for encryption (uses environment ID if not provided)
     * @param params.signedSessionId - Optional signed session ID for authentication
     * @returns Promise<string[]> - Array of Google Drive key share IDs that were backed up
     */
    backupKeySharesToGoogleDrive({ accountAddress, password, signedSessionId, }: {
        accountAddress: string;
        password?: string;
        signedSessionId: string;
    }): Promise<string[]>;
    /**
     * This method handles only the Google Drive upload mechanics without any reshare logic.
     * It encrypts the provided key shares, uploads them to Google Drive, and updates the
     * backup metadata. This method is intended for internal use by storeEncryptedBackupByWallet
     * and should not be called directly from external code.
     *
     * @param params - The upload parameters
     * @param params.accountAddress - The wallet account address
     * @param params.password - Optional password for encryption (uses environment ID if not provided)
     * @param params.encryptedKeyShares - The specific key shares to upload to Google Drive
     * @returns Promise<string[]> - Array of Google Drive key share IDs that were uploaded
     */
    private uploadKeySharesToGoogleDrive;
    restoreBackupFromGoogleDrive({ accountAddress, password, signedSessionId, }: {
        accountAddress: string;
        password?: string;
        signedSessionId: string;
    }): Promise<ClientKeyShare[]>;
    exportClientKeyshares({ accountAddress, password, signedSessionId, }: {
        accountAddress: string;
        password?: string;
        signedSessionId: string;
    }): Promise<void>;
    getClientKeyShares({ accountAddress, password, signedSessionId, }: {
        accountAddress: string;
        password?: string;
        signedSessionId: string;
    }): Promise<ClientKeyShare[]>;
    /**
     * Helper function to check if the required wallet fields are present and valid
     * @param accountAddress - The account address of the wallet to check
     * @param walletOperation - The wallet operation that determines required fields
     * @returns boolean indicating if wallet needs to be re-fetched and restored from server
     */
    private checkWalletFields;
    /**
     * verifyPassword attempts to recover and decrypt a single client key share using the provided password.
     * If successful, the key share is encrypted with the new password. This method solely performs the recovery
     * and decryption without storing the restored key shares. If unsuccessful, it throws an error.
     */
    verifyPassword({ accountAddress, password, walletOperation, signedSessionId, }: {
        accountAddress: string;
        password?: string;
        walletOperation?: WalletOperation;
        signedSessionId: string;
    }): Promise<void>;
    isPasswordEncrypted({ accountAddress, }: {
        accountAddress: string;
    }): Promise<boolean>;
    /**
     * check if the operation requires a password
     */
    requiresPasswordForOperation({ accountAddress, walletOperation, }: {
        accountAddress: string;
        walletOperation?: WalletOperation;
    }): Promise<boolean>;
    /**
     * check if the operation requires restoring backup shares
     */
    requiresRestoreBackupSharesForOperation({ accountAddress, walletOperation, }: {
        accountAddress: string;
        walletOperation?: WalletOperation;
    }): Promise<boolean>;
    getWalletClientKeyShareBackupInfo({ accountAddress, }: {
        accountAddress: string;
    }): Promise<KeyShareBackupInfo>;
    getWallet({ accountAddress, walletOperation, shareCount, password, signedSessionId, }: {
        accountAddress: string;
        walletOperation?: WalletOperation;
        shareCount?: number;
        password?: string;
        signedSessionId: string;
    }): Promise<WalletProperties>;
    getWallets(): Promise<any>;
    /**
     * sync auth token with api client
     * @param authToken - auth token to sync
     */
    syncAuthToken(authToken: string): void;
}
//# sourceMappingURL=client.d.ts.map