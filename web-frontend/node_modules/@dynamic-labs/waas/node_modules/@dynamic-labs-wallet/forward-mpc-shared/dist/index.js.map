{"version":3,"sources":["../src/types.ts","../src/messages/base.ts","../src/codecs/Uint8ArrayCodec.ts","../src/codecs/Uint32ArrayCodec.ts","../src/codecs/EncryptedKeyshareCodec.ts","../src/messages/utils/schemaBuilder.ts","../src/messages/utils/encodingHelpers.ts","../src/messages/utils/StandardMessage.ts","../src/messages/HandshakeV1Request.ts","../src/messages/HandshakeV1Response.ts","../src/signing/base.ts","../src/signing/algorithms/Ed25519SigningAlgorithm.ts","../src/signing/algorithms/BIP340SigningAlgorithm.ts","../src/signing/algorithms/EcdsaSigningAlgorithm.ts","../src/signing/allAlgorithms.ts","../src/constants/algorithms.ts","../src/codecs/DomainCodec.ts","../src/codecs/Uint8ArrayOrHexCodec.ts","../src/messages/SignMessageV1Request.ts","../src/codecs/WebSocketErrorCodec.ts","../src/messages/SignMessageV1Response.ts","../src/messages/ConnectionAckV1Request.ts","../src/messages/ConnectionAckV1Response.ts","../src/messages/allMessages.ts","../src/messages/registry.ts","../src/utils/assertDefined.ts","../src/crypto/generateKeypair.ts","../src/crypto/encapsulate.ts","../src/crypto/decapsulate.ts","../src/crypto/keyDerivation.ts","../src/crypto/keyshareEncryption.ts","../src/signing/registry.ts"],"names":["WebSocketErrorType","BaseMessage","data","getData","Uint8ArrayCodec","Type","u","Uint8Array","c","failure","cleanHex","startsWith","slice","length","test","decoded","hexToBytes","success","e","a","bytesToHex","Uint32ArrayCodec","Uint32Array","uint8Array","uint32Array","buffer","EncryptedKeyshareCodec","type","salt","encryptedPayload","buildMessageSchema","messageType","version","additionalFields","additionalSchemas","schema","literal","intersection","result","i","createComplexEncoder","fieldTransforms","encoded","key","value","Object","entries","undefined","createStandardDecoder","fieldExtractor","createStandardMessage","config","StandardMessageClass","MESSAGE_TYPE","MESSAGE_VERSION","encode","encodeData","decode","wireData","either","isLeft","right","_tag","decodeData","createSimpleMessage","HandshakeRequestSchema","challenge","nonce","HandshakeV1RequestMessage","HandshakeResponseSchema","encapsulatedSharedSecret","string","attestationDoc","connectionId","HandshakeV1ResponseMessage","BaseSigningAlgorithm","Ed25519SigningAlgorithm","algorithmName","signingAlgo","partial","derivationPath","createKeygenResultFromSecretShare","secretShare","pubkey","createSignRequest","keygenResult","params","processSignResult","_result","BIP340SigningAlgorithm","tweak","EcdsaSigningAlgorithm","hashAlgo","union","pubKeyAsHex","repeat","serializeCompressed","serializeUncompressed","SIGNING_ALGORITHM_CLASSES","ed25519","bip340","ecdsa","ALL_SIGNING_ALGORITHM_NAMES","keys","SIGNING_ALGORITHM_INSTANCES","ALL_SIGNING_ALGORITHM_SCHEMA","schemas","values","map","instance","Error","isValidSigningAlgorithm","name","algorithm","ALGORITHMS","SigningAlgorithm","ECDSA","dynamicEnum","className","requiresHashAlgo","supportsDerivationPath","supportsTweak","supportedHashAlgos","ED25519","BIP340","toDynamicSigningAlgorithm","algorithmConfig","find","fromDynamicSigningAlgorithm","dynamicAlgorithm","SignatureAlgoSchema","DomainCodec","domainPattern","identity","Uint8ArrayOrHexCodec","SignMessageRequestSchema","relayDomain","keyshare","message","roomUuid","SignMessageV1RequestMessage","WebSocketErrorTypeCodec","WebSocketErrorCodec","details","unknown","undefinedType","SignMessageResponseSchema","signature","error","SignMessageV1ResponseMessage","ConnectionAckRequestSchema","ConnectionAckV1RequestMessage","ConnectionAckResponseSchema","status","timestamp","ConnectionAckV1ResponseMessage","ALL_MESSAGE_CLASSES","ALL_MESSAGE_KEYS","getMessageClass","MessageClass","isValidMessageType","getAllSupportedMessages","versionStr","split","parseInt","parseMessageKey","MessageRegistry","getInstance","left","join","getRegisteredTypes","messageRegistry","assertDefined","assertNotNull","getDefined","generateMlKem768Keypair","ml_kem768","keygen","publicKey","secretKey","encapsulationKey","decapsulationKey","String","encapsulateMlKem768","encapsulate","decapsulateMlKem768","cipherText","decapsulate","AES_256_GCM_KEY_SIZE","AES_256_GCM_NONCE_SIZE","AES_256_GCM_TAG_SIZE","HKDF_SALT_SIZE","deriveAESKey","sharedSecret","info","infoBytes","TextEncoder","hkdf","sha256","createKeyDerivationInfo","purpose","encryptKeyshare","signingAlgorithm","randomBytes","keyshareInfo","aesKey","keyshareData","Date","now","aes256Gcm","gcm","plaintext","JSON","stringify","ciphertext","encrypt","set","fill","SigningAlgorithmRegistry","get","has","getAllNames","getAllInstances","signingAlgorithmRegistry"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Base structure for all WebSocket messages\n */\nexport interface BaseWebSocketMessage {\n  type: string;\n  version: number;\n}\n\n/**\n * WebSocket error types\n */\nexport enum WebSocketErrorType {\n  INVALID_MESSAGE = 'INVALID_MESSAGE',\n  HANDLER_NOT_FOUND = 'HANDLER_NOT_FOUND',\n  HANDLER_ERROR = 'HANDLER_ERROR',\n  CONNECTION_ERROR = 'CONNECTION_ERROR',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n}\n\n/**\n * Structured WebSocket error\n */\nexport interface WebSocketError {\n  type: WebSocketErrorType;\n  message: string;\n  details?: unknown;\n}\n\n/**\n * Standard error response format\n */\nexport interface ErrorResponse extends BaseWebSocketMessage {\n  type: 'error';\n  error: WebSocketError;\n}\n\n/**\n * WebSocket connection context (client-side version without ws instance)\n */\nexport interface WebSocketConnectionInfo {\n  id: string;\n  connectedAt: Date;\n  lastActivity: Date;\n  metadata?: Record<string, unknown>;\n}\n","/**\n * Base interface for all messages\n */\nexport interface IMessage<TRuntime = any, TWire = any> {\n  readonly type: string;\n  readonly version: number;\n\n  /**\n   * Encode this message to wire format for transmission\n   */\n  encode(): TWire;\n\n  /**\n   * Get the runtime data of this message\n   */\n  getData(): TRuntime;\n}\n\n/**\n * Abstract base class for all messages\n */\nexport abstract class BaseMessage<TRuntime = any, TWire = any>\n  implements IMessage<TRuntime, TWire>\n{\n  abstract readonly type: string;\n  abstract readonly version: number;\n\n  protected constructor(public readonly data: TRuntime) {}\n\n  abstract encode(): TWire;\n\n  getData(): TRuntime {\n    return this.data;\n  }\n}\n","import { failure, success, Type } from 'io-ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\n\nexport const Uint8ArrayCodec = new Type<\n  Uint8Array, // A: The runtime type (the type you work with in your code)\n  string, // O: The encoded output type (e.g., JSON representation)\n  unknown // I: The input type (e.g., from JSON)\n>(\n  'Uint8Array', // The name of the codec\n  (u): u is Uint8Array => u instanceof Uint8Array, // A type guard\n  (u, c) => {\n    // The `validate` function for decoding\n    if (typeof u !== 'string') {\n      return failure(u, c, 'Expected a hex string for Uint8Array');\n    }\n    try {\n      // Remove any '0x' prefix if present\n      const cleanHex = u.startsWith('0x') ? u.slice(2) : u;\n\n      // Validate hex string (must be even length and contain only hex characters)\n      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {\n        return failure(u, c, 'Invalid hex string format');\n      }\n\n      const decoded = hexToBytes(cleanHex);\n      return success(decoded);\n    } catch (e) {\n      return failure(u, c, `Invalid hex string: ${e}`);\n    }\n  },\n  // The `encode` function for converting back to the output type\n  (a) => bytesToHex(a)\n);\n","import { failure, success, Type } from 'io-ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\n\nexport const Uint32ArrayCodec = new Type<\n  Uint32Array, // A: The runtime type (the type you work with in your code)\n  string, // O: The encoded output type (e.g., JSON representation)\n  unknown // I: The input type (e.g., from JSON)\n>(\n  'Uint32Array', // The name of the codec\n  (u): u is Uint32Array => u instanceof Uint32Array, // A type guard\n  (u, c) => {\n    // The `validate` function for decoding\n    if (typeof u !== 'string') {\n      return failure(u, c, 'Expected a hex string for Uint32Array');\n    }\n    try {\n      // Remove any '0x' prefix if present\n      const cleanHex = u.startsWith('0x') ? u.slice(2) : u;\n\n      // Validate hex string (must be multiple of 8 characters for 32-bit values)\n      if (cleanHex.length === 0) {\n        return failure(u, c, 'Empty hex string not allowed for Uint32Array');\n      }\n      if (cleanHex.length % 8 !== 0) {\n        return failure(\n          u,\n          c,\n          'Invalid hex string format for Uint32Array (must be multiple of 8 hex characters)'\n        );\n      }\n\n      // Convert hex string to Uint8Array using noble-hashes\n      const uint8Array = hexToBytes(cleanHex);\n\n      // Convert Uint8Array to Uint32Array by interpreting the buffer\n      // Note: This assumes little-endian byte order\n      const uint32Array = new Uint32Array(uint8Array.buffer);\n\n      return success(uint32Array);\n    } catch (e) {\n      return failure(u, c, `Invalid hex string: ${e}`);\n    }\n  },\n  // The `encode` function for converting back to the output type\n  (a) => {\n    // Convert Uint32Array to Uint8Array to use noble-hashes\n    const uint8Array = new Uint8Array(a.buffer);\n    return bytesToHex(uint8Array);\n  }\n);\n","import { type, TypeOf } from 'io-ts';\nimport { Uint8ArrayCodec } from './Uint8ArrayCodec';\n\n/**\n * Encrypted keyshare structure for secure transmission\n * Contains HKDF salt and AES-256-GCM encrypted payload\n */\nexport const EncryptedKeyshareCodec = type({\n  salt: Uint8ArrayCodec,\n  encryptedPayload: Uint8ArrayCodec,\n});\n\nexport type EncryptedKeyshare = TypeOf<typeof EncryptedKeyshareCodec>;\n","import { intersection, literal, Mixed, type, Type } from 'io-ts';\n\n/**\n * Build standard message schema with type and version\n * Eliminates duplication across all message schemas\n */\nexport function buildMessageSchema<T extends string, V extends number>(\n  messageType: T,\n  version: V,\n  additionalFields: Record<string, any> = {},\n  ...additionalSchemas: Mixed[]\n): Type<any> {\n  const schema = type({\n    type: literal(messageType),\n    version: literal(version),\n    ...additionalFields,\n  });\n\n  if (additionalSchemas.length === 0) {\n    return schema;\n  }\n\n  if (additionalSchemas.length === 1) {\n    return intersection([schema, additionalSchemas[0]]);\n  }\n\n  // For multiple schemas, chain intersections\n  let result: Type<any> = intersection([schema, additionalSchemas[0]]);\n  for (let i = 1; i < additionalSchemas.length; i++) {\n    result = intersection([result, additionalSchemas[i]]);\n  }\n  return result;\n}\n\n/**\n * Message schema configuration interface\n */\nexport interface MessageSchemaConfig<T extends string, V extends number> {\n  type: T;\n  version: V;\n  fields: Record<string, any>;\n}\n\n/**\n * Create schema from configuration\n */\nexport function createSchemaFromConfig<T extends string, V extends number>(\n  config: MessageSchemaConfig<T, V>\n): Type<any> {\n  return buildMessageSchema(config.type, config.version, config.fields);\n}\n","/**\n * Standard encoder for simple messages\n * Creates basic encode function with type and version\n */\nexport function createSimpleEncoder<TData, TWire>(\n  messageType: string,\n  version: number\n) {\n  return (data: TData): TWire =>\n    ({\n      type: messageType,\n      version,\n      ...data,\n    }) as TWire;\n}\n\n/**\n * Standard encoder for complex messages with codec transformations\n * Handles field transformations like Uint8Array -> hex string\n */\nexport function createComplexEncoder<TData, TWire>(\n  messageType: string,\n  version: number,\n  fieldTransforms: Record<string, (value: any) => any> = {}\n) {\n  return (data: TData): TWire => {\n    const encoded: any = {\n      type: messageType,\n      version,\n    };\n\n    // Apply field transformations\n    for (const [key, value] of Object.entries(data as any)) {\n      if (value !== undefined) {\n        encoded[key] = fieldTransforms[key]\n          ? fieldTransforms[key](value)\n          : value;\n      }\n    }\n\n    return encoded as TWire;\n  };\n}\n\n/**\n * Standard decoder with field extraction\n * Extracts runtime data from decoded wire format\n */\nexport function createStandardDecoder<TData>(\n  fieldExtractor: (decoded: any) => TData\n) {\n  return (decoded: any): TData => fieldExtractor(decoded);\n}\n\n/**\n * Identity decoder for simple messages where wire format matches runtime format\n */\nexport function createIdentityDecoder<TData>(): (decoded: any) => TData {\n  return (decoded: any): TData => {\n    // Remove type and version fields, keep the rest\n    const { type, version, ...data } = decoded;\n    return data as TData;\n  };\n}\n","import { either } from 'fp-ts';\nimport { Errors, Type } from 'io-ts';\nimport { BaseMessage, IMessage } from '../base';\n\n/**\n * Configuration for creating a standard message class\n */\nexport interface StandardMessageConfig<\n  TData,\n  TWire,\n  TType extends string,\n  TVersion extends number,\n> {\n  messageType: TType;\n  version: TVersion;\n  schema: Type<any>;\n  encodeData: (data: TData, type: TType, version: TVersion) => TWire;\n  decodeData: (decoded: any) => TData;\n}\n\n/**\n * Standard message class factory - eliminates boilerplate\n * Creates a complete message class with encode/decode functionality\n */\nexport function createStandardMessage<\n  TData,\n  TWire,\n  TType extends string,\n  TVersion extends number,\n>(config: StandardMessageConfig<TData, TWire, TType, TVersion>) {\n  class StandardMessageClass\n    extends BaseMessage<TData, TWire>\n    implements IMessage<TData, TWire>\n  {\n    static readonly MESSAGE_TYPE = config.messageType;\n    static readonly MESSAGE_VERSION = config.version;\n    static readonly schema = config.schema;\n\n    readonly type = config.messageType;\n    readonly version = config.version;\n\n    constructor(data: TData) {\n      super(data);\n    }\n\n    encode(): TWire {\n      return config.encodeData(this.data, this.type, this.version);\n    }\n\n    static decode(\n      wireData: unknown\n    ): either.Either<Errors, StandardMessageClass> {\n      const result = config.schema.decode(wireData);\n      if (either.isLeft(result)) {\n        return result;\n      }\n\n      const decoded = result.right;\n      return {\n        _tag: 'Right',\n        right: new StandardMessageClass(config.decodeData(decoded)),\n      };\n    }\n  }\n\n  return StandardMessageClass;\n}\n\n/**\n * Type helper to extract the message class type from createStandardMessage\n */\nexport type StandardMessageClass<\n  TData,\n  TWire,\n  TType extends string,\n  TVersion extends number,\n> = ReturnType<typeof createStandardMessage<TData, TWire, TType, TVersion>>;\n\n/**\n * Simplified message factory for messages with identical runtime and wire formats\n */\nexport function createSimpleMessage<\n  TData,\n  TType extends string,\n  TVersion extends number,\n>(config: { messageType: TType; version: TVersion; schema: Type<any> }) {\n  return createStandardMessage({\n    messageType: config.messageType,\n    version: config.version,\n    schema: config.schema,\n    encodeData: (data: TData) =>\n      ({\n        type: config.messageType,\n        version: config.version,\n        ...data,\n      }) as any,\n    decodeData: (decoded: any) => {\n      const { type, version, ...data } = decoded;\n      return data as TData;\n    },\n  });\n}\n\n/**\n * Message factory with field transformations - eliminates encodeData/decodeData duplication\n */\nexport function createMessageWithTransforms<\n  TData,\n  TWire = TData & { type: string; version: number },\n  TType extends string = string,\n  TVersion extends number = number,\n>(config: {\n  messageType: TType;\n  version: TVersion;\n  schema: Type<any>;\n  transforms?: Record<string, (value: any) => any>;\n  normalizers?: Partial<Record<keyof TData, (input: any) => any>>;\n}) {\n  return createStandardMessage({\n    messageType: config.messageType,\n    version: config.version,\n    schema: config.schema,\n    encodeData: (data: TData) => {\n      const encoded: any = {\n        type: config.messageType,\n        version: config.version,\n      };\n\n      // Apply field transformations\n      const dataObj = data as Record<string, any>;\n      for (const [key, value] of Object.entries(dataObj)) {\n        if (value !== undefined) {\n          const transform = config.transforms?.[key];\n          encoded[key] = transform ? transform(value) : value;\n        }\n      }\n\n      return encoded as TWire;\n    },\n    decodeData: (decoded: any) => {\n      // Apply normalizers to convert wire format to runtime format\n      const normalizedData: any = { ...decoded };\n\n      if (config.normalizers) {\n        for (const [key, normalizer] of Object.entries(config.normalizers)) {\n          if (\n            key in normalizedData &&\n            normalizer &&\n            typeof normalizer === 'function' &&\n            normalizedData[key] !== undefined\n          ) {\n            const normalizedValue = normalizer(normalizedData[key]);\n            if (normalizedValue !== undefined) {\n              normalizedData[key] = normalizedValue;\n            }\n          }\n        }\n      }\n\n      // Remove type and version, return runtime data\n      const { type, version, ...data } = normalizedData;\n      return data as TData;\n    },\n  });\n}\n","import { TypeOf } from 'io-ts';\nimport { Uint8ArrayCodec } from '../codecs';\nimport {\n  buildMessageSchema,\n  createStandardMessage,\n  createStandardDecoder,\n} from './utils';\n\n/**\n * Handshake Request Runtime Data\n */\nexport interface HandshakeRequestData {\n  challenge: Uint8Array;\n  nonce: Uint8Array;\n}\n\n/**\n * Handshake Request Wire Format\n */\nexport interface HandshakeRequestWire {\n  type: 'handshake';\n  version: 1;\n  challenge: string; // hex string\n  nonce: string; // hex string\n}\n\n/**\n * Handshake Request Schema (built using Ultra-DRY utilities)\n */\nexport const HandshakeRequestSchema = buildMessageSchema('handshake', 1, {\n  challenge: Uint8ArrayCodec,\n  nonce: Uint8ArrayCodec,\n});\n\nexport type HandshakeRequest = TypeOf<typeof HandshakeRequestSchema>;\n\n/**\n * Handshake V1 Request Message Class (Ultra-DRY implementation)\n */\nexport const HandshakeV1RequestMessage = createStandardMessage({\n  messageType: 'handshake' as const,\n  version: 1 as const,\n  schema: HandshakeRequestSchema,\n  encodeData: (data: HandshakeRequestData): HandshakeRequestWire =>\n    HandshakeRequestSchema.encode({\n      type: 'handshake',\n      version: 1,\n      challenge: data.challenge,\n      nonce: data.nonce,\n    }),\n  decodeData: createStandardDecoder<HandshakeRequestData>((decoded) => ({\n    challenge: decoded.challenge,\n    nonce: decoded.nonce,\n  })),\n});\n","import { string, TypeOf } from 'io-ts';\nimport { buildMessageSchema, createSimpleMessage } from './utils';\n\n/**\n * Handshake Response Runtime Data\n */\nexport interface HandshakeResponseData {\n  encapsulatedSharedSecret: string; // hex-encoded\n  attestationDoc: string; // hex-encoded\n  connectionId: string; // Server's connection ID for key derivation\n}\n\n/**\n * Handshake Response Wire Format\n */\nexport interface HandshakeResponseWire {\n  type: 'handshake_response';\n  version: 1;\n  encapsulatedSharedSecret: string; // hex-encoded\n  attestationDoc: string; // base64-encoded\n  connectionId: string; // Server's connection ID for key derivation\n}\n\n/**\n * Handshake Response Schema (built using Ultra-DRY utilities)\n */\nexport const HandshakeResponseSchema = buildMessageSchema(\n  'handshake_response',\n  1,\n  {\n    encapsulatedSharedSecret: string,\n    attestationDoc: string,\n    connectionId: string,\n  }\n);\n\nexport type HandshakeResponse = TypeOf<typeof HandshakeResponseSchema>;\n\n/**\n * Handshake V1 Response Message Class (Ultra-DRY implementation)\n */\nexport const HandshakeV1ResponseMessage = createSimpleMessage<\n  HandshakeResponseData,\n  'handshake_response',\n  1\n>({\n  messageType: 'handshake_response',\n  version: 1,\n  schema: HandshakeResponseSchema,\n});\n\n// HandshakeResponse naturally implements IMessageConstructor through its static properties\n","import type { Type } from 'io-ts';\n\n/**\n * Base secret share data (what gets encrypted)\n */\nexport interface SecretShareData {\n  secretShare: string;\n  signingAlgorithm: string;\n  timestamp: number;\n  nonce: string;\n}\n\n/**\n * Decrypted secret share with reconstructed keygen result\n */\nexport interface DecryptedSecretShare {\n  keygenResult: any;\n  signingAlgorithm: string;\n  timestamp: number;\n  nonce: string;\n}\n\n/**\n * Base interface for signing algorithm implementations\n */\nexport interface ISigningAlgorithm {\n  readonly algorithmName: string;\n  readonly version: number;\n  readonly schema: Type<any>;\n\n  createKeygenResultFromSecretShare(secretShare: string): any;\n  createSignRequest(keygenResult: any, params: any): any;\n  processSignResult(result: any): Uint8Array;\n}\n\n/**\n * Base signing algorithm class\n */\nexport abstract class BaseSigningAlgorithm implements ISigningAlgorithm {\n  abstract readonly algorithmName: string;\n  abstract readonly version: number;\n  abstract readonly schema: Type<any>;\n\n  abstract createKeygenResultFromSecretShare(secretShare: string): any;\n  abstract createSignRequest(keygenResult: any, params: any): any;\n  abstract processSignResult(result: any): Uint8Array;\n}\n","import { BaseSigningAlgorithm } from '../base';\nimport { intersection, literal, partial, type } from 'io-ts';\nimport { Uint32ArrayCodec } from '../../codecs';\n\nexport interface Ed25519SignMessageSchema {\n  signingAlgo: 'ed25519';\n  derivationPath?: Uint32Array;\n}\n\nexport class Ed25519SigningAlgorithm extends BaseSigningAlgorithm {\n  readonly algorithmName = 'ed25519' as const;\n  readonly version = 1;\n\n  readonly schema = intersection([\n    type({\n      signingAlgo: literal('ed25519'),\n    }),\n    partial({\n      derivationPath: Uint32ArrayCodec,\n    }),\n  ]);\n\n  createKeygenResultFromSecretShare(secretShare: string): any {\n    return {\n      secretShare,\n      pubkey: new Uint8Array(32), // Mock pubkey\n    };\n  }\n\n  createSignRequest(keygenResult: any, params: any): any {\n    return {\n      secretShare: keygenResult.secretShare,\n      ...params,\n    };\n  }\n\n  processSignResult(_result: any): Uint8Array {\n    return new Uint8Array(64);\n  }\n}\n","import { BaseSigningAlgorithm } from '../base';\nimport { intersection, literal, partial, type } from 'io-ts';\nimport { Uint32ArrayCodec, Uint8ArrayCodec } from '../../codecs';\n\nexport interface BIP340SignMessageSchema {\n  signingAlgo: 'bip340';\n  derivationPath?: Uint32Array;\n  tweak?: Uint8Array;\n}\n\nexport class BIP340SigningAlgorithm extends BaseSigningAlgorithm {\n  readonly algorithmName = 'bip340' as const;\n  readonly version = 1;\n\n  readonly schema = intersection([\n    type({\n      signingAlgo: literal('bip340'),\n    }),\n    partial({\n      derivationPath: Uint32ArrayCodec,\n      tweak: Uint8ArrayCodec,\n    }),\n  ]);\n\n  createKeygenResultFromSecretShare(secretShare: string): any {\n    return {\n      secretShare,\n      pubkey: new Uint8Array(32), // Mock pubkey\n    };\n  }\n\n  createSignRequest(keygenResult: any, params: any): any {\n    return {\n      secretShare: keygenResult.secretShare,\n      ...params,\n    };\n  }\n\n  processSignResult(_result: any): Uint8Array {\n    return new Uint8Array(64);\n  }\n}\n","import { BaseSigningAlgorithm } from '../base';\nimport { intersection, literal, partial, type, union } from 'io-ts';\nimport { Uint32ArrayCodec } from '../../codecs';\n\nexport interface EcdsaSignMessageSchema {\n  signingAlgo: 'ecdsa';\n  hashAlgo: 'sha256' | 'sha256d' | 'keccak256';\n  derivationPath?: Uint32Array;\n}\n\nexport class EcdsaSigningAlgorithm extends BaseSigningAlgorithm {\n  readonly algorithmName = 'ecdsa' as const;\n  readonly version = 1;\n\n  readonly schema = intersection([\n    type({\n      signingAlgo: literal('ecdsa'),\n    }),\n    partial({\n      hashAlgo: union([\n        literal('sha256'),\n        literal('sha256d'),\n        literal('keccak256'),\n      ]),\n      derivationPath: Uint32ArrayCodec,\n    }),\n  ]);\n\n  createKeygenResultFromSecretShare(secretShare: string): any {\n    return {\n      secretShare,\n      pubkey: {\n        pubKeyAsHex: () => '0x' + '00'.repeat(33),\n        serializeCompressed: () => new Uint8Array(33),\n        serializeUncompressed: () => new Uint8Array(65),\n      },\n    };\n  }\n\n  createSignRequest(keygenResult: any, params: any): any {\n    return {\n      secretShare: keygenResult.secretShare,\n      ...params,\n    };\n  }\n\n  processSignResult(_result: any): Uint8Array {\n    return new Uint8Array(64);\n  }\n}\n","import { union, type Type } from 'io-ts';\nimport {\n  Ed25519SigningAlgorithm,\n  type Ed25519SignMessageSchema,\n} from './algorithms/Ed25519SigningAlgorithm';\nimport {\n  BIP340SigningAlgorithm,\n  type BIP340SignMessageSchema,\n} from './algorithms/BIP340SigningAlgorithm';\nimport {\n  EcdsaSigningAlgorithm,\n  type EcdsaSignMessageSchema,\n} from './algorithms/EcdsaSigningAlgorithm';\nimport type { ISigningAlgorithm } from './base';\n\n/**\n * üéØ SINGLE SOURCE OF TRUTH - Add new algorithms here and everything else is automatic!\n * This is the ONLY place you need to add new signing algorithms\n */\nexport const SIGNING_ALGORITHM_CLASSES = {\n  ed25519: Ed25519SigningAlgorithm,\n  bip340: BIP340SigningAlgorithm,\n  ecdsa: EcdsaSigningAlgorithm,\n} as const;\n\n/**\n * üìù Explicit union type of all signing algorithm schemas\n * (Only other place you need to add new algorithms)\n */\nexport type AllSigningAlgorithmSchemas =\n  | Ed25519SignMessageSchema\n  | BIP340SignMessageSchema\n  | EcdsaSignMessageSchema;\n\n// ========================================\n// ü§ñ EVERYTHING BELOW IS AUTOMATICALLY DERIVED\n// ========================================\n\n/**\n * Derive signing algorithm name type from classes\n */\nexport type SigningAlgorithmName = keyof typeof SIGNING_ALGORITHM_CLASSES;\n\n/**\n * Derive runtime array of algorithm names from classes\n */\nexport const ALL_SIGNING_ALGORITHM_NAMES = Object.keys(\n  SIGNING_ALGORITHM_CLASSES\n) as SigningAlgorithmName[];\n\n/**\n * Create algorithm instances (derived from classes)\n */\nexport const SIGNING_ALGORITHM_INSTANCES: Record<\n  SigningAlgorithmName,\n  ISigningAlgorithm\n> = {\n  ed25519: new SIGNING_ALGORITHM_CLASSES.ed25519(),\n  bip340: new SIGNING_ALGORITHM_CLASSES.bip340(),\n  ecdsa: new SIGNING_ALGORITHM_CLASSES.ecdsa(),\n};\n\n/**\n * Create union schema (derived from instances)\n */\nexport const ALL_SIGNING_ALGORITHM_SCHEMA: Type<AllSigningAlgorithmSchemas> =\n  (() => {\n    const schemas = Object.values(SIGNING_ALGORITHM_INSTANCES).map(\n      (instance) => instance.schema\n    );\n\n    if (schemas.length === 0) {\n      throw new Error('No signing algorithms defined');\n    }\n\n    if (schemas.length === 1) {\n      return schemas[0] as Type<AllSigningAlgorithmSchemas>;\n    }\n\n    return union([\n      schemas[0],\n      schemas[1],\n      ...schemas.slice(2),\n    ]) as Type<AllSigningAlgorithmSchemas>;\n  })();\n\n/**\n * Helper type to extract algorithm-specific schema\n */\nexport type SigningAlgorithmSchemaFor<\n  T extends AllSigningAlgorithmSchemas['signingAlgo'],\n> = Extract<AllSigningAlgorithmSchemas, { signingAlgo: T }>;\n\n/**\n * Utility to check if a string is a valid signing algorithm name\n */\nexport function isValidSigningAlgorithm(\n  name: string\n): name is SigningAlgorithmName {\n  return name in SIGNING_ALGORITHM_CLASSES;\n}\n\n/**\n * Create keygen result from secret share using algorithm-specific logic\n */\nexport function createKeygenResultFromSecretShare(\n  algorithmName: SigningAlgorithmName,\n  secretShare: string\n): any {\n  const algorithm = SIGNING_ALGORITHM_INSTANCES[algorithmName];\n  if (!algorithm) {\n    throw new Error(`Unknown signing algorithm: ${algorithmName}`);\n  }\n  return algorithm.createKeygenResultFromSecretShare(secretShare);\n}\n","import {\n  ALL_SIGNING_ALGORITHM_SCHEMA,\n  type AllSigningAlgorithmSchemas,\n  type SigningAlgorithmName,\n} from '../signing/allAlgorithms';\nimport { SigningAlgorithm } from '@dynamic-labs-wallet/core';\n\n/**\n * Algorithm configurations for complex properties\n * Maps Dynamic SDK enum values to our internal algorithm names\n */\nexport const ALGORITHMS = {\n  [SigningAlgorithm.ECDSA]: {\n    name: 'ecdsa' as const,\n    dynamicEnum: SigningAlgorithm.ECDSA,\n    className: 'Ecdsa' as const,\n    requiresHashAlgo: true,\n    supportsDerivationPath: true,\n    supportsTweak: false,\n    supportedHashAlgos: ['sha256', 'sha256d', 'keccak256'] as const,\n  },\n  [SigningAlgorithm.ED25519]: {\n    name: 'ed25519' as const,\n    dynamicEnum: SigningAlgorithm.ED25519,\n    className: 'Ed25519' as const,\n    requiresHashAlgo: false,\n    supportsDerivationPath: true,\n    supportsTweak: false,\n    supportedHashAlgos: [] as const,\n  },\n  [SigningAlgorithm.BIP340]: {\n    name: 'bip340' as const,\n    dynamicEnum: SigningAlgorithm.BIP340,\n    className: 'BIP340' as const,\n    requiresHashAlgo: false,\n    supportsDerivationPath: true,\n    supportsTweak: true,\n    supportedHashAlgos: [] as const,\n  },\n} as const;\n\n/**\n * Type definitions - use Dynamic SDK's SigningAlgorithm enum\n */\nexport type HashAlgorithm = 'sha256' | 'sha256d' | 'keccak256';\n\n/**\n * Helper function to convert our internal algorithm names to Dynamic SDK enum values\n */\nexport function toDynamicSigningAlgorithm(\n  algorithmName: SigningAlgorithmName\n): SigningAlgorithm {\n  const algorithmConfig = Object.values(ALGORITHMS).find(\n    (config) => config.name === algorithmName\n  );\n  if (!algorithmConfig) {\n    throw new Error(`Unknown algorithm: ${algorithmName}`);\n  }\n  return algorithmConfig.dynamicEnum;\n}\n\n/**\n * Helper function to convert Dynamic SDK enum values to our internal algorithm names\n */\nexport function fromDynamicSigningAlgorithm(\n  dynamicAlgorithm: SigningAlgorithm\n): SigningAlgorithmName {\n  const algorithmConfig = ALGORITHMS[dynamicAlgorithm];\n  if (!algorithmConfig) {\n    throw new Error(`Unknown Dynamic SDK algorithm: ${dynamicAlgorithm}`);\n  }\n  return algorithmConfig.name;\n}\n\n/**\n * Union schema derived from algorithm instances (no more manual schema generation!)\n */\nexport const SignatureAlgoSchema = ALL_SIGNING_ALGORITHM_SCHEMA;\n\n/**\n * Export the union type for external use\n */\nexport type { AllSigningAlgorithmSchemas as SigningAlgorithmSchemas };\n","import { Type, failure, success, identity } from 'io-ts';\n\n/**\n * Codec for validating domain names without protocol or paths.\n * Allows optional port numbers.\n * Examples:\n * - example.com\n * - sub.example.com\n * - example.com:8080\n */\nexport const DomainCodec = new Type<string>(\n  'DomainCodec',\n  (u): u is string => typeof u === 'string',\n  (u, c) => {\n    if (typeof u !== 'string') {\n      return failure(u, c, 'Value must be a string');\n    }\n\n    // Domain regex pattern:\n    // - Starts with alphanumeric or hyphen\n    // - Can contain dots for subdomains\n    // - Optional port number at the end\n    // - No protocols or paths allowed\n    const domainPattern =\n      /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?::\\d{1,5})?$/;\n\n    if (!domainPattern.test(u)) {\n      return failure(u, c, 'Invalid domain format');\n    }\n\n    return success(u);\n  },\n  identity\n);\n","import { failure, success, Type } from 'io-ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\n\nexport const Uint8ArrayOrHexCodec = new Type<\n  Uint8Array | string, // A: The runtime type (the type you work with in your code)\n  string, // O: The encoded output type (e.g., JSON representation)\n  string | unknown // I: The input type (e.g., from JSON)\n>(\n  'Uint8ArrayOrHex', // The name of the codec\n  (u): u is Uint8Array => u instanceof Uint8Array, // A type guard\n  (u, c) => {\n    // Handle Uint8Array input (already in correct format)\n    if ((u as any) instanceof Uint8Array) {\n      return success(u as unknown as Uint8Array);\n    }\n\n    // Handle string input (hex string)\n    if (typeof u !== 'string') {\n      return failure(u, c, 'Expected a hex string or Uint8Array');\n    }\n\n    try {\n      // Remove any '0x' prefix if present\n      const cleanHex = u.startsWith('0x') ? u.slice(2) : u;\n\n      // Validate hex string (must be even length and contain only hex characters)\n      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {\n        return failure(u, c, 'Invalid hex string format');\n      }\n\n      const decoded = hexToBytes(cleanHex);\n      return success(decoded);\n    } catch (e) {\n      return failure(u, c, `Invalid hex string: ${e}`);\n    }\n  },\n  // The `encode` function for converting back to the output type\n  (a) => {\n    if (typeof a === 'string') {\n      return a;\n    }\n    return bytesToHex(a);\n  }\n);\n","import { string, TypeOf } from 'io-ts';\nimport { Uint32ArrayCodec, Uint8ArrayCodec } from '../codecs';\nimport {\n  HashAlgorithm,\n  SignatureAlgoSchema,\n  fromDynamicSigningAlgorithm,\n} from '../constants';\nimport { DomainCodec } from '../codecs/DomainCodec';\nimport {\n  EncryptedKeyshareCodec,\n  type EncryptedKeyshare,\n} from '../codecs/EncryptedKeyshareCodec';\nimport {\n  buildMessageSchema,\n  createStandardMessage,\n  createStandardDecoder,\n  createComplexEncoder,\n} from './utils';\nimport { Uint8ArrayOrHexCodec } from '../codecs/Uint8ArrayOrHexCodec';\nimport { SigningAlgorithm } from '@dynamic-labs-wallet/core';\n\n/**\n * Sign Message Request Runtime Data\n */\nexport interface SignMessageRequestData {\n  relayDomain: string;\n  signingAlgo: SigningAlgorithm;\n  hashAlgo?: HashAlgorithm;\n  derivationPath?: Uint32Array;\n  tweak?: Uint8Array;\n  keyshare: EncryptedKeyshare;\n  message: Uint8Array | string;\n  roomUuid: string;\n}\n\n/**\n * Sign Message Request Wire Format\n */\nexport interface SignMessageRequestWire {\n  type: 'signMessage';\n  version: 1;\n  relayDomain: string;\n  signingAlgo: SigningAlgorithm;\n  hashAlgo?: HashAlgorithm;\n  derivationPath?: string; // hex string\n  tweak?: string; // hex string\n  keyshare: {\n    salt: string; // hex string\n    encryptedPayload: string; // hex string\n  };\n  message: string; // hex string\n  roomUuid: string;\n}\n\n/**\n * Sign Message Request Schema - uses codecs that handle both formats automatically\n */\nexport const SignMessageRequestSchema = buildMessageSchema(\n  'signMessage',\n  1,\n  {\n    relayDomain: DomainCodec,\n    keyshare: EncryptedKeyshareCodec,\n    message: Uint8ArrayOrHexCodec,\n    roomUuid: string,\n  },\n  SignatureAlgoSchema\n);\n\nexport type SignMessageRequest = TypeOf<typeof SignMessageRequestSchema>;\n\n/**\n * Sign Message V1 Request Message Class - Clean implementation using createComplexEncoder\n */\nexport const SignMessageV1RequestMessage = createStandardMessage({\n  messageType: 'signMessage' as const,\n  version: 1 as const,\n  schema: SignMessageRequestSchema,\n  encodeData: createComplexEncoder('signMessage', 1, {\n    signingAlgo: (value: SigningAlgorithm) =>\n      fromDynamicSigningAlgorithm(value),\n    derivationPath: (value: Uint32Array) => Uint32ArrayCodec.encode(value),\n    tweak: (value: Uint8Array) => Uint8ArrayCodec.encode(value),\n    keyshare: (value: EncryptedKeyshare) =>\n      EncryptedKeyshareCodec.encode(value),\n    message: (value: Uint8Array | string) => Uint8ArrayOrHexCodec.encode(value),\n  }),\n  decodeData: createStandardDecoder<SignMessageRequestData>((decoded) => ({\n    relayDomain: decoded.relayDomain,\n    signingAlgo: decoded.signingAlgo,\n    hashAlgo: decoded.hashAlgo,\n    derivationPath: decoded.derivationPath,\n    tweak: decoded.tweak,\n    keyshare: decoded.keyshare,\n    message: decoded.message,\n    roomUuid: decoded.roomUuid,\n  })),\n});\n","import {\n  type,\n  string,\n  union,\n  undefined as undefinedType,\n  unknown,\n  TypeOf,\n} from 'io-ts';\n\n/**\n * WebSocket Error Type Codec\n */\nexport const WebSocketErrorTypeCodec = string; // Just use string directly\n\n/**\n * WebSocket Error Codec\n */\nexport const WebSocketErrorCodec = type({\n  type: WebSocketErrorTypeCodec,\n  message: string,\n  details: union([unknown, undefinedType]), // Optional details field\n});\n\nexport type WebSocketErrorValidated = TypeOf<typeof WebSocketErrorCodec>;\n","import { TypeOf, union, undefined as undefinedType } from 'io-ts';\nimport {\n  buildMessageSchema,\n  createStandardMessage,\n  createComplexEncoder,\n  createStandardDecoder,\n} from './utils';\nimport { WebSocketError } from '../types';\nimport { WebSocketErrorCodec } from '../codecs/WebSocketErrorCodec';\nimport { Uint8ArrayOrHexCodec } from '../codecs/Uint8ArrayOrHexCodec';\n\n/**\n * Sign Message Response Runtime Data\n */\nexport interface SignMessageResponseData {\n  signature?: Uint8Array; // The signature as byte array - present on success\n  error?: WebSocketError; // Error details - present on failure\n}\n\n/**\n * Sign Message Response Wire Format\n */\nexport interface SignMessageResponseWire {\n  type: 'signMessage_response';\n  version: 1;\n  signature?: string; // The signature (hex-encoded) - present on success\n  error?: WebSocketError; // Error details - present on failure\n}\n\n/**\n * Sign Message Response Schema (built using Ultra-DRY utilities)\n * Schema expects wire format types (string for signature)\n */\nexport const SignMessageResponseSchema = buildMessageSchema(\n  'signMessage_response',\n  1,\n  {\n    signature: union([Uint8ArrayOrHexCodec, undefinedType]), // Codec handles both hex string and Uint8Array\n    error: union([WebSocketErrorCodec, undefinedType]),\n  }\n);\n\nexport type SignMessageResponse = TypeOf<typeof SignMessageResponseSchema>;\n\n/**\n * Sign Message V1 Response Message Class (Ultra-DRY implementation)\n */\nexport const SignMessageV1ResponseMessage = createStandardMessage<\n  SignMessageResponseData,\n  SignMessageResponseWire,\n  'signMessage_response',\n  1\n>({\n  messageType: 'signMessage_response',\n  version: 1,\n  schema: SignMessageResponseSchema,\n  encodeData: createComplexEncoder('signMessage_response', 1, {\n    signature: (value: Uint8Array) => Uint8ArrayOrHexCodec.encode(value),\n  }),\n  decodeData: createStandardDecoder<SignMessageResponseData>((decoded) => ({\n    signature: decoded.signature,\n    error: decoded.error,\n  })),\n});\n","import { union, string, undefined as undefinedType, TypeOf } from 'io-ts';\nimport { buildMessageSchema, createSimpleMessage } from './utils';\n\n/**\n * Connection Acknowledgment Request Runtime Data\n */\nexport interface ConnectionAckRequestData {\n  connectionId?: string;\n}\n\n/**\n * Connection Acknowledgment Request Wire Format\n */\nexport interface ConnectionAckRequestWire {\n  type: 'connection_ack';\n  version: 1;\n  connectionId?: string;\n}\n\n/**\n * Connection Acknowledgment Request Schema (built using Ultra-DRY utilities)\n */\nexport const ConnectionAckRequestSchema = buildMessageSchema(\n  'connection_ack',\n  1,\n  {\n    connectionId: union([string, undefinedType]), // Optional string connectionId\n  }\n);\n\nexport type ConnectionAckRequest = TypeOf<typeof ConnectionAckRequestSchema>;\n\n/**\n * Connection Acknowledgment V1 Request Message Class (Ultra-DRY implementation)\n */\nexport const ConnectionAckV1RequestMessage = createSimpleMessage<\n  ConnectionAckRequestData,\n  'connection_ack',\n  1\n>({\n  messageType: 'connection_ack',\n  version: 1,\n  schema: ConnectionAckRequestSchema,\n});\n","import { literal, string, TypeOf } from 'io-ts';\nimport { buildMessageSchema, createSimpleMessage } from './utils';\n\n/**\n * Connection Acknowledgment Response Runtime Data\n */\nexport interface ConnectionAckResponseData {\n  status: 'acknowledged';\n  timestamp: string;\n}\n\n/**\n * Connection Acknowledgment Response Wire Format\n */\nexport interface ConnectionAckResponseWire {\n  type: 'connection_ack_response';\n  version: 1;\n  status: 'acknowledged';\n  timestamp: string;\n}\n\n/**\n * Connection Acknowledgment Response Schema (built using Ultra-DRY utilities)\n */\nexport const ConnectionAckResponseSchema = buildMessageSchema(\n  'connection_ack_response',\n  1,\n  {\n    status: literal('acknowledged'),\n    timestamp: string, // ISO timestamp string\n  }\n);\n\nexport type ConnectionAckResponse = TypeOf<typeof ConnectionAckResponseSchema>;\n\n/**\n * Connection Acknowledgment V1 Response Message Class (Ultra-DRY implementation)\n */\nexport const ConnectionAckV1ResponseMessage = createSimpleMessage<\n  ConnectionAckResponseData,\n  'connection_ack_response',\n  1\n>({\n  messageType: 'connection_ack_response',\n  version: 1,\n  schema: ConnectionAckResponseSchema,\n});\n","import { HandshakeV1RequestMessage } from './HandshakeV1Request';\nimport { HandshakeV1ResponseMessage } from './HandshakeV1Response';\nimport { SignMessageV1RequestMessage } from './SignMessageV1Request';\nimport { SignMessageV1ResponseMessage } from './SignMessageV1Response';\nimport { ConnectionAckV1RequestMessage } from './ConnectionAckV1Request';\nimport { ConnectionAckV1ResponseMessage } from './ConnectionAckV1Response';\n\n/**\n * üéØ SINGLE SOURCE OF TRUTH - Add new messages here and everything else is automatic!\n * This is the ONLY place you need to add new message types\n */\nexport const ALL_MESSAGE_CLASSES = {\n  'handshake@1': HandshakeV1RequestMessage,\n  'handshake_response@1': HandshakeV1ResponseMessage,\n  'signMessage@1': SignMessageV1RequestMessage,\n  'signMessage_response@1': SignMessageV1ResponseMessage,\n  'connection_ack@1': ConnectionAckV1RequestMessage,\n  'connection_ack_response@1': ConnectionAckV1ResponseMessage,\n} as const;\n\n// ========================================\n// ü§ñ EVERYTHING BELOW IS AUTOMATICALLY DERIVED\n// ========================================\n\n/**\n * Derive message type union from classes\n */\nexport type AllMessageTypes = keyof typeof ALL_MESSAGE_CLASSES;\n\n/**\n * Derive runtime array of message keys from classes\n */\nexport const ALL_MESSAGE_KEYS = Object.keys(\n  ALL_MESSAGE_CLASSES\n) as AllMessageTypes[];\n\n/**\n * Get message class by type and version (derived from single source)\n */\nexport function getMessageClass(type: string, version: number) {\n  const key = `${type}@${version}` as AllMessageTypes;\n  const MessageClass = ALL_MESSAGE_CLASSES[key];\n\n  if (!MessageClass) {\n    throw new Error(`Unknown message type: ${type} version ${version}`);\n  }\n\n  return MessageClass;\n}\n\n/**\n * Type-safe check if message type exists\n */\nexport function isValidMessageType(type: string, version: number): boolean {\n  const key = `${type}@${version}`;\n  return key in ALL_MESSAGE_CLASSES;\n}\n\n/**\n * Get all supported message types and versions\n */\nexport function getAllSupportedMessages(): Array<{\n  type: string;\n  version: number;\n}> {\n  return ALL_MESSAGE_KEYS.map((key) => {\n    const [type, versionStr] = key.split('@');\n    return { type, version: parseInt(versionStr, 10) };\n  });\n}\n\n/**\n * Helper to extract message type and version from key\n */\nexport function parseMessageKey(key: AllMessageTypes): {\n  type: string;\n  version: number;\n} {\n  const [type, versionStr] = key.split('@');\n  return { type, version: parseInt(versionStr, 10) };\n}\n","import { either } from 'fp-ts';\nimport { IMessage } from './base';\nimport { getMessageClass, getAllSupportedMessages } from './allMessages';\n\n/**\n * Ultra-DRY Message Registry - everything is derived, no registration needed\n */\nexport class MessageRegistry {\n  private static instance: MessageRegistry;\n\n  private constructor() {}\n\n  static getInstance(): MessageRegistry {\n    if (!MessageRegistry.instance) {\n      MessageRegistry.instance = new MessageRegistry();\n    }\n    return MessageRegistry.instance;\n  }\n\n  /**\n   * Get a message class by type and version (derived from single source)\n   */\n  getMessageClass(type: string, version: number) {\n    try {\n      return getMessageClass(type, version);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Create a message instance from wire data (using derived message classes)\n   */\n  decode(wireData: any): either.Either<string, IMessage> {\n    if (!wireData || typeof wireData !== 'object') {\n      return { _tag: 'Left', left: 'Invalid wire data: must be an object' };\n    }\n\n    const { type, version } = wireData;\n    if (!type || !version) {\n      return {\n        _tag: 'Left',\n        left: 'Invalid wire data: missing type or version',\n      };\n    }\n\n    const MessageClass = this.getMessageClass(type, version);\n    if (!MessageClass) {\n      return { _tag: 'Left', left: `Unknown message type: ${type}@${version}` };\n    }\n\n    const result = MessageClass.decode(wireData);\n    if (either.isLeft(result)) {\n      return {\n        _tag: 'Left',\n        left: `Decode error: ${result.left.map((e) => e.message).join(', ')}`,\n      };\n    }\n\n    return { _tag: 'Right', right: result.right };\n  }\n\n  /**\n   * Encode a message to wire format\n   */\n  encode(message: IMessage): any {\n    return message.encode();\n  }\n\n  /**\n   * Get all registered message types (derived from single source)\n   */\n  getRegisteredTypes(): string[] {\n    return getAllSupportedMessages().map(\n      ({ type, version }) => `${type}@${version}`\n    );\n  }\n}\n\n// Export singleton instance\nexport const messageRegistry = MessageRegistry.getInstance();\n","/**\n * Asserts that a value is defined (not null or undefined)\n * @throws Error if value is null or undefined\n */\nexport function assertDefined<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error(message ?? 'Value must be defined');\n  }\n}\n\n/**\n * Asserts that a value is not null\n * @throws Error if value is null\n */\nexport function assertNotNull<T>(\n  value: T | null,\n  message?: string\n): asserts value is T {\n  if (value === null) {\n    throw new Error(message ?? 'Value must not be null');\n  }\n}\n\n/**\n * Returns a value if it is defined, otherwise throws an error\n * @throws Error if value is null or undefined\n */\nexport function getDefined<T>(\n  value: T | null | undefined,\n  message?: string\n): T {\n  assertDefined(value, message);\n  return value;\n}\n","import { ml_kem768 } from '@noble/post-quantum/ml-kem.js';\nimport { assertNotNull } from '../utils/assertDefined';\n\nexport const generateMlKem768Keypair = (): {\n  encapsulationKey: Uint8Array;\n  decapsulationKey: Uint8Array;\n} => {\n  try {\n    const keys = ml_kem768.keygen();\n    assertNotNull(keys.publicKey, 'Encapsulation key must be defined');\n    assertNotNull(keys.secretKey, 'Decapsulation key must be defined');\n    return {\n      encapsulationKey: keys.publicKey,\n      decapsulationKey: keys.secretKey,\n    };\n  } catch (error) {\n    throw new Error(\n      `Failed to generate ML-KEM-768 keypair: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n};\n","import { ml_kem768 } from '@noble/post-quantum/ml-kem.js';\n\nexport const encapsulateMlKem768 = (\n  encapsulationKey: Uint8Array\n): { cipherText: Uint8Array; sharedSecret: Uint8Array } => {\n  return ml_kem768.encapsulate(encapsulationKey);\n};\n","import { ml_kem768 } from '@noble/post-quantum/ml-kem.js';\n\nexport const decapsulateMlKem768 = (\n  decapsulationKey: Uint8Array,\n  cipherText: Uint8Array\n): Uint8Array => {\n  return ml_kem768.decapsulate(cipherText, decapsulationKey);\n};\n","import { hkdf } from '@noble/hashes/hkdf.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\n\nexport const AES_256_GCM_KEY_SIZE = 32; // 256 bits\nexport const AES_256_GCM_NONCE_SIZE = 12; // 96 bits\nexport const AES_256_GCM_TAG_SIZE = 16; // 128 bits\nexport const HKDF_SALT_SIZE = 32; // 256 bits\n\n/**\n * Derive AES-256 key from ML-KEM shared secret using HKDF\n * Following NIST SP 800-56C recommendations\n */\nexport function deriveAESKey(\n  sharedSecret: Uint8Array,\n  salt: Uint8Array,\n  info: string\n): Uint8Array {\n  const infoBytes = new TextEncoder().encode(info);\n  return hkdf(sha256, sharedSecret, salt, infoBytes, AES_256_GCM_KEY_SIZE);\n}\n\n/**\n * Create standardized context info for HKDF\n */\nexport function createKeyDerivationInfo(\n  purpose: 'keyshare' | 'hmac',\n  connectionId: string,\n  version: number = 1\n): string {\n  return `forward-mpc-${purpose}-v${version}-${connectionId}`;\n}\n","import { gcm } from '@noble/ciphers/aes';\nimport { bytesToHex, randomBytes } from '@noble/hashes/utils.js';\nimport { deriveAESKey, createKeyDerivationInfo } from './keyDerivation';\nimport type { EncryptedKeyshare } from '../codecs/EncryptedKeyshareCodec';\nimport type { SigningAlgorithmName } from '../signing/allAlgorithms';\n\n/**\n * Encrypt keyshare using AES-256-GCM with ML-KEM derived key\n *\n * @param keyshare - The keyshare object from Dynamic Wallet SDK\n * @param sharedSecret - ML-KEM shared secret from handshake\n * @param connectionId - Unique connection identifier\n * @param signingAlgorithm - Algorithm name for context\n * @returns Encrypted keyshare with salt and encrypted payload\n */\nexport async function encryptKeyshare(\n  keyshare: any,\n  sharedSecret: Uint8Array,\n  connectionId: string,\n  signingAlgorithm: SigningAlgorithmName\n): Promise<EncryptedKeyshare> {\n  // Generate random salt for HKDF\n  const salt = randomBytes(32);\n\n  // Derive AES key using HKDF with connection-specific context\n  const keyshareInfo = createKeyDerivationInfo('keyshare', connectionId);\n  const aesKey = deriveAESKey(sharedSecret, salt, keyshareInfo);\n\n  // Prepare keyshare data for encryption\n  const keyshareData = {\n    keyshare,\n    signingAlgorithm,\n    timestamp: Date.now(),\n    nonce: bytesToHex(randomBytes(16)),\n  };\n\n  // Encrypt with AES-256-GCM\n  const nonce = randomBytes(12);\n  const aes256Gcm = gcm(aesKey, nonce);\n  const plaintext = new TextEncoder().encode(JSON.stringify(keyshareData));\n  const ciphertext = aes256Gcm.encrypt(plaintext);\n\n  // Combine nonce + ciphertext for single payload\n  const encryptedPayload = new Uint8Array(nonce.length + ciphertext.length);\n  encryptedPayload.set(nonce, 0);\n  encryptedPayload.set(ciphertext, nonce.length);\n\n  // Clear sensitive data from memory\n  aesKey.fill(0);\n\n  return { salt, encryptedPayload };\n}\n","import type { SigningAlgorithmName } from './allAlgorithms';\nimport type { ISigningAlgorithm } from './base';\nimport {\n  SIGNING_ALGORITHM_INSTANCES,\n  ALL_SIGNING_ALGORITHM_NAMES,\n  isValidSigningAlgorithm,\n} from './allAlgorithms';\n\n/**\n * Ultra-simple registry - everything is derived, no registration needed\n */\nclass SigningAlgorithmRegistry {\n  /**\n   * Get algorithm instance (derived from single source of truth)\n   */\n  get(name: SigningAlgorithmName): ISigningAlgorithm {\n    const algorithm = SIGNING_ALGORITHM_INSTANCES[name];\n    if (!algorithm) {\n      throw new Error(`Unknown signing algorithm: ${name}`);\n    }\n    return algorithm;\n  }\n\n  /**\n   * Type-safe check if algorithm exists\n   */\n  has(name: string): name is SigningAlgorithmName {\n    return isValidSigningAlgorithm(name);\n  }\n\n  /**\n   * Get all algorithm names (derived from classes)\n   */\n  getAllNames(): SigningAlgorithmName[] {\n    return ALL_SIGNING_ALGORITHM_NAMES;\n  }\n\n  /**\n   * Get all algorithm instances (derived from classes)\n   */\n  getAllInstances(): Record<SigningAlgorithmName, ISigningAlgorithm> {\n    return SIGNING_ALGORITHM_INSTANCES;\n  }\n}\n\nexport const signingAlgorithmRegistry = new SigningAlgorithmRegistry();\n"]}