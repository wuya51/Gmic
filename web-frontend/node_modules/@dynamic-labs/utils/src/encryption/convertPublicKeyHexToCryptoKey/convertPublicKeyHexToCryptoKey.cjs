'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var cryptoAvailability = require('../cryptoAvailability/cryptoAvailability.cjs');

/**
 * Converts a hexadecimal string representation of a public key into a CryptoKey object
 *
 * @param hex - The hexadecimal string representation of the public key
 * @returns A Promise that resolves to a CryptoKey object suitable for ECDH operations
 * @throws Error if the hex string length is invalid or doesn't represent a valid public key
 * @throws CryptoNotAvailableError if crypto.subtle is not available (requires secure context)
 */
const convertPublicKeyHexToCryptoKey = (hex) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    cryptoAvailability.assertCryptoSubtleAvailable();
    // Validate hex string length (65 bytes = 130 hex characters)
    if (hex.length !== 130) {
        throw new Error('Invalid public key length. Expected 130 hex characters.');
    }
    // Validate hex string format (should start with '04' for uncompressed point)
    if (!hex.startsWith('04')) {
        throw new Error('Invalid public key format. Should start with "04".');
    }
    // Convert the hex string to an ArrayBuffer
    const byteArray = new Uint8Array((_b = (_a = decodeURIComponent(hex)
        .match(/.{1,2}/g)) === null || _a === void 0 ? void 0 : _a.map((byte) => parseInt(byte, 16))) !== null && _b !== void 0 ? _b : []);
    // Import the ArrayBuffer as a CryptoKey
    return crypto.subtle.importKey('raw', byteArray.buffer, {
        name: 'ECDH',
        namedCurve: 'P-256',
    }, true, []);
});

exports.convertPublicKeyHexToCryptoKey = convertPublicKeyHexToCryptoKey;
