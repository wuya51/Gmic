'use strict';

var core = require('@dynamic-labs-wallet/core');
var web = require('#internal/web');
var semver = require('semver');
var uuid = require('uuid');
var logger$1 = require('@dynamic-labs/logger');
var loadArgon2idWasm = require('argon2id');
var axios = require('axios');
var createHttpError = require('http-errors');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

const getMPCSignatureScheme = ({ signingAlgorithm, baseRelayUrl = core.MPC_RELAY_PROD_API_URL })=>{
    switch(signingAlgorithm){
        case core.SigningAlgorithm.ECDSA:
            return new web.Ecdsa(baseRelayUrl);
        case core.SigningAlgorithm.ED25519:
            return new web.ExportableEd25519(baseRelayUrl);
        case core.SigningAlgorithm.BIP340:
            return new web.BIP340(baseRelayUrl);
        default:
            throw new Error(`Unsupported signing algorithm: ${signingAlgorithm}`);
    }
};
const getMPCSigner = ({ chainName, baseRelayUrl })=>{
    const chainConfig = core.getMPCChainConfig(chainName);
    const signatureScheme = getMPCSignatureScheme({
        signingAlgorithm: chainConfig.signingAlgorithm,
        baseRelayUrl
    });
    return signatureScheme;
};

/**
 * Encryption version identifiers
 */ var EncryptionVersion = /*#__PURE__*/ function(EncryptionVersion) {
    EncryptionVersion["V1_LEGACY"] = "v1";
    EncryptionVersion["V2_PBKDF2"] = "v2";
    EncryptionVersion["V3_ARGON2"] = "v3";
    return EncryptionVersion;
}({});
/**
 * Current default version for new encryptions
 */ const ENCRYPTION_VERSION_CURRENT = "v3";
/**
 * Algorithm constants
 */ const PBKDF2_ALGORITHM = 'PBKDF2';
const HASH_ALGORITHM = 'SHA-256'; // Generic hash algorithm constant
const ARGON2_ALGORITHM = 'Argon2id';
const AES_GCM_ALGORITHM = 'AES-GCM';
const AES_GCM_LENGTH = 256;
/**
 * Argon2 configuration constants, values were chosen based on RFC (https://www.rfc-editor.org/rfc/rfc9106.html#name-parameter-choice)
 * taking into account that this runs in the client, possibly in smartphones with limited resources
 */ const ARGON2_MEMORY_SIZE = 65536; // 64 MB in KiB
const ARGON2_ITERATIONS = 3;
const ARGON2_PARALLELISM = 2;
const ARGON2_HASH_LENGTH = 32;
/**
 * PBKDF2 configuration constants
 */ const PBKDF2_ITERATIONS_V1 = 100000;
const PBKDF2_ITERATIONS_V2 = 1000000;

/**
 * Derives a key using Argon2id algorithm
 * @param params - Key derivation parameters
 * @param encryptionConfig - Encryption configuration
 * @returns Promise<CryptoKey>
 */ const deriveArgon2Key = async ({ password, salt }, encryptionConfig)=>{
    const argon2id = await loadArgon2idWasm();
    const argon2Config = encryptionConfig;
    const passwordBytes = new TextEncoder().encode(password);
    const hash = argon2id({
        password: passwordBytes,
        salt: salt,
        parallelism: argon2Config.parallelism || ARGON2_PARALLELISM,
        passes: argon2Config.iterations,
        memorySize: argon2Config.memorySize || ARGON2_MEMORY_SIZE,
        tagLength: argon2Config.hashLength || ARGON2_HASH_LENGTH
    });
    return crypto.subtle.importKey('raw', new Uint8Array(hash), {
        name: encryptionConfig.algorithm,
        length: encryptionConfig.algorithmLength
    }, false, [
        'encrypt',
        'decrypt'
    ]);
};

/**
 * Encryption configuration for each version
 */ const ENCRYPTION_VERSIONS = {
    [EncryptionVersion.V1_LEGACY]: {
        version: EncryptionVersion.V1_LEGACY,
        algorithm: AES_GCM_ALGORITHM,
        keyDerivation: PBKDF2_ALGORITHM,
        iterations: PBKDF2_ITERATIONS_V1,
        hashAlgorithm: HASH_ALGORITHM,
        algorithmLength: AES_GCM_LENGTH
    },
    [EncryptionVersion.V2_PBKDF2]: {
        version: EncryptionVersion.V2_PBKDF2,
        algorithm: AES_GCM_ALGORITHM,
        keyDerivation: PBKDF2_ALGORITHM,
        iterations: PBKDF2_ITERATIONS_V2,
        hashAlgorithm: HASH_ALGORITHM,
        algorithmLength: AES_GCM_LENGTH
    },
    [EncryptionVersion.V3_ARGON2]: {
        version: EncryptionVersion.V3_ARGON2,
        algorithm: AES_GCM_ALGORITHM,
        keyDerivation: ARGON2_ALGORITHM,
        iterations: ARGON2_ITERATIONS,
        hashAlgorithm: ARGON2_ALGORITHM,
        algorithmLength: AES_GCM_LENGTH,
        memorySize: ARGON2_MEMORY_SIZE,
        parallelism: ARGON2_PARALLELISM,
        hashLength: ARGON2_HASH_LENGTH
    }
};
/**
 * Helper function to get encryption configuration by version string
 * @param version - The version string (e.g., 'v1', 'v2', 'v3')
 * @returns The encryption configuration for the specified version
 */ const getEncryptionConfig = (version)=>{
    // If no version specified, use legacy for backward compatibility
    if (!version) {
        return ENCRYPTION_VERSIONS[EncryptionVersion.V1_LEGACY];
    }
    const config = ENCRYPTION_VERSIONS[version];
    if (!config) {
        throw new Error(`Unsupported encryption version: ${version}`);
    }
    return config;
};
/**
 * Check if a configuration uses Argon2
 */ const isArgon2Config = (config)=>{
    return config.keyDerivation === ARGON2_ALGORITHM;
};

/**
 * Utility functions for encryption operations
 * These functions are separated to avoid circular dependencies
 */ const bytesToBase64 = (arr)=>{
    return btoa(Array.from(arr, (b)=>String.fromCharCode(b)).join(''));
};
const stringToBytes = (str)=>{
    return new TextEncoder().encode(str);
};
const base64ToBytes = (base64)=>{
    return new Uint8Array(Buffer.from(base64, 'base64'));
};
// Helper function to ensure proper base64 padding
const ensureBase64Padding = (str)=>{
    return str.padEnd(Math.ceil(str.length / 4) * 4, '=');
};

/**
 * Derives a key using PBKDF2 algorithm
 * @param params - Key derivation parameters
 * @param encryptionConfig - Encryption configuration
 * @returns Promise<CryptoKey>
 */ const derivePBKDF2Key = async ({ password, salt }, encryptionConfig)=>{
    const passwordBytes = stringToBytes(password);
    const initialKey = await crypto.subtle.importKey('raw', passwordBytes, {
        name: 'PBKDF2'
    }, false, [
        'deriveKey'
    ]);
    return crypto.subtle.deriveKey({
        name: encryptionConfig.keyDerivation,
        salt: salt,
        iterations: encryptionConfig.iterations,
        hash: encryptionConfig.hashAlgorithm
    }, initialKey, {
        name: encryptionConfig.algorithm,
        length: encryptionConfig.algorithmLength
    }, false, [
        'encrypt',
        'decrypt'
    ]);
};

/**
 * Get the appropriate key derivation function based on the encryption config
 */ const getKey = async (params, encryptionConfig)=>{
    // Use Argon2 for v3, PBKDF2 for v1 and v2
    if (encryptionConfig.keyDerivation === ARGON2_ALGORITHM) {
        return deriveArgon2Key(params, encryptionConfig);
    } else {
        return derivePBKDF2Key(params, encryptionConfig);
    }
};
/**
 * Encrypts data using the specified encryption version.
 * Always uses the latest encryption configuration for new encryptions by default.
 */ const encryptData = async ({ data, password, version = ENCRYPTION_VERSION_CURRENT })=>{
    const encryptionConfig = getEncryptionConfig(version);
    try {
        // Generate a random salt and IV
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12)); // AES-GCM requires 12 bytes
        const key = await getKey({
            password,
            salt
        }, encryptionConfig);
        // Convert the input string to bytes
        const dataBytes = new TextEncoder().encode(data);
        // Encrypt the data
        const encryptedData = await crypto.subtle.encrypt({
            name: AES_GCM_ALGORITHM,
            iv
        }, key, dataBytes);
        // Convert to base64 strings, ensure proper padding
        return {
            salt: bytesToBase64(salt),
            iv: bytesToBase64(iv),
            cipher: bytesToBase64(new Uint8Array(encryptedData)),
            version
        };
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Error encrypting data: ${errorMessage} (version: ${version})`);
    }
};
/**
 * Decrypts data with version-based configuration.
 * Uses the version field from the data to determine encryption parameters.
 * Falls back to legacy version for backward compatibility if no version is specified.
 * For v3 (Argon2), retries with parallelism=1 if an OperationError occurs.
 */ const decryptData = async ({ data, password })=>{
    const { salt, iv, cipher, version } = data;
    // Ensure proper base64 padding for all values
    const paddedSalt = ensureBase64Padding(salt);
    const paddedIv = ensureBase64Padding(iv);
    const paddedCipher = ensureBase64Padding(cipher);
    const saltBytes = base64ToBytes(paddedSalt);
    const ivBytes = base64ToBytes(paddedIv);
    const cipherBytes = base64ToBytes(paddedCipher);
    // Determine which encryption configuration to use
    const encryptionConfig = getEncryptionConfig(version);
    try {
        const key = await getKey({
            password,
            salt: saltBytes
        }, encryptionConfig);
        const decryptedData = await crypto.subtle.decrypt({
            name: AES_GCM_ALGORITHM,
            iv: ivBytes
        }, key, cipherBytes);
        return new TextDecoder().decode(decryptedData);
    } catch (error) {
        // For a short period of time we lowered the parallelism for v3 (Argon2) to 1 to try to fix issues
        // for users with limited resources, however this introduced a new issue that the decryption would fail
        // for existing users with v3 (Argon2) encryption, this is a fallback for a few users.
        if (error instanceof Error && error.name === 'OperationError' && version === 'v3' && isArgon2Config(encryptionConfig)) {
            try {
                // Create a modified config with parallelism=1
                const modifiedConfig = _extends({}, encryptionConfig, {
                    parallelism: 1
                });
                const key = await getKey({
                    password,
                    salt: saltBytes
                }, modifiedConfig);
                const decryptedData = await crypto.subtle.decrypt({
                    name: AES_GCM_ALGORITHM,
                    iv: ivBytes
                }, key, cipherBytes);
                return new TextDecoder().decode(decryptedData);
            } catch (retryError) {
                // If retry also fails, throw the original error with additional context
                throw new Error(`Decryption failed after retry with parallelism=1: ${retryError}`);
            }
        }
        throw new Error('Decryption failed: ' + error);
    }
};
/**
 * Gets encryption metadata for a specific version.
 * Used when we need to include metadata in legacy systems or APIs that require it.
 */ const getEncryptionMetadataForVersion = (version)=>{
    const encryptionConfig = getEncryptionConfig(version);
    const metadata = {
        algorithm: encryptionConfig.algorithm,
        keyDerivation: encryptionConfig.keyDerivation,
        iterations: encryptionConfig.iterations,
        hashAlgorithm: encryptionConfig.hashAlgorithm,
        algorithmLength: encryptionConfig.algorithmLength
    };
    // Add Argon2-specific metadata if applicable
    if (isArgon2Config(encryptionConfig)) {
        metadata.memorySize = encryptionConfig.memorySize;
        metadata.parallelism = encryptionConfig.parallelism;
        metadata.hashLength = encryptionConfig.hashLength;
    }
    return metadata;
};

const GOOGLE_DRIVE_UPLOAD_API = 'https://www.googleapis.com';
const uploadFileToGoogleDriveAppStorage = async ({ accessToken, fileName, jsonData })=>{
    return uploadFileToGoogleDrive({
        accessToken,
        fileName,
        jsonData,
        parents: [
            'appDataFolder'
        ]
    });
};
const uploadFileToGoogleDrivePersonal = async ({ accessToken, fileName, jsonData })=>{
    return uploadFileToGoogleDrive({
        accessToken,
        fileName,
        jsonData,
        parents: [
            'root'
        ]
    });
};
const uploadFileToGoogleDrive = async ({ accessToken, fileName, jsonData, parents })=>{
    const metadata = {
        name: fileName,
        mimeType: 'application/json',
        parents
    };
    const form = new FormData();
    form.append('metadata', new Blob([
        JSON.stringify(metadata)
    ], {
        type: 'application/json'
    }));
    form.append('file', new Blob([
        JSON.stringify(jsonData)
    ], {
        type: 'application/json'
    }));
    const response = await fetch(`${GOOGLE_DRIVE_UPLOAD_API}/upload/drive/v3/files?uploadType=multipart`, {
        method: 'POST',
        headers: {
            Authorization: `Bearer ${accessToken}`
        },
        body: form
    });
    if (!response.ok) {
        throw new Error('Error uploading file');
    }
    const result = await response.json();
    return result; // Return file metadata, including file ID
};
const listFilesFromGoogleDrive = async ({ accessToken, fileName })=>{
    // Step 1: List all files inside `appDataFolder` with the specified backup filename
    const resp = await fetch(`${GOOGLE_DRIVE_UPLOAD_API}/drive/v3/files?q=${encodeURIComponent(`name='${fileName}'`)}&spaces=appDataFolder&orderBy=createdTime desc`, {
        headers: {
            Authorization: `Bearer ${accessToken}`
        }
    });
    const data = await resp.json();
    // If no files found, return null
    if (!data.files || data.files.length === 0) {
        return null;
    }
    const files = data.files;
    return files;
};
const downloadFileFromGoogleDrive = async ({ accessToken, fileName })=>{
    const files = await listFilesFromGoogleDrive({
        accessToken,
        fileName
    });
    if (!files || files.length === 0) {
        return null;
    }
    // Get the most recent file
    const fileMetadata = files[0];
    // Fetch the file data using the file ID
    const fileRes = await fetch(`${GOOGLE_DRIVE_UPLOAD_API}/drive/v3/files/${fileMetadata.id}?alt=media`, {
        headers: {
            Authorization: `Bearer ${accessToken}`
        }
    });
    // Read the file's raw data
    const fileRawData = await fileRes.text();
    if (fileRawData.length === 0) {
        return null;
    }
    try {
        // Just parse and return the data without validation
        // The client will handle validation of the structure
        return JSON.parse(fileRawData);
    } catch (error) {
        return null;
    }
};

const handleAxiosError = (error, message, context)=>{
    var _error_response, _error_response1, _error_response2;
    logger.error('[DynamicWaasWalletClient] Axios error: ', {
        message,
        error: (_error_response = error.response) == null ? void 0 : _error_response.data,
        status: (_error_response1 = error.response) == null ? void 0 : _error_response1.status,
        context
    });
    switch((_error_response2 = error.response) == null ? void 0 : _error_response2.status){
        case 400:
            throw createHttpError(400, 'Invalid request');
        case 401:
            throw createHttpError(401, 'Authorization header or cookie is required');
        case 403:
            throw createHttpError(403, 'Forbidden');
        case 422:
            throw createHttpError(422, 'Unprocessable content');
        case 500:
            throw createHttpError(500, 'Internal server error');
        default:
            throw createHttpError(500, 'Internal server error');
    }
};

const logger = new logger$1.Logger('DynamicWaasWalletClient', logger$1.LogLevel.DEBUG);
const setLoggerContext = ({ environmentId, authMode = core.AuthMode.HEADER, sessionId = undefined, userId = undefined })=>{
    try {
        logger$1.Logger.setEnvironmentId(environmentId);
        logger$1.Logger.globalMetaData.set('sid', sessionId);
        logger$1.Logger.globalMetaData.set('user_id', userId);
        logger$1.Logger.globalMetaData.set('auth_mode', authMode);
    } catch (error) {
        logError({
            message: '[DynamicWaasWalletClient] Error setting logger context',
            error: error,
            context: {}
        });
    }
};
const logError = ({ message, error, context })=>{
    if (error instanceof axios.AxiosError) {
        handleAxiosError(error, message, context);
    }
    logger.error('[DynamicWaasWalletClient] Error in browser client', {
        error: error instanceof Error ? error.message : String(error),
        context
    });
};

const DEFAULT_LOG_LEVEL = logger$1.LogLevel.DEBUG; //todo: change back to info when done debugging
const STORAGE_KEY = 'dynamic-waas-wallet-client';
const CLIENT_KEYSHARE_EXPORT_FILENAME_PREFIX = 'dynamicWalletKeyShareBackup';
const SIGNED_SESSION_ID_MIN_VERSION = '4.25.4';
// Namespace-specific version requirements
const SIGNED_SESSION_ID_MIN_VERSION_BY_NAMESPACE = {
    WalletKit: '4.25.4',
    ClientSDK: '0.1.0-alpha.0'
};

const isBrowser = ()=>typeof window !== 'undefined';
const getClientKeyShareExportFileName = ({ thresholdSignatureScheme, accountAddress })=>{
    return `${CLIENT_KEYSHARE_EXPORT_FILENAME_PREFIX}-${thresholdSignatureScheme}-${accountAddress}.json`;
};
const getClientKeyShareBackupInfo = (params)=>{
    var _params_walletProperties, _params_walletProperties_keyShares_;
    const backups = {
        [core.BackupLocation.DYNAMIC]: [],
        [core.BackupLocation.GOOGLE_DRIVE]: [],
        [core.BackupLocation.ICLOUD]: [],
        [core.BackupLocation.USER]: [],
        [core.BackupLocation.EXTERNAL]: [],
        [core.BackupLocation.DELEGATED]: []
    };
    if (!(params == null ? void 0 : (_params_walletProperties = params.walletProperties) == null ? void 0 : _params_walletProperties.keyShares)) {
        return {
            backups,
            passwordEncrypted: false
        };
    }
    params.walletProperties.keyShares.forEach((keyShare)=>{
        if (backups[keyShare.backupLocation]) {
            backups[keyShare.backupLocation].push({
                location: keyShare.backupLocation,
                keyShareId: keyShare.id,
                externalKeyShareId: keyShare == null ? void 0 : keyShare.externalKeyShareId
            });
        }
    });
    const passwordEncrypted = Boolean((_params_walletProperties_keyShares_ = params.walletProperties.keyShares[0]) == null ? void 0 : _params_walletProperties_keyShares_.passwordEncrypted);
    return {
        backups,
        passwordEncrypted
    };
};
/**
 * Helper function to merge keyshares and remove duplicates based on pubkey and secretShare
 * @param existingKeyShares - Array of existing keyshares
 * @param newKeyShares - Array of new keyshares to merge
 * @returns Array of merged unique keyshares
 */ const mergeUniqueKeyShares = (existingKeyShares, newKeyShares)=>{
    const uniqueKeyShares = newKeyShares.filter((newShare)=>!existingKeyShares.some((existingShare)=>{
            if (!(newShare == null ? void 0 : newShare.pubkey) || !(existingShare == null ? void 0 : existingShare.pubkey)) return false;
            return newShare.pubkey.toString() === existingShare.pubkey.toString() && newShare.secretShare === existingShare.secretShare;
        }));
    return [
        ...existingKeyShares,
        ...uniqueKeyShares
    ];
};
const timeoutPromise = ({ timeInMs, activity = 'Ceremony' })=>{
    return new Promise((_, reject)=>setTimeout(()=>reject(new Error(`${activity} did not complete in ${timeInMs}ms`)), timeInMs));
};
/**
 * Generic helper function to retry a promise-based operations
 *
 * @param operation - The async operation to retry
 * @param config - Configuration options for retry behavior
 * @returns Promise with the operation result
 * @throws Last error encountered after all retries are exhausted
 */ async function retryPromise(operation, { maxAttempts = 5, retryInterval = 500, operationName = 'operation', logContext = {} } = {}) {
    let attempts = 0;
    while(attempts < maxAttempts){
        try {
            return await operation();
        } catch (error) {
            var _error_response;
            attempts++;
            logger.warn(`Failed to execute ${operationName} on attempt ${attempts}`, _extends({}, logContext, {
                error: error instanceof Error ? error.message : 'Unknown error',
                axiosError: error instanceof axios.AxiosError ? (_error_response = error.response) == null ? void 0 : _error_response.data : undefined
            }));
            if (attempts === maxAttempts) {
                var _error_response1;
                logger.error(`Failed to execute ${operationName} after ${maxAttempts} attempts`, _extends({}, logContext, {
                    error: error instanceof Error ? error.message : 'Unknown error',
                    axiosError: error instanceof axios.AxiosError ? (_error_response1 = error.response) == null ? void 0 : _error_response1.data : undefined
                }));
                throw error;
            }
            // Calculate exponential backoff delay
            const exponentialDelay = retryInterval * 2 ** (attempts - 1);
            await new Promise((resolve)=>setTimeout(resolve, exponentialDelay));
        }
    }
    // TypeScript needs this even though it's unreachable
    throw new Error('Unreachable code');
}
const formatEvmMessage = (message)=>{
    if (typeof message === 'string' && message.startsWith('0x')) {
        const serializedTxBytes = Uint8Array.from(Buffer.from(message.slice(2), 'hex'));
        return web.MessageHash.keccak256(serializedTxBytes);
    }
    return web.MessageHash.keccak256(message);
};
const isHexString = (str)=>{
    // Remove 0x prefix if present
    const hex = str.startsWith('0x') ? str.slice(2) : str;
    // Check if string contains only hex characters
    return /^[0-9A-Fa-f]+$/.test(hex);
};
const formatSolanaMessage = (message)=>{
    if (typeof message === 'string') {
        if (!isHexString(message)) {
            return Buffer.from(message).toString('hex');
        } else {
            return new Uint8Array(Buffer.from(message, 'hex'));
        }
    } else {
        return message;
    }
};
const formatMessage = (chainName, message)=>{
    switch(chainName){
        case 'EVM':
            return formatEvmMessage(message);
        case 'SVM':
            return formatSolanaMessage(message);
        case 'SUI':
            return message;
        default:
            throw new Error('Unsupported chain name');
    }
};
const getGoogleOAuthAccountId = (verifiedCredentials)=>{
    const googleVerifiedCredential = verifiedCredentials == null ? void 0 : verifiedCredentials.find((credential)=>credential.oauthProvider === sdkApiCore.ProviderEnum.Google);
    return googleVerifiedCredential == null ? void 0 : googleVerifiedCredential.id;
};
const createBackupData = ({ encryptedKeyShares, accountAddress, thresholdSignatureScheme, hasPassword = true })=>{
    return {
        keyShares: encryptedKeyShares,
        metadata: {
            createdAt: new Date().toISOString(),
            accountAddress,
            thresholdSignatureScheme,
            hasPassword,
            encryption: getEncryptionMetadataForVersion(ENCRYPTION_VERSION_CURRENT),
            encryptionVersion: ENCRYPTION_VERSION_CURRENT,
            shareCount: encryptedKeyShares.length
        }
    };
};

/**
 * Uploads a backup to Google Drive App
 * @param accessToken - The access token for the Google Drive API
 * @param fileName - The name of the file to upload
 * @param backupData - The data to upload
 * @param accountAddress - The account address associated with the backup
 */ const uploadBackupToGoogleDrive = async ({ accessToken, fileName, backupData, accountAddress })=>{
    const uploadPromises = [
        retryPromise(()=>uploadFileToGoogleDriveAppStorage({
                accessToken,
                fileName,
                jsonData: backupData
            })),
        retryPromise(()=>uploadFileToGoogleDrivePersonal({
                accessToken,
                fileName,
                jsonData: backupData
            }))
    ];
    const results = await Promise.allSettled(uploadPromises);
    const errors = [];
    // Check App Storage result
    if (results[0].status === 'rejected') {
        const error = results[0].reason;
        logger.error('[DynamicWaasWalletClient] Failed to upload keyshares to Google Drive App Storage', {
            accountAddress,
            error
        });
        errors.push(`Failed to backup keyshares to Google Drive App Storage: ${error instanceof Error ? error.message : String(error)}`);
    }
    // Check Personal Drive result
    if (results[1].status === 'rejected') {
        const error = results[1].reason;
        logger.error('[DynamicWaasWalletClient] Failed to upload keyshares to Google Drive Personal', {
            accountAddress,
            error
        });
        errors.push(`Failed to backup keyshares to Google Drive Personal: ${error instanceof Error ? error.message : String(error)}`);
    }
    // Throw if any uploads failed
    if (errors.length > 0) {
        throw new Error(`[DynamicWaasWalletClient] ${errors.join('; ')}`);
    }
};

const localStorageWriteTest = {
    tested: false,
    writable: false
};
/**
 * Checks whether localStorage is supported on this browser.
 */ const supportsLocalStorage = ()=>{
    if (!isBrowser()) {
        return false;
    }
    try {
        if (typeof globalThis.localStorage !== 'object') {
            return false;
        }
    } catch (e) {
        // DOM exception when accessing `localStorage`
        return false;
    }
    if (localStorageWriteTest.tested) {
        return localStorageWriteTest.writable;
    }
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(randomKey, randomKey);
        globalThis.localStorage.removeItem(randomKey);
        localStorageWriteTest.tested = true;
        localStorageWriteTest.writable = true;
    } catch (e) {
        // localStorage can't be written to
        localStorageWriteTest.tested = true;
        localStorageWriteTest.writable = false;
    }
    return localStorageWriteTest.writable;
};
/**
 * Provides safe access to the globalThis.localStorage property.
 */ const localStorageAdapter = {
    getItem: (key)=>{
        if (!supportsLocalStorage()) {
            return null;
        }
        return globalThis.localStorage.getItem(key);
    },
    removeItem: (key)=>{
        if (!supportsLocalStorage()) {
            return;
        }
        globalThis.localStorage.removeItem(key);
    },
    setItem: (key, value)=>{
        if (!supportsLocalStorage()) {
            return;
        }
        globalThis.localStorage.setItem(key, value);
    }
};
/**
 * Returns a localStorage-like object that stores the key-value pairs in
 * memory.
 */ const memoryLocalStorageAdapter = (store = {})=>({
        getItem: (key)=>store[key] || null,
        removeItem: (key)=>{
            delete store[key];
        },
        setItem: (key, value)=>{
            store[key] = value;
        }
    });

/** Algorithm label for the new hybrid encryption standard */ const ALG_LABEL_RSA = 'HYBRID-RSA-AES-256';
/**
 * Convert base64 to base64url encoding
 */ const toBase64Url = (buffer)=>{
    const base64 = Buffer.from(buffer).toString('base64');
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
};
/**
 * Convert ArrayBuffer to base64url
 */ const arrayBufferToBase64Url = (buffer)=>{
    return toBase64Url(buffer);
};
/**
 * Import RSA public key from PEM format
 */ const importRSAPublicKey = async (publicKeyPem)=>{
    // Remove PEM headers and decode base64
    const pemHeader = '-----BEGIN PUBLIC KEY-----';
    const pemFooter = '-----END PUBLIC KEY-----';
    const pemContents = publicKeyPem.replace(pemHeader, '').replace(pemFooter, '').replace(/\s/g, '');
    const binaryDer = Buffer.from(pemContents, 'base64').toString('binary');
    const keyData = new Uint8Array(binaryDer.length);
    for(let i = 0; i < binaryDer.length; i++){
        keyData[i] = binaryDer.charCodeAt(i);
    }
    return await crypto.subtle.importKey('spki', keyData, {
        name: 'RSA-OAEP',
        hash: 'SHA-256'
    }, false, [
        'encrypt'
    ]);
};
/**
 * Creates the encoded envelope bytes from the encrypted data components
 */ const createEncodedEnvelopeBytes = (iv, ciphertext, authTag, encryptedAesKey)=>{
    const envelopeData = {
        algorithm: ALG_LABEL_RSA,
        iv: arrayBufferToBase64Url(iv.buffer),
        encryptedData: arrayBufferToBase64Url(ciphertext.buffer),
        authTag: arrayBufferToBase64Url(authTag.buffer),
        encryptedKey: arrayBufferToBase64Url(encryptedAesKey)
    };
    return Buffer.from(new TextEncoder().encode(JSON.stringify(envelopeData))).toString('base64');
};
/**
 * Encrypts data using HYBRID-RSA-AES-256 encryption scheme with Web Crypto API.
 * 1. Generate random AES-256 key
 * 2. Encrypt AES key with RSA public key
 * 3. Encrypt data with AES-256-GCM
 */ const encryptDelegatedKeyShare = async (data, publicKeyPem)=>{
    try {
        // Step 1: Generate a random AES-256 key and 16-byte IV
        const aesKey = await crypto.subtle.generateKey({
            name: 'AES-GCM',
            length: 256
        }, true, [
            'encrypt'
        ]);
        const iv = crypto.getRandomValues(new Uint8Array(16)); // 128-bit IV for GCM
        // Step 2: Encrypt the data with AES-256-GCM
        const plaintext = new TextEncoder().encode(data);
        const encryptedData = await crypto.subtle.encrypt({
            name: 'AES-GCM',
            iv: iv
        }, aesKey, plaintext);
        // Extract the auth tag from the encrypted data (last 16 bytes)
        const encryptedDataArray = new Uint8Array(encryptedData);
        const authTag = encryptedDataArray.slice(-16);
        const ciphertext = encryptedDataArray.slice(0, -16);
        // Step 3: Encrypt the AES key with RSA public key
        const rsaPublicKey = await importRSAPublicKey(publicKeyPem);
        // Export the AES key to encrypt it
        const aesKeyData = await crypto.subtle.exportKey('raw', aesKey);
        const encryptedAesKey = await crypto.subtle.encrypt({
            name: 'RSA-OAEP'
        }, rsaPublicKey, aesKeyData);
        return {
            algorithm: ALG_LABEL_RSA,
            iv: arrayBufferToBase64Url(iv.buffer),
            encryptedData: arrayBufferToBase64Url(ciphertext.buffer),
            authTag: arrayBufferToBase64Url(authTag.buffer),
            encryptedKey: arrayBufferToBase64Url(encryptedAesKey),
            encodedEnvelopeBytes: createEncodedEnvelopeBytes(iv, ciphertext, authTag, encryptedAesKey)
        };
    } catch (error) {
        throw new Error(`Encryption failed: ${error instanceof Error ? error.message : String(error)}`);
    }
};

class DynamicWalletClient {
    getAuthMode() {
        return this.authMode;
    }
    /**
   * Check if the SDK version meets the requirement for signed session ID
   * Uses namespace-specific version requirements when available
   * @returns boolean indicating if requireSignedSessionId should be set to true
   */ requiresSignedSessionId() {
        if (!this.sdkVersion) {
            return false;
        }
        try {
            const parsedVersion = core.parseNamespacedVersion(this.sdkVersion);
            if (!parsedVersion) {
                return false;
            }
            const { namespace, version } = parsedVersion;
            // Check if we have a namespace-specific version requirement
            const namespaceMinVersion = SIGNED_SESSION_ID_MIN_VERSION_BY_NAMESPACE[namespace];
            if (namespaceMinVersion) {
                return semver.gte(version, namespaceMinVersion);
            }
            // Fall back to default version requirement
            return semver.gte(version, SIGNED_SESSION_ID_MIN_VERSION);
        } catch (error) {
            logger.warn(`[DynamicWaasWalletClient] Error checking if requiresSignedSessionId should be set to true for version ${this.sdkVersion}`, error);
            return false;
        }
    }
    async initLoggerContext(authToken) {
        // only decode jwt token in header auth mode
        if (this.authMode === 'cookie') {
            setLoggerContext({
                environmentId: this.environmentId,
                authMode: this.authMode
            });
            return;
        }
        try {
            // Split the JWT token into its parts (header.payload.signature)
            const parts = authToken.split('.');
            if (parts.length !== 3) {
                logger.debug('[DynamicWaasWalletClient] Invalid JWT token when initializing logger context');
                return;
            }
            // Decode the payload (second part)
            const base64Payload = parts[1].replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(Buffer.from(base64Payload, 'base64').toString('utf-8'));
            const payload = JSON.parse(jsonPayload);
            if (!payload || typeof payload !== 'object') {
                logger.debug('[DynamicWaasWalletClient] Invalid JWT payload when initializing logger context');
                return;
            }
            const userId = payload['sub'] || 'unknown';
            const sessionId = payload['sid'] || 'unknown';
            setLoggerContext({
                environmentId: this.environmentId,
                authMode: this.authMode,
                sessionId,
                userId
            });
            this.sessionId = sessionId;
        } catch (error) {
            logError({
                message: 'Error initializing logger context',
                error: error,
                context: {}
            });
            throw error;
        }
    }
    async initialize() {
        if (this.initializePromise) {
            return await this.initializePromise;
        }
        this.logger.debug('[DynamicWaasWalletClient] Initializing Dynamic Waas Wallet SDK');
        this.initializePromise = this._initialize();
        const result = await this.initializePromise;
        this.logger.debug('[DynamicWaasWalletClient] Dynamic Waas Wallet SDK initialized');
        return result;
    }
    /**
   * Client initialization logic
   */ async _initialize() {
        try {
            const initializePromises = [
                this.restoreWallets()
            ];
            await Promise.all(initializePromises);
            return {
                error: null
            };
        } catch (error) {
            return {
                error
            };
        }
    }
    async serverInitializeKeyGen({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, onError, onCeremonyComplete }) {
        // Initialize keygen, create room, and create the wallet account on the server
        const data = await this.apiClient.createWalletAccount({
            chainName,
            clientKeygenIds,
            dynamicRequestId,
            thresholdSignatureScheme,
            onError,
            onCeremonyComplete
        });
        this.logger.debug(`[DynamicWaasWalletClient] Initialized client key generation with IDs: ${clientKeygenIds.join(', ')} for chain: ${chainName} using scheme: ${thresholdSignatureScheme}`);
        return data;
    }
    async clientInitializeKeyGen({ chainName, thresholdSignatureScheme }) {
        // Get the mpc signer
        const mpcSigner = getMPCSigner({
            chainName,
            baseRelayUrl: this.baseMPCRelayApiUrl
        });
        const clientThreshold = core.getClientThreshold(thresholdSignatureScheme);
        const keygenInitResults = await Promise.all(Array(clientThreshold).fill(null).map(()=>mpcSigner.initKeygen()));
        return keygenInitResults;
    }
    async derivePublicKey({ chainName, keyShare, derivationPath }) {
        const mpcSigner = getMPCSigner({
            chainName,
            baseRelayUrl: this.baseMPCRelayApiUrl
        });
        let publicKey;
        if (mpcSigner instanceof web.Ecdsa) {
            publicKey = await mpcSigner.derivePubkey(keyShare, derivationPath);
        } else if (mpcSigner instanceof web.ExportableEd25519) {
            publicKey = await mpcSigner.getPubkey(keyShare);
        }
        return publicKey;
    }
    async clientKeyGen({ chainName, roomId, serverKeygenIds, clientKeygenInitResults, thresholdSignatureScheme }) {
        // Get the chain config and the mpc signer
        const mpcSigner = getMPCSigner({
            chainName,
            baseRelayUrl: this.baseMPCRelayApiUrl
        });
        // Get the MPC config for the threshold signature scheme
        const mpcConfig = core.MPC_CONFIG[thresholdSignatureScheme];
        // For each client keygen init result, create an array of other parties' keygenIds
        const clientKeygenResults = await Promise.all(clientKeygenInitResults.map((currentInit)=>{
            // Get all other client keygenIds (excluding current one)
            const otherClientKeygenIds = clientKeygenInitResults.filter((init)=>init.keygenId !== currentInit.keygenId).map((init)=>init.keygenId);
            // Combine server keygenIds with other client keygenIds
            const allOtherKeygenIds = [
                ...serverKeygenIds,
                ...otherClientKeygenIds
            ];
            if (!(mpcSigner instanceof web.ExportableEd25519)) {
                return mpcSigner.keygen(roomId, mpcConfig.numberOfParties, mpcConfig.threshold, currentInit, allOtherKeygenIds);
            } else {
                // One party joins the keygen room using acting as the sampler: (wallet-service)
                // The remaining parties join the key sampling ceremony using: (browser)
                return mpcSigner.receiveKey(roomId, mpcConfig.numberOfParties, mpcConfig.threshold, currentInit, allOtherKeygenIds);
            }
        }));
        // only need one client keygen result to derive the public key
        const [clientKeygenResult] = clientKeygenResults;
        const chainConfig = core.getMPCChainConfig(chainName);
        const derivationPath = new Uint32Array(chainConfig.derivationPath);
        const rawPublicKey = await this.derivePublicKey({
            chainName,
            keyShare: clientKeygenResult,
            derivationPath
        });
        return {
            rawPublicKey,
            clientKeygenResults
        };
    }
    async keyGen({ chainName, thresholdSignatureScheme, onError, onCeremonyComplete }) {
        const dynamicRequestId = uuid.v4();
        try {
            const clientKeygenInitResults = await this.clientInitializeKeyGen({
                chainName,
                thresholdSignatureScheme
            });
            const clientKeygenIds = clientKeygenInitResults.map((result)=>result.keygenId);
            this.logger.debug('[DynamicWaasWalletClient] Initialized client key generation', {
                clientKeygenIds: clientKeygenIds.join(', '),
                chainName,
                thresholdSignatureScheme
            });
            const { roomId, serverKeygenIds } = await this.serverInitializeKeyGen({
                chainName,
                clientKeygenIds,
                dynamicRequestId,
                thresholdSignatureScheme,
                onCeremonyComplete
            });
            this.logger.debug('[DynamicWaasWalletClient] Server key generation initialized', {
                roomId,
                clientKeygenIds: clientKeygenIds.join(', '),
                serverKeygenIds: serverKeygenIds.join(', '),
                chainName
            });
            const { rawPublicKey, clientKeygenResults: clientKeyShares } = await this.clientKeyGen({
                chainName,
                roomId,
                serverKeygenIds,
                clientKeygenInitResults,
                thresholdSignatureScheme
            });
            this.logger.debug('[DynamicWaasWalletClient] Client key generation completed', {
                roomId,
                serverKeygenIds: serverKeygenIds.join(', '),
                clientKeygenIds: clientKeygenIds.join(', '),
                chainName,
                thresholdSignatureScheme,
                rawPublicKey,
                clientKeySharesCount: clientKeyShares.length
            });
            return {
                rawPublicKey,
                clientKeyShares
            };
        } catch (error) {
            logError({
                message: 'Error in keyGen',
                error: error,
                context: {
                    chainName,
                    thresholdSignatureScheme,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async importRawPrivateKey({ chainName, privateKey, thresholdSignatureScheme, onError, onCeremonyComplete }) {
        const dynamicRequestId = uuid.v4();
        try {
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            const clientKeygenInitResults = await this.clientInitializeKeyGen({
                chainName,
                thresholdSignatureScheme
            });
            const clientKeygenIds = clientKeygenInitResults.map((result)=>result.keygenId);
            this.logger.debug('[DynamicWaasWalletClient] Client key generation initialized', {
                clientKeygenIds: clientKeygenIds.join(', '),
                chainName,
                thresholdSignatureScheme
            });
            const { roomId, serverKeygenIds } = await this.apiClient.importPrivateKey({
                chainName,
                clientKeygenIds,
                dynamicRequestId,
                thresholdSignatureScheme,
                onError,
                onCeremonyComplete
            });
            this.logger.debug('[DynamicWaasWalletClient] Server key generation initialized', {
                roomId,
                clientKeygenIds: clientKeygenIds.join(', '),
                serverKeygenIds: serverKeygenIds.join(', '),
                chainName
            });
            const { threshold } = core.getTSSConfig(thresholdSignatureScheme);
            const clientKeygenResults = await Promise.all(clientKeygenInitResults.map(async (currentInit, index)=>{
                const otherClientKeygenIds = clientKeygenInitResults.filter((init)=>init.keygenId !== currentInit.keygenId).map((init)=>init.keygenId);
                if (index === 0) {
                    const otherKeyGenIds = [
                        ...serverKeygenIds,
                        ...otherClientKeygenIds
                    ];
                    const importerKeygenResult = await mpcSigner.importPrivateKeyImporter(roomId, threshold, privateKey, currentInit, otherKeyGenIds);
                    return importerKeygenResult;
                } else {
                    const recipientKeygenResult = await mpcSigner.importPrivateKeyRecipient(roomId, threshold, currentInit, [
                        ...serverKeygenIds,
                        ...otherClientKeygenIds
                    ]);
                    return recipientKeygenResult;
                }
            }));
            const [clientKeygenResult] = clientKeygenResults;
            const rawPublicKey = await this.derivePublicKey({
                chainName,
                keyShare: clientKeygenResult,
                derivationPath: undefined
            });
            this.logger.debug('[DynamicWaasWalletClient] Completed import of raw private key', {
                rawPublicKey,
                chainName,
                thresholdSignatureScheme,
                roomId,
                serverKeygenIds: serverKeygenIds.join(', '),
                clientKeygenIds: clientKeygenIds.join(', ')
            });
            return {
                rawPublicKey,
                clientKeyShares: clientKeygenResults
            };
        } catch (error) {
            logError({
                message: 'Error in importRawPrivateKey',
                error: error,
                context: {
                    chainName,
                    thresholdSignatureScheme,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async serverSign({ walletId, message, isFormatted, mfaToken, context, onError, dynamicRequestId }) {
        // Create the room and sign the message
        if (typeof message !== 'string') {
            message = `0x${Buffer.from(message).toString('hex')}`;
        }
        const data = await this.apiClient.signMessage({
            walletId,
            message,
            isFormatted,
            dynamicRequestId,
            mfaToken,
            context: context ? JSON.parse(JSON.stringify(context, (_key, value)=>typeof value === 'bigint' ? value.toString() : value)) : undefined,
            onError
        });
        return data;
    }
    async clientSign({ chainName, message, roomId, keyShare, derivationPath, isFormatted, dynamicRequestId }) {
        try {
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            const formattedMessage = isFormatted ? new web.MessageHash(message) : formatMessage(chainName, message);
            this.logger.debug('[DynamicWaasWalletClient] Starting client sign', {
                chainName,
                message,
                roomId,
                derivationPath,
                isFormatted
            });
            const signature = await mpcSigner.sign(roomId, keyShare, formattedMessage, derivationPath);
            return signature;
        } catch (error) {
            logError({
                message: 'Error in clientSign',
                error: error,
                context: {
                    chainName,
                    roomId,
                    derivationPath,
                    isFormatted,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    //todo: need to modify with imported flag
    async sign({ accountAddress, message, chainName, password = undefined, isFormatted = false, signedSessionId, mfaToken, context, onError }) {
        const dynamicRequestId = uuid.v4();
        try {
            await this.verifyPassword({
                accountAddress,
                password,
                walletOperation: core.WalletOperation.SIGN_MESSAGE,
                signedSessionId
            });
            const wallet = await this.getWallet({
                accountAddress,
                password,
                walletOperation: core.WalletOperation.SIGN_MESSAGE,
                signedSessionId
            });
            // Perform the server sign
            const data = await this.serverSign({
                walletId: wallet.walletId,
                message,
                isFormatted,
                mfaToken,
                context,
                onError,
                dynamicRequestId
            });
            this.logger.debug('[DynamicWaasWalletClient] Server sign completed', {
                message,
                accountAddress,
                walletId: wallet.walletId,
                roomId: data.roomId,
                dynamicRequestId
            });
            const derivationPath = wallet.derivationPath && wallet.derivationPath != '' ? new Uint32Array(Object.values(JSON.parse(wallet.derivationPath))) : undefined;
            // Perform the client sign and return the signature
            const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
                accountAddress
            });
            const signature = await this.clientSign({
                chainName,
                message,
                roomId: data.roomId,
                keyShare: clientKeyShares[0],
                derivationPath,
                isFormatted,
                dynamicRequestId
            });
            this.logger.debug('[DynamicWaasWalletClient] Client sign completed', {
                chainName,
                message,
                roomId: data.roomId,
                derivationPath,
                isFormatted
            });
            return signature;
        } catch (error) {
            logError({
                message: 'Error in sign',
                error: error,
                context: {
                    accountAddress,
                    chainName,
                    isFormatted: isFormatted ? 'true' : 'false',
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async refreshWalletAccountShares({ accountAddress, chainName, password = undefined, signedSessionId, mfaToken }) {
        const dynamicRequestId = uuid.v4();
        try {
            await this.verifyPassword({
                accountAddress,
                password,
                walletOperation: core.WalletOperation.REFRESH,
                signedSessionId
            });
            const wallet = await this.getWallet({
                accountAddress,
                walletOperation: core.WalletOperation.NO_OPERATION,
                password,
                signedSessionId
            });
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            // Create the room and refresh the shares
            const data = await this.apiClient.refreshWalletAccountShares({
                dynamicRequestId,
                walletId: wallet.walletId,
                mfaToken
            });
            const roomId = data.roomId;
            const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
                accountAddress
            });
            const refreshResults = await Promise.all(clientKeyShares.map((clientKeyShare)=>mpcSigner.refresh(roomId, clientKeyShare)));
            await this.setClientKeySharesToLocalStorage({
                accountAddress,
                clientKeyShares: refreshResults,
                overwriteOrMerge: 'overwrite'
            });
            await this.storeEncryptedBackupByWallet({
                accountAddress,
                password: password != null ? password : this.environmentId,
                signedSessionId
            });
        } catch (error) {
            logError({
                message: 'Error in refreshWalletAccountShares',
                error: error,
                context: {
                    accountAddress,
                    chainName,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async getExportId({ chainName, clientKeyShare }) {
        const mpcSigner = getMPCSigner({
            chainName,
            baseRelayUrl: this.baseMPCRelayApiUrl
        });
        const exportId = await mpcSigner.exportID(clientKeyShare);
        return exportId;
    }
    /**
   * Helper function to create client shares required to complete a reshare ceremony.
   * @param {string} chainName - The chain to create shares for
   * @param {WalletProperties} wallet - The wallet to reshare
   * @param {ThresholdSignatureScheme} oldThresholdSignatureScheme - The current threshold signature scheme
   * @param {ThresholdSignatureScheme} newThresholdSignatureScheme - The target threshold signature scheme
   * @returns {Promise<{
   *   newClientInitKeygenResults: ClientInitKeygenResult[],
   *   newClientKeygenIds: string[],
   *   existingClientKeygenIds: string[],
   *   existingClientKeyShares: ClientKeyShare[]
   * }>} Object containing new and existing client keygen results, IDs and shares
   * @todo Support higher to lower reshare strategies
   */ async reshareStrategy({ chainName, wallet, accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme }) {
        const mpcSigner = getMPCSigner({
            chainName,
            baseRelayUrl: this.baseMPCRelayApiUrl
        });
        // Determine share counts based on threshold signature schemes
        const { newClientShareCount, existingClientShareCount } = core.getReshareConfig({
            oldThresholdSignatureScheme,
            newThresholdSignatureScheme
        });
        // Create new client shares
        const newClientInitKeygenResults = await Promise.all(Array.from({
            length: newClientShareCount
        }, ()=>mpcSigner.initKeygen()));
        const newClientKeygenIds = newClientInitKeygenResults.map((result)=>result.keygenId);
        // Get existing client shares
        const existingClientKeyShares = (await this.getClientKeySharesFromLocalStorage({
            accountAddress
        })).slice(0, existingClientShareCount);
        const existingClientKeygenIds = await Promise.all(existingClientKeyShares.map(async (keyShare)=>await this.getExportId({
                chainName,
                clientKeyShare: keyShare
            })));
        return {
            newClientInitKeygenResults,
            newClientKeygenIds,
            existingClientKeygenIds,
            existingClientKeyShares
        };
    }
    async reshare({ chainName, accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password = undefined, signedSessionId, backupToGoogleDrive = false, delegateToProjectEnvironment = false, mfaToken }) {
        const dynamicRequestId = uuid.v4();
        try {
            var _publicKey_key, _publicKey_key1;
            await this.verifyPassword({
                accountAddress,
                password,
                walletOperation: core.WalletOperation.RESHARE,
                signedSessionId
            });
            const { existingClientShareCount } = core.getReshareConfig({
                oldThresholdSignatureScheme,
                newThresholdSignatureScheme
            });
            const wallet = await this.getWallet({
                accountAddress,
                walletOperation: core.WalletOperation.NO_OPERATION,
                shareCount: existingClientShareCount,
                password,
                signedSessionId
            });
            const { newClientInitKeygenResults, newClientKeygenIds, existingClientKeygenIds, existingClientKeyShares } = await this.reshareStrategy({
                chainName,
                accountAddress,
                wallet,
                oldThresholdSignatureScheme,
                newThresholdSignatureScheme
            });
            const clientKeygenIds = [
                ...newClientKeygenIds,
                ...existingClientKeygenIds
            ];
            // Server to create the room and complete the server reshare logics
            const data = await this.apiClient.reshare({
                walletId: wallet.walletId,
                clientKeygenIds: clientKeygenIds,
                oldThresholdSignatureScheme,
                newThresholdSignatureScheme,
                dynamicRequestId,
                delegateToProjectEnvironment,
                mfaToken
            });
            const { roomId, serverKeygenIds, newServerKeygenIds = [] } = data;
            // Get the MPC config for the threshold signature scheme
            const oldMpcConfig = core.MPC_CONFIG[oldThresholdSignatureScheme];
            const newMpcConfig = core.MPC_CONFIG[newThresholdSignatureScheme];
            const allPartyKeygenIds = [
                ...clientKeygenIds,
                ...serverKeygenIds,
                ...newServerKeygenIds
            ];
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            const existingResharePromises = existingClientKeyShares.map((keyShare)=>mpcSigner.reshareRemainingParty(roomId, newMpcConfig.threshold, keyShare, allPartyKeygenIds));
            const newResharePromises = newClientInitKeygenResults.map((keygenResult)=>mpcSigner.reshareNewParty(roomId, oldMpcConfig.threshold, newMpcConfig.threshold, keygenResult, allPartyKeygenIds));
            // Run both share parties in parallel by group
            const [existingReshareResults, newReshareResults] = await Promise.all([
                Promise.all(existingResharePromises),
                Promise.all(newResharePromises)
            ]);
            const clientKeyshares = delegateToProjectEnvironment ? [
                ...existingReshareResults
            ] : [
                ...existingReshareResults,
                ...newReshareResults
            ];
            this.walletMap[accountAddress] = _extends({}, this.walletMap[accountAddress], {
                thresholdSignatureScheme: newThresholdSignatureScheme
            });
            await this.setClientKeySharesToLocalStorage({
                accountAddress,
                clientKeyShares: clientKeyshares,
                overwriteOrMerge: 'overwrite'
            });
            await this.storeEncryptedBackupByWallet({
                accountAddress,
                password,
                signedSessionId,
                backupToGoogleDrive,
                delegatedLocations: newReshareResults.map(()=>({
                        location: core.BackupLocation.DELEGATED
                    }))
            });
            const publicKey = await this.apiClient.getDelegatedEncryptionKey({
                environmentId: this.environmentId
            });
            if (!(publicKey == null ? void 0 : (_publicKey_key = publicKey.key) == null ? void 0 : _publicKey_key.publicKeyPemB64)) {
                throw new Error('Public key not found');
            }
            const encryptedDelegatedKeyShareEnvelope = await encryptDelegatedKeyShare(JSON.stringify(clientKeyshares[0]), publicKey == null ? void 0 : (_publicKey_key1 = publicKey.key) == null ? void 0 : _publicKey_key1.publicKeyPemB64);
            await this.apiClient.publishDelegatedKeyShare({
                walletId: this.walletMap[accountAddress].walletId,
                encryptedKeyShare: encryptedDelegatedKeyShareEnvelope == null ? void 0 : encryptedDelegatedKeyShareEnvelope.encodedEnvelopeBytes,
                encryptionVersion: ENCRYPTION_VERSION_CURRENT,
                signedSessionId,
                requiresSignedSessionId: this.requiresSignedSessionId(),
                dynamicRequestId
            });
        } catch (error) {
            logError({
                message: 'Error in reshare, resetting wallet to previous state',
                error: error,
                context: {
                    accountAddress,
                    chainName,
                    oldThresholdSignatureScheme,
                    newThresholdSignatureScheme,
                    backupToGoogleDrive,
                    dynamicRequestId
                }
            });
            // reset user wallet when reshare fails, this would allow the client to recover wallets from an active state
            this.walletMap[accountAddress] = _extends({}, this.walletMap[accountAddress], {
                thresholdSignatureScheme: oldThresholdSignatureScheme
            });
            await this.setClientKeySharesToLocalStorage({
                accountAddress,
                clientKeyShares: [],
                overwriteOrMerge: 'overwrite'
            });
            throw error;
        }
    }
    async delegateKeyShares({ accountAddress, password = undefined, signedSessionId, mfaToken }) {
        try {
            const delegateToProjectEnvironment = this.featureFlags && this.featureFlags[core.FEATURE_FLAGS.ENABLE_DELEGATED_KEY_SHARES_FLAG] === true;
            if (!delegateToProjectEnvironment) {
                throw new Error('Delegation is not allowed for this project environment');
            }
            const wallet = await this.getWallet({
                accountAddress,
                walletOperation: core.WalletOperation.REACH_ALL_PARTIES,
                password,
                signedSessionId
            });
            if (wallet.chainName === 'SUI') {
                throw new Error('Delegation is not allowed for SUI');
            }
            const currentThresholdSignatureScheme = this.walletMap[accountAddress].thresholdSignatureScheme;
            await this.reshare({
                chainName: this.walletMap[accountAddress].chainName,
                accountAddress,
                oldThresholdSignatureScheme: currentThresholdSignatureScheme,
                newThresholdSignatureScheme: core.ThresholdSignatureScheme.TWO_OF_THREE,
                password,
                signedSessionId,
                backupToGoogleDrive: false,
                delegateToProjectEnvironment: true,
                mfaToken
            });
            const backupInfo = this.walletMap[accountAddress].clientKeySharesBackupInfo;
            const delegatedKeyShares = backupInfo.backups[core.BackupLocation.DELEGATED] || [];
            return delegatedKeyShares;
        } catch (error) {
            logError({
                message: 'Error in delegateKeyShares',
                error: error,
                context: {
                    accountAddress
                }
            });
            throw error;
        }
    }
    async exportKey({ accountAddress, chainName, password = undefined, signedSessionId, mfaToken }) {
        const dynamicRequestId = uuid.v4();
        try {
            const wallet = await this.getWallet({
                accountAddress,
                password,
                walletOperation: core.WalletOperation.EXPORT_PRIVATE_KEY,
                signedSessionId
            });
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
                accountAddress
            });
            const exportId = await this.getExportId({
                chainName,
                clientKeyShare: clientKeyShares[0]
            });
            const data = await this.apiClient.exportKey({
                walletId: wallet.walletId,
                exportId,
                dynamicRequestId,
                mfaToken
            });
            this.logger.debug('[DynamicWaasWalletClient] Starting export of private key', {
                accountAddress,
                chainName,
                walletId: wallet.walletId,
                exportId,
                roomId: data.roomId
            });
            const keyExportRaw = await mpcSigner.exportFullPrivateKey(data.roomId, clientKeyShares[0], exportId);
            if (!keyExportRaw) {
                throw new Error('Error exporting private key');
            }
            this.logger.debug('[DynamicWaasWalletClient] Completed export of private key', {
                accountAddress,
                chainName,
                walletId: wallet.walletId,
                exportId,
                roomId: data.roomId
            });
            const derivationPath = wallet.derivationPath && wallet.derivationPath != '' ? new Uint32Array(Object.values(JSON.parse(wallet.derivationPath))) : undefined;
            let derivedPrivateKey;
            if (mpcSigner instanceof web.Ecdsa) {
                derivedPrivateKey = await mpcSigner.derivePrivateKeyFromXpriv(keyExportRaw, derivationPath);
            } else if (mpcSigner instanceof web.ExportableEd25519) {
                derivedPrivateKey = keyExportRaw;
            } else if (mpcSigner instanceof web.BIP340) {
                derivedPrivateKey = await mpcSigner.derivePrivateKeyFromXpriv(keyExportRaw, derivationPath);
            }
            return {
                derivedPrivateKey
            };
        } catch (error) {
            logError({
                message: 'Error in exportKey',
                error: error,
                context: {
                    accountAddress,
                    chainName,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async offlineExportKey({ chainName, keyShares, derivationPath }) {
        try {
            if (!keyShares || keyShares.length < 2) {
                throw new Error(`Must provide at least min threshold of key shares`);
            }
            const mpcSigner = getMPCSigner({
                chainName,
                baseRelayUrl: this.baseMPCRelayApiUrl
            });
            const walletKeyShares = keyShares.map((keyShare)=>{
                return mpcSigner instanceof web.Ecdsa ? new web.EcdsaKeygenResult(keyShare.pubkey, keyShare.secretShare) : mpcSigner instanceof web.ExportableEd25519 ? new web.ExportableEd25519KeygenResult(keyShare.pubkey, keyShare.secretShare) : new web.BIP340KeygenResult(keyShare.pubkey, keyShare.secretShare);
            });
            const keyExportRaw = await mpcSigner.offlineExportFullPrivateKey(walletKeyShares);
            if (!keyExportRaw) {
                throw new Error('Error exporting private key: Export returned null');
            }
            const chainConfig = core.getMPCChainConfig(chainName);
            const walletDerivationPath = !derivationPath ? undefined : new Uint32Array(chainConfig.derivationPath);
            let derivedPrivateKey;
            if (mpcSigner instanceof web.Ecdsa) {
                derivedPrivateKey = await mpcSigner.derivePrivateKeyFromXpriv(keyExportRaw, walletDerivationPath);
            } else if (mpcSigner instanceof web.ExportableEd25519) {
                derivedPrivateKey = keyExportRaw;
            } else if (mpcSigner instanceof web.BIP340) {
                derivedPrivateKey = await mpcSigner.derivePrivateKeyFromXpriv(keyExportRaw, walletDerivationPath);
            }
            const rawPublicKey = await this.derivePublicKey({
                chainName,
                keyShare: walletKeyShares[0],
                derivationPath: walletDerivationPath
            });
            return {
                derivedPrivateKey,
                rawPublicKey
            };
        } catch (error) {
            logError({
                message: 'Error in offlineExportKey',
                error: error,
                context: {
                    chainName
                }
            });
            throw error;
        }
    }
    async encryptKeyShare({ keyShare, password }) {
        const serializedKeyShare = JSON.stringify(keyShare);
        const encryptedKeyShare = await encryptData({
            data: serializedKeyShare,
            password: password != null ? password : this.environmentId
        });
        // stringify the encrypted key share, convert to base64, and store it
        const serializedEncryptedKeyShare = Buffer.from(JSON.stringify(encryptedKeyShare)).toString('base64');
        return serializedEncryptedKeyShare;
    }
    /**
   * helper function to store encrypted backup by wallet from iframe local storage
   */ async getClientKeySharesFromLocalStorage({ accountAddress }) {
        var _this_storage;
        const walletObject = await ((_this_storage = this.storage) == null ? void 0 : _this_storage.getItem(accountAddress));
        if (!walletObject) {
            this.logger.debug(`[DynamicWaasWalletClient] No item found in iframe local storage for accountAddress: ${accountAddress}`);
            return [];
        }
        try {
            let parsedWalletObject;
            if (typeof walletObject === 'string') {
                parsedWalletObject = JSON.parse(walletObject);
            } else {
                parsedWalletObject = walletObject;
            }
            return (parsedWalletObject == null ? void 0 : parsedWalletObject.clientKeyShares) || [];
        } catch (error) {
            logError({
                message: `Error parsing clientKeyShares: Error for accountAddress:`,
                error: error,
                context: {
                    accountAddress
                }
            });
            return [];
        }
    }
    /**
   * helper function to store encrypted backup by wallet from iframe local storage
   */ async setClientKeySharesToLocalStorage({ accountAddress, clientKeyShares, overwriteOrMerge = 'merge' }) {
        var _this_storage;
        const stringifiedClientKeyShares = JSON.stringify({
            clientKeyShares: overwriteOrMerge === 'overwrite' ? clientKeyShares : mergeUniqueKeyShares(await this.getClientKeySharesFromLocalStorage({
                accountAddress
            }), clientKeyShares)
        });
        await ((_this_storage = this.storage) == null ? void 0 : _this_storage.setItem(accountAddress, stringifiedClientKeyShares));
    }
    /**
   * Central backup orchestrator that encrypts and stores wallet key shares.
   *
   * This method serves as the main backup coordinator, handling the distribution of encrypted
   * key shares between Dynamic's backend and Google Drive based on the wallet's threshold scheme.
   * It is used by multiple operations including reshare, refresh, and manual backup requests.
   *
   * **Backup Distribution Strategy:**
   * - **Single share wallets**: All shares stored on Dynamic's backend only
   * - **Multi-share wallets (2+)**: When backing up to Google Drive, N-1 shares on Dynamic's backend, 1 share on Google Drive
   * - **Multi-share wallets (2+)**: When not backing up to Google Drive, all shares on Dynamic's backend
   *
   * **Process Flow:**
   * 1. Encrypts all client key shares with the provided password (or environment ID if no password)
   * 2. For multi-share wallets (2+): conditionally distributes N-1 to backend, 1 to Google Drive
   * 3. For other configurations: stores all shares on Dynamic's backend
   * 4. Updates backup metadata and synchronizes wallet state
   * 5. Persists the updated wallet map to local storage
   *
   * @param params - The backup operation parameters
   * @param params.accountAddress - The account address of the wallet to backup
   * @param params.clientKeyShares - Optional specific key shares to backup (uses localStorage if not provided)
   * @param params.password - Optional password for encryption (uses environment ID if not provided)
   * @param params.signedSessionId - Optional signed session ID for authentication
   * @param params.backupToGoogleDrive - Whether to backup to Google Drive (defaults to false)
   * @returns Promise with backup metadata including share locations and IDs
   */ async storeEncryptedBackupByWallet({ accountAddress, clientKeyShares = undefined, password = undefined, signedSessionId, backupToGoogleDrive = false, delegatedLocations = [] }) {
        const dynamicRequestId = uuid.v4();
        try {
            var _this_walletMap_accountAddress, _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_GOOGLE_DRIVE, _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups, _this_walletMap_accountAddress_clientKeySharesBackupInfo, _this_walletMap_accountAddress1;
            const keySharesToBackup = clientKeyShares != null ? clientKeyShares : await this.getClientKeySharesFromLocalStorage({
                accountAddress
            });
            if (!((_this_walletMap_accountAddress = this.walletMap[accountAddress]) == null ? void 0 : _this_walletMap_accountAddress.walletId)) {
                const error = new Error(`WalletId not found for accountAddress ${accountAddress}`);
                logError({
                    message: 'Error in storeEncryptedBackupByWallet, wallet or walletId not found from the wallet map',
                    error,
                    context: {
                        accountAddress,
                        walletMap: this.walletMap
                    }
                });
                throw error;
            }
            // TODO(zfaizal2): throw error if signedSessionId is not provided after service deploy
            let dynamicClientKeyShares = [];
            let googleDriveKeyShares = [];
            const encryptedKeyShares = await Promise.all(keySharesToBackup.map((keyShare)=>this.encryptKeyShare({
                    keyShare,
                    password
                })));
            const hasExistingGoogleDriveBackup = ((_this_walletMap_accountAddress1 = this.walletMap[accountAddress]) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo = _this_walletMap_accountAddress1.clientKeySharesBackupInfo) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo_backups = _this_walletMap_accountAddress_clientKeySharesBackupInfo.backups) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_GOOGLE_DRIVE = _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups[core.BackupLocation.GOOGLE_DRIVE]) == null ? void 0 : _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_GOOGLE_DRIVE.length) > 0;
            // Backup to Google Drive if:
            // 1. Explicitly requested via flag, OR
            // 2. User already has Google Drive backups
            const shouldBackupToGoogleDrive = backupToGoogleDrive || hasExistingGoogleDriveBackup;
            if (shouldBackupToGoogleDrive && keySharesToBackup.length >= 2) {
                // For 2 shares: 1 to backend, 1 to Google Drive
                // For 3+ shares: N-1 to backend, 1 to Google Drive
                const googleDriveShareCount = 1;
                dynamicClientKeyShares = encryptedKeyShares.slice(0, -googleDriveShareCount);
                googleDriveKeyShares = encryptedKeyShares.slice(-googleDriveShareCount);
            } else {
                dynamicClientKeyShares = encryptedKeyShares;
            }
            const data = await this.apiClient.storeEncryptedBackupByWallet({
                walletId: this.walletMap[accountAddress].walletId,
                encryptedKeyShares: dynamicClientKeyShares,
                passwordEncrypted: Boolean(password) && password !== this.environmentId,
                encryptionVersion: ENCRYPTION_VERSION_CURRENT,
                signedSessionId,
                authMode: this.authMode,
                requiresSignedSessionId: this.requiresSignedSessionId(),
                dynamicRequestId
            });
            if (data.keyShareIds.length === 0) {
                throw new Error('No key shares were backed up');
            }
            const locations = [
                {
                    location: core.BackupLocation.DYNAMIC,
                    externalKeyShareId: data.keyShareIds[0]
                }
            ];
            if (googleDriveKeyShares.length > 0) {
                await this.uploadKeySharesToGoogleDrive({
                    accountAddress,
                    encryptedKeyShares: googleDriveKeyShares
                });
                locations.push({
                    location: core.BackupLocation.GOOGLE_DRIVE
                });
            }
            if ((delegatedLocations == null ? void 0 : delegatedLocations.length) > 0) {
                locations.push(...delegatedLocations);
            }
            const backupData = await this.apiClient.markKeySharesAsBackedUp({
                walletId: this.walletMap[accountAddress].walletId,
                locations,
                dynamicRequestId
            });
            const updatedBackupInfo = getClientKeyShareBackupInfo({
                walletProperties: {
                    derivationPath: this.walletMap[accountAddress].derivationPath,
                    keyShares: backupData.locationsWithKeyShares.map((ks)=>({
                            id: ks.keyShareId,
                            backupLocation: ks.location,
                            externalKeyShareId: ks.externalKeyShareId,
                            passwordEncrypted: Boolean(password) && password !== this.environmentId
                        })),
                    thresholdSignatureScheme: this.walletMap[accountAddress].thresholdSignatureScheme
                }
            });
            this.walletMap[accountAddress] = _extends({}, this.walletMap[accountAddress], {
                clientKeySharesBackupInfo: updatedBackupInfo
            });
            await this.storage.setItem(this.storageKey, JSON.stringify(this.walletMap));
            return data;
        } catch (error) {
            logError({
                message: 'Error in storeEncryptedBackupByWallet',
                error: error,
                context: {
                    accountAddress,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async storeEncryptedBackupByWalletWithRetry({ accountAddress, clientKeyShares, password, signedSessionId }) {
        await retryPromise(()=>this.storeEncryptedBackupByWallet({
                accountAddress,
                clientKeyShares,
                password,
                signedSessionId
            }), {
            operationName: 'store encrypted backup',
            logContext: {
                walletAddress: accountAddress
            }
        });
    }
    async updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId }) {
        await this.getWallet({
            accountAddress,
            password: existingPassword,
            walletOperation: core.WalletOperation.REACH_ALL_PARTIES,
            signedSessionId
        });
        await this.storeEncryptedBackupByWallet({
            accountAddress,
            password: newPassword,
            signedSessionId
        });
    }
    async decryptKeyShare({ keyShare, password }) {
        const decodedKeyShare = JSON.parse(Buffer.from(keyShare, 'base64').toString());
        const decryptedKeyShare = await decryptData({
            data: decodedKeyShare,
            password: password != null ? password : this.environmentId
        });
        const deserializedKeyShare = JSON.parse(decryptedKeyShare);
        return deserializedKeyShare;
    }
    /**
   * Helper function to get Google OAuth Account ID or throw an error if not found.
   * @param accountAddress - The account address for logging purposes
   * @returns The Google OAuth Account ID
   * @throws Error if no Google OAuth account ID is found
   */ async getGoogleOauthAccountIdOrThrow(accountAddress) {
        const dynamicRequestId = uuid.v4();
        try {
            const user = await this.apiClient.getUser(dynamicRequestId);
            const oauthAccountId = getGoogleOAuthAccountId(user == null ? void 0 : user.verifiedCredentials);
            if (!oauthAccountId) {
                const error = new Error('No Google OAuth account ID found');
                logError({
                    message: 'No Google OAuth account ID found',
                    error,
                    context: {
                        user,
                        accountAddress
                    }
                });
                throw error;
            }
            return oauthAccountId;
        } catch (error) {
            logError({
                message: 'Error in getGoogleOauthAccountIdOrThrow',
                error: error,
                context: {
                    accountAddress,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    /**
   * Helper function to determine keyshare recovery strategy for dynamic shares.
   * For REFRESH operations, retrieves enough shares to meet the client threshold.
   * For all other operations, retrieves just 1 share.
   *
   * @param clientKeyShareBackupInfo - Information about backed up key shares
   * @param thresholdSignatureScheme - The signature scheme being used (2-of-2, 2-of-3, etc)
   * @param walletOperation - The operation being performed (REFRESH, SIGN_MESSAGE, etc)
   * @param shareCount - The number of shares to recover if specified for reshare operations
   * @returns @shares: Object mapping backup locations to arrays of share IDs to recover
   * @returns @requiredShareCount: The number of shares required to recover
   */ recoverStrategy({ clientKeyShareBackupInfo, thresholdSignatureScheme, walletOperation, shareCount = undefined }) {
        const { backups } = clientKeyShareBackupInfo;
        const { clientThreshold } = core.MPC_CONFIG[thresholdSignatureScheme];
        let requiredShareCount = walletOperation === core.WalletOperation.REFRESH || walletOperation === core.WalletOperation.REACH_ALL_PARTIES || walletOperation === core.WalletOperation.RESHARE ? clientThreshold : 1;
        // Override requiredShareCount if shareCount is provided
        if (shareCount !== undefined) {
            requiredShareCount = shareCount;
        }
        const dynamicShares = backups[core.BackupLocation.DYNAMIC].slice(0, requiredShareCount);
        return {
            shares: {
                [core.BackupLocation.DYNAMIC]: dynamicShares.map((ks)=>{
                    var _ks_externalKeyShareId, _ref;
                    return (_ref = (_ks_externalKeyShareId = ks.externalKeyShareId) != null ? _ks_externalKeyShareId : ks.keyShareId) != null ? _ref : '';
                })
            },
            requiredShareCount
        };
    }
    async recoverEncryptedBackupByWallet({ accountAddress, password, walletOperation, signedSessionId, shareCount = undefined, storeRecoveredShares = true, mfaToken }) {
        try {
            const wallet = this.walletMap[accountAddress];
            this.logger.debug(`recoverEncryptedBackupByWallet wallet: ${walletOperation}`, wallet);
            const { shares } = this.recoverStrategy({
                clientKeyShareBackupInfo: wallet.clientKeySharesBackupInfo,
                thresholdSignatureScheme: wallet.thresholdSignatureScheme,
                walletOperation,
                shareCount
            });
            const { dynamic: dynamicKeyShareIds } = shares;
            const data = await this.apiClient.recoverEncryptedBackupByWallet({
                walletId: wallet.walletId,
                keyShareIds: dynamicKeyShareIds,
                signedSessionId,
                mfaToken,
                requiresSignedSessionId: this.requiresSignedSessionId()
            });
            const dynamicKeyShares = data.keyShares.filter((keyShare)=>keyShare.encryptedAccountCredential !== null && keyShare.backupLocation === core.BackupLocation.DYNAMIC);
            const decryptedKeyShares = await Promise.all(dynamicKeyShares.map((keyShare)=>this.decryptKeyShare({
                    keyShare: keyShare.encryptedAccountCredential,
                    password: password != null ? password : this.environmentId
                })));
            if (storeRecoveredShares) {
                await this.setClientKeySharesToLocalStorage({
                    accountAddress,
                    clientKeyShares: decryptedKeyShares,
                    overwriteOrMerge: 'merge'
                });
                await this.storage.setItem(this.storageKey, JSON.stringify(this.walletMap));
            }
            return decryptedKeyShares;
        } catch (error) {
            logError({
                message: 'Error in recoverEncryptedBackupByWallet',
                error: error,
                context: {
                    accountAddress,
                    walletOperation,
                    shareCount
                }
            });
            throw error;
        }
    }
    async restoreWallets() {
        const wallets = await this.storage.getItem(this.storageKey);
        if (!wallets) {
            return;
        }
        this.walletMap = JSON.parse(wallets);
    }
    /**
   * This method handles the complete flow for ensuring wallet key shares are backed up to Google Drive:
   * - For 2-of-2 wallets: Automatically reshares to 2-of-3 threshold, then distributes shares (1 to backend, 1 to Google Drive)
   * - For 2-of-3 wallets: Call storeEncryptedBackupByWallet to backup for backend and Google Drive
   *
   * @param params - The backup parameters
   * @param params.accountAddress - The wallet account address to backup
   * @param params.password - Optional password for encryption (uses environment ID if not provided)
   * @param params.signedSessionId - Optional signed session ID for authentication
   * @returns Promise<string[]> - Array of Google Drive key share IDs that were backed up
   */ async backupKeySharesToGoogleDrive({ accountAddress, password, signedSessionId }) {
        try {
            await this.getWallet({
                accountAddress,
                walletOperation: core.WalletOperation.REACH_ALL_PARTIES,
                password,
                signedSessionId
            });
            const currentThresholdSignatureScheme = this.walletMap[accountAddress].thresholdSignatureScheme;
            if (currentThresholdSignatureScheme === core.ThresholdSignatureScheme.TWO_OF_TWO) {
                // Reshare to 2-of-3, which will automatically handle the backup distribution
                await this.reshare({
                    chainName: this.walletMap[accountAddress].chainName,
                    accountAddress,
                    oldThresholdSignatureScheme: currentThresholdSignatureScheme,
                    newThresholdSignatureScheme: core.ThresholdSignatureScheme.TWO_OF_THREE,
                    password,
                    signedSessionId,
                    backupToGoogleDrive: true
                });
                const backupInfo = this.walletMap[accountAddress].clientKeySharesBackupInfo;
                const googleDriveShares = backupInfo.backups[core.BackupLocation.GOOGLE_DRIVE] || [];
                return googleDriveShares.map((ks)=>{
                    var _ks_externalKeyShareId;
                    return (_ks_externalKeyShareId = ks.externalKeyShareId) != null ? _ks_externalKeyShareId : '';
                });
            } else {
                // Already 2-of-3, only call backup
                const data = await this.storeEncryptedBackupByWallet({
                    accountAddress,
                    password,
                    signedSessionId,
                    backupToGoogleDrive: true
                });
                return data.keyShareIds;
            }
        } catch (error) {
            logError({
                message: 'Error in backupKeySharesToGoogleDrive',
                error: error,
                context: {
                    accountAddress
                }
            });
            throw error;
        }
    }
    /**
   * This method handles only the Google Drive upload mechanics without any reshare logic.
   * It encrypts the provided key shares, uploads them to Google Drive, and updates the
   * backup metadata. This method is intended for internal use by storeEncryptedBackupByWallet
   * and should not be called directly from external code.
   *
   * @param params - The upload parameters
   * @param params.accountAddress - The wallet account address
   * @param params.password - Optional password for encryption (uses environment ID if not provided)
   * @param params.encryptedKeyShares - The specific key shares to upload to Google Drive
   * @returns Promise<string[]> - Array of Google Drive key share IDs that were uploaded
   */ async uploadKeySharesToGoogleDrive({ accountAddress, encryptedKeyShares }) {
        try {
            if (encryptedKeyShares.length === 0) {
                throw new Error('No key shares found');
            }
            const oauthAccountId = await this.getGoogleOauthAccountIdOrThrow(accountAddress);
            const accessToken = await this.apiClient.getAccessToken({
                oauthAccountId
            });
            const thresholdSignatureScheme = this.walletMap[accountAddress].thresholdSignatureScheme;
            const fileName = getClientKeyShareExportFileName({
                thresholdSignatureScheme,
                accountAddress
            });
            const backupData = createBackupData({
                encryptedKeyShares,
                accountAddress,
                thresholdSignatureScheme
            });
            await uploadBackupToGoogleDrive({
                accessToken,
                fileName,
                backupData,
                accountAddress
            });
            return;
        } catch (error) {
            logError({
                message: 'Error in backupKeySharesToGoogleDrive',
                error: error,
                context: {
                    accountAddress
                }
            });
            throw error;
        }
    }
    async restoreBackupFromGoogleDrive({ accountAddress, password, signedSessionId }) {
        try {
            await this.getWallet({
                accountAddress,
                signedSessionId
            });
            const oauthAccountId = await this.getGoogleOauthAccountIdOrThrow(accountAddress);
            const accessToken = await this.apiClient.getAccessToken({
                oauthAccountId
            });
            const thresholdSignatureScheme = this.walletMap[accountAddress].thresholdSignatureScheme;
            const fileName = getClientKeyShareExportFileName({
                thresholdSignatureScheme,
                accountAddress
            });
            let backupData = null;
            try {
                backupData = await retryPromise(()=>downloadFileFromGoogleDrive({
                        accessToken,
                        fileName
                    }));
            } catch (error) {
                logError({
                    message: 'Failed to download backup from Google Drive',
                    error: error,
                    context: {
                        accountAddress,
                        fileName
                    }
                });
                throw error;
            }
            if (!backupData) {
                const error = new Error('No backup file found');
                logError({
                    message: 'No backup file found',
                    error: new Error('No backup file found'),
                    context: {
                        accountAddress,
                        fileName
                    }
                });
                throw error;
            }
            // Validate the backup data structure
            if (!backupData.keyShares || !backupData.metadata) {
                const error = new Error('Invalid backup format: missing keyShares or metadata');
                logError({
                    message: 'Invalid backup format: missing keyShares or metadata',
                    error,
                    context: {
                        accountAddress,
                        fileName
                    }
                });
                throw error;
            }
            const { keyShares } = backupData;
            const decryptedKeyShares = await Promise.all(keyShares.map((keyShare)=>this.decryptKeyShare({
                    keyShare,
                    password
                })));
            await this.setClientKeySharesToLocalStorage({
                accountAddress,
                clientKeyShares: decryptedKeyShares,
                overwriteOrMerge: 'merge'
            });
            return decryptedKeyShares;
        } catch (error) {
            logError({
                message: 'Error in restoreBackupFromGoogleDrive',
                error: error,
                context: {
                    accountAddress
                }
            });
            throw error;
        }
    }
    async exportClientKeyshares({ accountAddress, password, signedSessionId }) {
        await this.verifyPassword({
            accountAddress,
            password,
            walletOperation: core.WalletOperation.REACH_ALL_PARTIES,
            signedSessionId
        });
        const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
            accountAddress
        });
        if (!accountAddress) {
            throw new Error('Must provide an account address');
        }
        const derivationPath = this.walletMap[accountAddress].derivationPath;
        const text = JSON.stringify({
            keyShares: clientKeyShares,
            derivationPath
        });
        const blob = new Blob([
            text
        ], {
            type: 'text/plain'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${CLIENT_KEYSHARE_EXPORT_FILENAME_PREFIX}-${accountAddress}.txt`;
        a.click();
    }
    async getClientKeyShares({ accountAddress, password, signedSessionId }) {
        await this.getWallet({
            accountAddress,
            password,
            walletOperation: core.WalletOperation.REACH_THRESHOLD,
            signedSessionId
        });
        return this.getClientKeySharesFromLocalStorage({
            accountAddress
        });
    }
    /**
   * Helper function to check if the required wallet fields are present and valid
   * @param accountAddress - The account address of the wallet to check
   * @param walletOperation - The wallet operation that determines required fields
   * @returns boolean indicating if wallet needs to be re-fetched and restored from server
   */ async checkWalletFields({ accountAddress, walletOperation = core.WalletOperation.REACH_THRESHOLD, shareCount }) {
        let keyshareCheck = false;
        let walletCheck = false;
        let thresholdSignatureSchemeCheck = false;
        let derivationPathCheck = false;
        // check if wallet exists
        const existingWallet = this.walletMap[accountAddress];
        if (existingWallet) {
            walletCheck = true;
        }
        // check if threshold signature scheme exists
        if (existingWallet == null ? void 0 : existingWallet.thresholdSignatureScheme) {
            thresholdSignatureSchemeCheck = true;
        }
        // check if derivation path exists
        if ((existingWallet == null ? void 0 : existingWallet.derivationPath) || (existingWallet == null ? void 0 : existingWallet.derivationPath) === '') {
            derivationPathCheck = true;
        }
        // check if wallet already exists with sufficient keyshares
        if (existingWallet) {
            const { shares } = this.recoverStrategy({
                clientKeyShareBackupInfo: existingWallet.clientKeySharesBackupInfo || {
                    backups: getClientKeyShareBackupInfo()
                },
                thresholdSignatureScheme: existingWallet.thresholdSignatureScheme,
                walletOperation,
                shareCount
            });
            const { dynamic: requiredDynamicKeyShareIds = [] } = shares;
            const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
                accountAddress
            });
            if (requiredDynamicKeyShareIds.length <= ((clientKeyShares == null ? void 0 : clientKeyShares.length) || 0)) {
                keyshareCheck = true;
            }
        }
        return walletCheck && thresholdSignatureSchemeCheck && keyshareCheck && derivationPathCheck;
    }
    /**
   * verifyPassword attempts to recover and decrypt a single client key share using the provided password.
   * If successful, the key share is encrypted with the new password. This method solely performs the recovery
   * and decryption without storing the restored key shares. If unsuccessful, it throws an error.
   */ async verifyPassword({ accountAddress, password = undefined, walletOperation = core.WalletOperation.NO_OPERATION, signedSessionId }) {
        await this.getWallet({
            accountAddress,
            password,
            walletOperation,
            signedSessionId
        });
        if (await this.requiresPasswordForOperation({
            accountAddress,
            walletOperation
        }) && !password) {
            throw new Error('Password is required for operation but not provided');
        }
        // silent return if no password is provided and operation does not require a password
        if (!password) {
            return;
        }
        const { backups } = await this.getWalletClientKeyShareBackupInfo({
            accountAddress
        });
        const { dynamic: dynamicKeyShareIds = [] } = backups;
        if (!dynamicKeyShareIds || dynamicKeyShareIds.length === 0) {
            throw new Error('No dynamic key shares found');
        }
        try {
            // TODO(zfaizal2): throw error if signedSessionId is not provided after service deploy
            await this.recoverEncryptedBackupByWallet({
                accountAddress,
                password,
                walletOperation,
                shareCount: 1,
                storeRecoveredShares: false,
                signedSessionId
            });
        } catch (error) {
            logError({
                message: 'Error in verifyPassword',
                error: error,
                context: {
                    accountAddress
                }
            });
            throw error;
        }
    }
    async isPasswordEncrypted({ accountAddress }) {
        const clientKeySharesBackupInfo = await this.getWalletClientKeyShareBackupInfo({
            accountAddress
        });
        return clientKeySharesBackupInfo == null ? void 0 : clientKeySharesBackupInfo.passwordEncrypted;
    }
    /**
   * check if the operation requires a password
   */ async requiresPasswordForOperation({ accountAddress, walletOperation = core.WalletOperation.REACH_THRESHOLD }) {
        const isEncrypted = await this.isPasswordEncrypted({
            accountAddress
        });
        if (!isEncrypted) {
            return false;
        }
        return this.requiresRestoreBackupSharesForOperation({
            accountAddress,
            walletOperation
        });
    }
    /**
   * check if the operation requires restoring backup shares
   */ async requiresRestoreBackupSharesForOperation({ accountAddress, walletOperation = core.WalletOperation.REACH_THRESHOLD }) {
        const clientKeySharesBackupInfo = await this.getWalletClientKeyShareBackupInfo({
            accountAddress
        });
        const clientKeyShares = await this.getClientKeySharesFromLocalStorage({
            accountAddress
        });
        if (walletOperation === core.WalletOperation.REACH_ALL_PARTIES || walletOperation === core.WalletOperation.REFRESH || walletOperation === core.WalletOperation.RESHARE) {
            return true;
        }
        const { requiredShareCount } = this.recoverStrategy({
            clientKeyShareBackupInfo: clientKeySharesBackupInfo,
            thresholdSignatureScheme: this.walletMap[accountAddress].thresholdSignatureScheme,
            walletOperation
        });
        if (clientKeyShares.length >= requiredShareCount) {
            return false;
        }
        return true;
    }
    async getWalletClientKeyShareBackupInfo({ accountAddress }) {
        const dynamicRequestId = uuid.v4();
        try {
            var _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_DYNAMIC, _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups, _this_walletMap_accountAddress_clientKeySharesBackupInfo, _this_walletMap_accountAddress, _user_verifiedCredentials;
            // Return existing backup info if it exists
            if (((_this_walletMap_accountAddress = this.walletMap[accountAddress]) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo = _this_walletMap_accountAddress.clientKeySharesBackupInfo) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo_backups = _this_walletMap_accountAddress_clientKeySharesBackupInfo.backups) == null ? void 0 : (_this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_DYNAMIC = _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups[core.BackupLocation.DYNAMIC]) == null ? void 0 : _this_walletMap_accountAddress_clientKeySharesBackupInfo_backups_BackupLocation_DYNAMIC.length) > 0) {
                return this.walletMap[accountAddress].clientKeySharesBackupInfo;
            }
            // Get backup info from server
            const user = await this.apiClient.getUser(dynamicRequestId);
            const wallet = (_user_verifiedCredentials = user.verifiedCredentials) == null ? void 0 : _user_verifiedCredentials.find((vc)=>vc.address.toLowerCase() === accountAddress.toLowerCase());
            return getClientKeyShareBackupInfo({
                walletProperties: wallet == null ? void 0 : wallet.walletProperties
            });
        } catch (error) {
            logError({
                message: 'Error in getWalletClientKeyShareBackupInfo',
                error: error,
                context: {
                    accountAddress,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async getWallet({ accountAddress, walletOperation = core.WalletOperation.NO_OPERATION, shareCount = undefined, password = undefined, signedSessionId }) {
        const dynamicRequestId = uuid.v4();
        try {
            var _user_verifiedCredentials;
            const existingWalletCheck = await this.checkWalletFields({
                accountAddress,
                walletOperation,
                shareCount
            });
            if (existingWalletCheck) {
                this.logger.debug(`[DynamicWaasWalletClient] Wallet ${accountAddress} already exists`);
                return this.walletMap[accountAddress];
            }
            // Fetch and restore wallet from server
            const user = await this.apiClient.getUser(dynamicRequestId);
            const wallet = (_user_verifiedCredentials = user.verifiedCredentials) == null ? void 0 : _user_verifiedCredentials.find((vc)=>vc.address.toLowerCase() === accountAddress.toLowerCase());
            this.logger.debug('[DynamicWaasWalletClient] Restoring wallet', wallet);
            const walletProperties = wallet.walletProperties;
            this.walletMap[accountAddress] = _extends({}, this.walletMap[accountAddress], {
                walletId: wallet.id,
                chainName: core.verifiedCredentialNameToChainEnum[wallet.chain],
                accountAddress,
                thresholdSignatureScheme: walletProperties.thresholdSignatureScheme,
                derivationPath: walletProperties.derivationPath,
                clientKeySharesBackupInfo: getClientKeyShareBackupInfo({
                    walletProperties
                })
            });
            if (walletOperation !== core.WalletOperation.NO_OPERATION && await this.requiresRestoreBackupSharesForOperation({
                accountAddress,
                walletOperation
            })) {
                // TODO(zfaizal2): throw error if signedSessionId is not provided after service deploy
                const decryptedKeyShares = await this.recoverEncryptedBackupByWallet({
                    accountAddress,
                    password: password != null ? password : this.environmentId,
                    walletOperation: walletOperation,
                    signedSessionId,
                    shareCount
                });
                const existingKeyShares = await this.getClientKeySharesFromLocalStorage({
                    accountAddress
                });
                await this.setClientKeySharesToLocalStorage({
                    accountAddress,
                    clientKeyShares: mergeUniqueKeyShares(existingKeyShares, decryptedKeyShares)
                });
                this.logger.debug('[DynamicWaasWalletClient] Recovered backup', decryptedKeyShares);
            }
            const walletCount = Object.keys(this.walletMap).length;
            if (walletCount === 0) {
                throw new Error('No wallets found');
            }
            // Return the only wallet if there's just one
            if (walletCount === 1) {
                return Object.values(this.walletMap)[0];
            }
            return this.walletMap[accountAddress];
        } catch (error) {
            logError({
                message: 'Error in getWallet',
                error: error,
                context: {
                    accountAddress,
                    walletOperation,
                    shareCount,
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    async getWallets() {
        const dynamicRequestId = uuid.v4();
        try {
            var _user_verifiedCredentials;
            const user = await this.apiClient.getUser(dynamicRequestId);
            this.userId = user.id;
            const waasWallets = (_user_verifiedCredentials = user.verifiedCredentials) == null ? void 0 : _user_verifiedCredentials.filter((vc)=>vc.walletName === 'dynamicwaas');
            const wallets = waasWallets.map((vc)=>{
                var _this_walletMap_vc_address, _vc_walletProperties;
                var _this_walletMap_vc_address_derivationPath;
                return {
                    walletId: vc.id,
                    chainName: vc.chain,
                    accountAddress: vc.address,
                    clientKeySharesBackupInfo: getClientKeyShareBackupInfo({
                        walletProperties: vc.walletProperties || {}
                    }),
                    derivationPath: (_this_walletMap_vc_address_derivationPath = (_this_walletMap_vc_address = this.walletMap[vc.address]) == null ? void 0 : _this_walletMap_vc_address.derivationPath) != null ? _this_walletMap_vc_address_derivationPath : undefined,
                    thresholdSignatureScheme: (_vc_walletProperties = vc.walletProperties) == null ? void 0 : _vc_walletProperties.thresholdSignatureScheme
                };
            });
            this.walletMap = wallets.reduce((acc, wallet)=>{
                var _acc_accountAddress;
                const accountAddress = wallet.accountAddress;
                acc[wallet.accountAddress] = {
                    walletId: wallet.walletId,
                    chainName: wallet.chainName,
                    accountAddress: wallet.accountAddress,
                    clientKeySharesBackupInfo: wallet.clientKeySharesBackupInfo,
                    derivationPath: ((_acc_accountAddress = acc[accountAddress]) == null ? void 0 : _acc_accountAddress.derivationPath) || undefined,
                    thresholdSignatureScheme: wallet.thresholdSignatureScheme
                };
                return acc;
            }, {});
            return wallets;
        } catch (error) {
            logError({
                message: 'Error in getWallets',
                error: error,
                context: {
                    dynamicRequestId
                }
            });
            throw error;
        }
    }
    /**
   * sync auth token with api client
   * @param authToken - auth token to sync
   */ syncAuthToken(authToken) {
        if (this.authMode === core.AuthMode.COOKIE) {
            return;
        }
        this.apiClient.syncAuthToken(authToken);
    }
    constructor({ environmentId, baseApiUrl, baseMPCRelayApiUrl, storageKey, debug, featureFlags, authMode = core.AuthMode.HEADER, authToken = undefined, // Represents the version of the client SDK used by developer
    sdkVersion }){
        this.userId = undefined;
        this.sessionId = undefined;
        this.initializePromise = null;
        this.logger = logger;
        this.walletMap = {} // todo: store in session storage
        ;
        this.memoryStorage = null;
        this.iframe = null;
        this.featureFlags = {};
        this.environmentId = environmentId;
        this.storageKey = `${STORAGE_KEY}-${storageKey != null ? storageKey : environmentId}`;
        this.baseMPCRelayApiUrl = baseMPCRelayApiUrl;
        this.authMode = authMode;
        this.sdkVersion = sdkVersion;
        this.apiClient = new core.DynamicApiClient({
            environmentId,
            authToken,
            baseApiUrl,
            authMode,
            sdkVersion
        });
        this.debug = Boolean(debug);
        this.logger.setLogLevel(this.debug ? logger$1.LogLevel.DEBUG : DEFAULT_LOG_LEVEL);
        this.featureFlags = featureFlags || {};
        // setup storage
        if (supportsLocalStorage()) {
            this.storage = localStorageAdapter;
        } else {
            this.memoryStorage = {};
            this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
        const environment = core.getEnvironmentFromUrl(baseApiUrl);
        this.iframeDomain = core.IFRAME_DOMAIN_MAP[environment];
        // Generate unique instanceId when client is created
        this.instanceId = uuid.v4();
        // initialize logger context
        if (authMode === core.AuthMode.HEADER && authToken) {
            this.initLoggerContext(authToken);
        }
    }
}

const ERROR_KEYGEN_FAILED = '[DynamicWaasWalletClient]: Error with keygen';
const ERROR_CREATE_WALLET_ACCOUNT = '[DynamicWaasWalletClient]: Error creating wallet account';
const ERROR_SIGN_MESSAGE = '[DynamicWaasWalletClient]: Error signing message';
const ERROR_SIGN_TYPED_DATA = '[DynamicWaasWalletClient]: Error signing typed data';
const ERROR_ACCOUNT_ADDRESS_REQUIRED = '[DynamicWaasWalletClient]: Account address is required';
const ERROR_VERIFY_MESSAGE_SIGNATURE = '[DynamicWaasWalletClient]: Error verifying message signature';
const ERROR_VERIFY_TRANSACTION_SIGNATURE = '[DynamicWaasWalletClient]: Error verifying transaction signature';
const ERROR_EXPORT_PRIVATE_KEY = '[DynamicWaasWalletClient]: Error exporting private key';
const ERROR_IMPORT_PRIVATE_KEY = '[DynamicWaasWalletClient]: Error importing private key';

Object.defineProperty(exports, "BIP340", {
    enumerable: true,
    get: function () { return web.BIP340; }
});
Object.defineProperty(exports, "BIP340InitKeygenResult", {
    enumerable: true,
    get: function () { return web.BIP340InitKeygenResult; }
});
Object.defineProperty(exports, "BIP340KeygenResult", {
    enumerable: true,
    get: function () { return web.BIP340KeygenResult; }
});
Object.defineProperty(exports, "Ecdsa", {
    enumerable: true,
    get: function () { return web.Ecdsa; }
});
Object.defineProperty(exports, "EcdsaInitKeygenResult", {
    enumerable: true,
    get: function () { return web.EcdsaInitKeygenResult; }
});
Object.defineProperty(exports, "EcdsaKeygenResult", {
    enumerable: true,
    get: function () { return web.EcdsaKeygenResult; }
});
Object.defineProperty(exports, "EcdsaPublicKey", {
    enumerable: true,
    get: function () { return web.EcdsaPublicKey; }
});
Object.defineProperty(exports, "EcdsaSignature", {
    enumerable: true,
    get: function () { return web.EcdsaSignature; }
});
Object.defineProperty(exports, "Ed25519", {
    enumerable: true,
    get: function () { return web.Ed25519; }
});
Object.defineProperty(exports, "Ed25519InitKeygenResult", {
    enumerable: true,
    get: function () { return web.Ed25519InitKeygenResult; }
});
Object.defineProperty(exports, "Ed25519KeygenResult", {
    enumerable: true,
    get: function () { return web.Ed25519KeygenResult; }
});
Object.defineProperty(exports, "MessageHash", {
    enumerable: true,
    get: function () { return web.MessageHash; }
});
Object.defineProperty(exports, "Logger", {
    enumerable: true,
    get: function () { return logger$1.Logger; }
});
exports.DynamicWalletClient = DynamicWalletClient;
exports.ERROR_ACCOUNT_ADDRESS_REQUIRED = ERROR_ACCOUNT_ADDRESS_REQUIRED;
exports.ERROR_CREATE_WALLET_ACCOUNT = ERROR_CREATE_WALLET_ACCOUNT;
exports.ERROR_EXPORT_PRIVATE_KEY = ERROR_EXPORT_PRIVATE_KEY;
exports.ERROR_IMPORT_PRIVATE_KEY = ERROR_IMPORT_PRIVATE_KEY;
exports.ERROR_KEYGEN_FAILED = ERROR_KEYGEN_FAILED;
exports.ERROR_SIGN_MESSAGE = ERROR_SIGN_MESSAGE;
exports.ERROR_SIGN_TYPED_DATA = ERROR_SIGN_TYPED_DATA;
exports.ERROR_VERIFY_MESSAGE_SIGNATURE = ERROR_VERIFY_MESSAGE_SIGNATURE;
exports.ERROR_VERIFY_TRANSACTION_SIGNATURE = ERROR_VERIFY_TRANSACTION_SIGNATURE;
exports.createBackupData = createBackupData;
exports.formatEvmMessage = formatEvmMessage;
exports.formatMessage = formatMessage;
exports.getClientKeyShareBackupInfo = getClientKeyShareBackupInfo;
exports.getClientKeyShareExportFileName = getClientKeyShareExportFileName;
exports.getGoogleOAuthAccountId = getGoogleOAuthAccountId;
exports.getMPCSignatureScheme = getMPCSignatureScheme;
exports.getMPCSigner = getMPCSigner;
exports.isBrowser = isBrowser;
exports.isHexString = isHexString;
exports.mergeUniqueKeyShares = mergeUniqueKeyShares;
exports.retryPromise = retryPromise;
exports.timeoutPromise = timeoutPromise;
Object.keys(core).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return core[k]; }
    });
});
