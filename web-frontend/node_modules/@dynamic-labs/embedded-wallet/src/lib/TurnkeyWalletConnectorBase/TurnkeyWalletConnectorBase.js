'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';
import { TurnkeyClient } from '@turnkey/http';
import { getTLD, PlatformService, DynamicError, DeferredPromise } from '@dynamic-labs/utils';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { turnkeyAuthenticatorRecoveryHandler } from '../AuthenticatorHandler/TurnkeyAuthenticatorRecoveryHandler.js';
import { TURNKEY_API_BASE_URL } from '../constants.js';
import { TurnkeyExportHandler } from '../ExportHandler/TurnkeyExportHandler.js';
import { base64UrlEncode } from '../utils/base64UrlEncode/base64UrlEncode.js';
import { generateRandomBuffer } from '../utils/generateRandomBuffer/generateRandomBuffer.js';
import { convertAttestationTransports } from '../utils/convertAttestationTransports/convertAttestationTransports.js';
import { logger } from '../utils/logger/logger.js';
import { TurnkeyPasskeyService } from '../utils/TurnkeyPasskeyService/TurnkeyPasskeyService.js';

class TurnkeyWalletConnectorBase extends WalletConnectorBase {
    constructor(nameAndKey, props) {
        super(props);
        // Public fields
        this.requiresNonDynamicEmailOtp = false;
        this.isEmbeddedWallet = true;
        this.removeSessionKeys = () => __awaiter(this, void 0, void 0, function* () {
            TurnkeyWalletConnectorBase.sessionKeys = undefined;
            TurnkeyWalletConnectorBase.apiKeyStamper = undefined;
            TurnkeyExportHandler.apiKeyStamper = undefined;
        });
        this.stampCreateWalletAccountRequest = (_a) => __awaiter(this, [_a], void 0, function* ({ request, }) {
            yield this.createOrRestoreSession();
            const turnkeyClient = yield this.getTurnkeyClient();
            return turnkeyClient.stampCreateWalletAccounts(request);
        });
        this.stampDeleteSubOrganizationRequest = (_b) => __awaiter(this, [_b], void 0, function* ({ request, }) {
            yield this.createOrRestoreSession();
            const turnkeyClient = yield this.getTurnkeyClient();
            return turnkeyClient.stampDeleteSubOrganization(request);
        });
        if (!props.appName) {
            throw new Error('appName not set');
        }
        this.name = nameAndKey.name;
        this.overrideKey = nameAndKey.key;
        this.appName = props.appName;
        this.__authenticatorMethodHandler = turnkeyAuthenticatorRecoveryHandler;
    }
    getWebAuthnAttestation() {
        return __awaiter(this, void 0, void 0, function* () {
            const challenge = generateRandomBuffer();
            const authenticatorUserId = generateRandomBuffer();
            const { email, passkeyIdentifier } = this;
            if (!email && !passkeyIdentifier) {
                throw new Error('Email or passkeyIdentifier must be set to register a webauthn credential.');
            }
            const displayName = email || `${this.appName} - ${passkeyIdentifier}`;
            const webAuthnCreateParams = {
                publicKey: {
                    authenticatorSelection: {
                        authenticatorAttachment: undefined,
                        requireResidentKey: false,
                        residentKey: 'preferred',
                        userVerification: 'discouraged',
                    },
                    challenge,
                    pubKeyCredParams: [
                        {
                            alg: -7,
                            type: 'public-key',
                        },
                    ],
                    rp: {
                        id: getTLD(),
                        name: this.appName,
                    },
                    user: {
                        displayName,
                        id: authenticatorUserId,
                        name: email || `${this.appName} - ${passkeyIdentifier}`,
                    },
                },
            };
            let attestation;
            try {
                attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
            }
            catch (error) {
                logger.warn(`Unable to register webauthn credential on the current page's TLD ${getTLD()}. Falling back to using hostname. ${PlatformService.getHostname()}`, error);
                // Create the passkey on the hostname instead.
                webAuthnCreateParams.publicKey.rp.id = PlatformService.getHostname();
                attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
            }
            return {
                attestation: {
                    attestationObject: attestation.attestationObject,
                    clientDataJson: attestation.clientDataJson,
                    credentialId: attestation.credentialId,
                    transports: convertAttestationTransports(attestation.transports),
                },
                challenge: base64UrlEncode(challenge),
                displayName,
            };
        });
    }
    getAuthenticatorHandler() {
        return this.__authenticatorMethodHandler;
    }
    getExportHandler() {
        // Create handler if it doesn't exist, reuse if it does
        if (!TurnkeyWalletConnectorBase.__exportHandler) {
            TurnkeyWalletConnectorBase.__exportHandler = new TurnkeyExportHandler();
        }
        return TurnkeyWalletConnectorBase.__exportHandler;
    }
    // Public methods
    get email() {
        return this._email;
    }
    setEmail(email) {
        this._email = email;
    }
    get phone() {
        return this._phone;
    }
    setPhone(phone) {
        this._phone = phone;
    }
    get passkeyIdentifier() {
        return this._passkeyIdentifier;
    }
    setPasskeyIdentifier(passkeyIdentifier) {
        this._passkeyIdentifier = passkeyIdentifier;
    }
    clearEmail() {
        this._email = null;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const verifiedCredentials = this.verifiedCredentials || [];
            const addresses = verifiedCredentials
                .map((vc) => vc === null || vc === void 0 ? void 0 : vc.address)
                .filter((a) => typeof a === 'string');
            return addresses;
        });
    }
    get turnkeyAddress() {
        var _a;
        const { address } = (_a = this.verifiedCredential) !== null && _a !== void 0 ? _a : {};
        return address;
    }
    get walletProperties() {
        const { walletProperties } = this.verifiedCredential || {};
        return walletProperties;
    }
    // Private methods
    set verifiedCredentials(verifiedCredentials) {
        this._verifiedCredentials = verifiedCredentials;
    }
    get verifiedCredentials() {
        return this._verifiedCredentials;
    }
    set verifiedCredential(verifiedCredential) {
        this._verifiedCredential = verifiedCredential;
    }
    get verifiedCredential() {
        return this._verifiedCredential;
    }
    setSessionKeyFetcher(func) {
        this.createOrRestoreSessionFetcherFunction = func;
    }
    setSessionKeyRemoveFunction(func) {
        this.removeSessionKeysFunction = func;
    }
    createOrRestoreSession() {
        return __awaiter(this, arguments, void 0, function* ({ ignoreRestore, } = {}) {
            var _a, _b, _c;
            if (!this.isSessionKeyCompatible() ||
                TurnkeyWalletConnectorBase.isLoadingSession) {
                return;
            }
            if (!this.createOrRestoreSessionFetcherFunction) {
                throw new DynamicError('Cannot register session key to init provider');
            }
            const { sessionKeys } = TurnkeyWalletConnectorBase;
            if (sessionKeys === null || sessionKeys === void 0 ? void 0 : sessionKeys.publicKey) {
                const isExpired = new Date() >= new Date(sessionKeys.expirationDate);
                if (!isExpired)
                    return sessionKeys.publicKey;
            }
            try {
                TurnkeyWalletConnectorBase.isLoadingSession = true;
                this.isLoadingSessionDeferredPromise = new DeferredPromise();
                if (!((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.id)) {
                    throw new DynamicError('No wallet ID found');
                }
                const sessionKeys = yield this.createOrRestoreSessionFetcherFunction({
                    ignoreRestore,
                    walletId: (_b = this.verifiedCredential) === null || _b === void 0 ? void 0 : _b.id,
                });
                TurnkeyWalletConnectorBase.sessionKeys = sessionKeys;
                TurnkeyWalletConnectorBase.apiKeyStamper = new ApiKeyStamper({
                    apiPrivateKey: sessionKeys.privateKey,
                    apiPublicKey: sessionKeys.publicKey,
                });
                TurnkeyExportHandler.apiKeyStamper =
                    TurnkeyWalletConnectorBase.apiKeyStamper;
                logger.metaData.set('sessionApiPublicKey', sessionKeys.publicKey);
                return sessionKeys.publicKey;
            }
            catch (error) {
                logger.error(error);
                throw new DynamicError('Failed to create or restore session');
            }
            finally {
                TurnkeyWalletConnectorBase.isLoadingSession = false;
                (_c = this.isLoadingSessionDeferredPromise) === null || _c === void 0 ? void 0 : _c.resolve();
            }
        });
    }
    isSessionKeyCompatible() {
        var _a;
        const walletProperties = (_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.walletProperties;
        const isSessionKeyCompatible = walletProperties === null || walletProperties === void 0 ? void 0 : walletProperties.isSessionKeyCompatible;
        return Boolean(isSessionKeyCompatible);
    }
    isSessionActive() {
        return __awaiter(this, void 0, void 0, function* () {
            const hasWallet = yield this.getAddress();
            return Boolean(hasWallet &&
                TurnkeyWalletConnectorBase.sessionKeys &&
                TurnkeyWalletConnectorBase.apiKeyStamper);
        });
    }
    get sessionKeys() {
        return TurnkeyWalletConnectorBase.sessionKeys;
    }
    getTurnkeyClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (TurnkeyWalletConnectorBase.isLoadingSession) {
                yield ((_a = this.isLoadingSessionDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            }
            let rpId = getTLD();
            if (!rpId) {
                rpId = PlatformService.getHostname();
            }
            const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
                rpId,
            });
            const apiKeyStamper = TurnkeyWalletConnectorBase === null || TurnkeyWalletConnectorBase === void 0 ? void 0 : TurnkeyWalletConnectorBase.apiKeyStamper;
            const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
            this.__turnkeyClient =
                (_b = this.getAuthenticatorHandler().client) !== null && _b !== void 0 ? _b : new TurnkeyClient({
                    baseUrl: TURNKEY_API_BASE_URL,
                }, stamper);
            return this.__turnkeyClient;
        });
    }
    setLoggerMetadata() {
        var _a, _b, _c;
        logger.metaData.set('turnkeySubOrganizationId', (_b = (_a = this._verifiedCredential) === null || _a === void 0 ? void 0 : _a.walletProperties) === null || _b === void 0 ? void 0 : _b.turnkeySubOrganizationId);
        logger.metaData.set('walletId', (_c = this._verifiedCredential) === null || _c === void 0 ? void 0 : _c.id);
        let authMethod = 'Unknown';
        if (this.isSessionKeyCompatible()) {
            authMethod = 'SessionKeys';
        }
        else if (this.__authenticatorMethodHandler.recoveryType === 'passkey') {
            authMethod = 'Passkey';
        }
        else if (this.__authenticatorMethodHandler.recoveryType === 'email') {
            authMethod = 'EmailAuth';
        }
        logger.metaData.set('authMethod', authMethod);
    }
}
TurnkeyWalletConnectorBase.isLoadingSession = false;

export { TurnkeyWalletConnectorBase };
