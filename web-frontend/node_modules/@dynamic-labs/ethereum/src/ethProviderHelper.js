'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { createWalletClient, custom, getAddress } from 'viem';
import { chainsMap, normalizeRpcError } from '@dynamic-labs/ethereum-core';
import { getProvidersFromWindow, Eip6963ProviderSingleton } from '@dynamic-labs/utils';
import { findWalletBookWallet } from '@dynamic-labs/wallet-book';
import { ProviderLookup, logger, eventListenerHandlers } from '@dynamic-labs/wallet-connector-core';

class EthProviderHelper {
    constructor(connector) {
        this.walletBookWallet = findWalletBookWallet(connector.walletBook, connector.key);
        this.connector = connector;
    }
    getInstalledProvider() {
        const eip6963Provider = this.getEip6963Provider();
        if (eip6963Provider) {
            return eip6963Provider;
        }
        const injectedProvider = this.getInjectedProvider();
        return injectedProvider;
    }
    getInjectedProvider() {
        const config = this.getInjectedConfig();
        if (!config ||
            !config.extensionLocators ||
            !config.extensionLocators.length)
            return undefined;
        const provider = this.installedProviderLookup(config.extensionLocators);
        return provider;
    }
    getEip6963Provider() {
        const { rdns } = this.connector.metadata;
        if (!rdns) {
            return undefined;
        }
        return this.eip6963ProviderLookup(rdns);
    }
    getInjectedConfig() {
        var _a;
        const injectedConfig = (_a = this.walletBookWallet) === null || _a === void 0 ? void 0 : _a.injectedConfig;
        return injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.find((c) => c.chain === 'evm');
    }
    installedProviders() {
        const config = this.getInjectedConfig();
        if (!config)
            return [];
        const providers = [];
        if (config.windowLocations) {
            for (const windowLocation of config.windowLocations) {
                const foundProviders = getProvidersFromWindow(windowLocation);
                if (foundProviders && foundProviders.length)
                    providers.push(...foundProviders);
            }
        }
        if (window.ethereum) {
            if (!window.ethereum.providers || !window.ethereum.providers.length) {
                providers.push(window.ethereum);
            }
            else {
                window.ethereum.providers.forEach((p) => providers.push(p));
            }
        }
        return providers;
    }
    installedProviderLookup(extensionLocators) {
        const allInstalledProviders = this.installedProviders();
        return ProviderLookup(allInstalledProviders, extensionLocators);
    }
    eip6963ProviderLookup(rdns) {
        var _a;
        const { providers } = Eip6963ProviderSingleton.get();
        return (_a = providers.find((provider) => { var _a; return ((_a = provider === null || provider === void 0 ? void 0 : provider.info) === null || _a === void 0 ? void 0 : _a.rdns) === rdns; })) === null || _a === void 0 ? void 0 : _a.provider;
    }
    isInstalledHelper() {
        return this.findProvider() !== undefined;
    }
    findProvider() {
        const provider = this.connector.findProvider();
        return provider;
    }
    findWalletClient(chainId) {
        const provider = this.findProvider();
        if (!provider) {
            return undefined;
        }
        return createWalletClient({
            account: this.connector.getActiveAccount(),
            chain: chainId ? chainsMap[chainId] : this.connector.getActiveChain(),
            transport: custom({
                request: (args) => provider.request(args).catch(normalizeRpcError),
            }, this.connector.providersConfig.httpTransportConfig),
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const client = this.findWalletClient();
            if (!client) {
                return Promise.resolve(undefined);
            }
            return this.getAddressWithProvider(client);
        });
    }
    getAddressWithProvider(client) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const [lowercaseAddress] = yield client.requestAddresses();
                const publicAddress = getAddress(lowercaseAddress);
                this.connector.setActiveAccount(publicAddress);
                return publicAddress;
            }
            catch (err) {
                logger.error(err);
                return Promise.reject(err);
            }
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletAddress = yield this.getAddress();
            if (!walletAddress) {
                return Promise.resolve(undefined);
            }
            const client = this.findWalletClient();
            if (!client) {
                return Promise.resolve(undefined);
            }
            const signedMessage = yield client.signMessage({
                account: walletAddress,
                message: messageToSign,
            });
            return signedMessage;
        });
    }
    _setupEventListeners(walletConnector) {
        const web3Provider = this.findProvider();
        if (!web3Provider) {
            logger.warn('Provider not found', {
                connector: walletConnector,
            });
            return {
                tearDownEventListeners: () => { },
            };
        }
        if (!web3Provider.on) {
            logger.warn('Provider does not support event listeners', {
                connector: walletConnector,
                provider: web3Provider,
            });
            return {
                tearDownEventListeners: () => { },
            };
        }
        const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(walletConnector);
        web3Provider.on('accountsChanged', handleAccountChange);
        web3Provider.on('chainChanged', handleChainChange);
        web3Provider.on('disconnect', handleDisconnect);
        const tearDownEventListeners = () => {
            const web3Provider = this.findProvider();
            if (!web3Provider) {
                return;
            }
            if (handleAccountChange) {
                web3Provider.removeListener('accountsChanged', handleAccountChange);
            }
            if (handleChainChange) {
                web3Provider.removeListener('chainChanged', handleChainChange);
            }
            if (handleDisconnect) {
                web3Provider.removeListener('disconnect', handleDisconnect);
            }
        };
        return {
            tearDownEventListeners,
        };
    }
}

export { EthProviderHelper };
