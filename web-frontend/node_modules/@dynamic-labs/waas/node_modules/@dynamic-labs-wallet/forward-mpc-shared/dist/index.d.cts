import * as fp_ts_lib_Either from 'fp-ts/lib/Either';
import * as io_ts from 'io-ts';
import { TypeOf, Type } from 'io-ts';
import { SigningAlgorithm } from '@dynamic-labs-wallet/core';
import { either } from 'fp-ts';

/**
 * Base structure for all WebSocket messages
 */
interface BaseWebSocketMessage {
    type: string;
    version: number;
}
/**
 * WebSocket error types
 */
declare enum WebSocketErrorType {
    INVALID_MESSAGE = "INVALID_MESSAGE",
    HANDLER_NOT_FOUND = "HANDLER_NOT_FOUND",
    HANDLER_ERROR = "HANDLER_ERROR",
    CONNECTION_ERROR = "CONNECTION_ERROR",
    VALIDATION_ERROR = "VALIDATION_ERROR"
}
/**
 * Structured WebSocket error
 */
interface WebSocketError {
    type: WebSocketErrorType;
    message: string;
    details?: unknown;
}
/**
 * Standard error response format
 */
interface ErrorResponse extends BaseWebSocketMessage {
    type: 'error';
    error: WebSocketError;
}
/**
 * WebSocket connection context (client-side version without ws instance)
 */
interface WebSocketConnectionInfo {
    id: string;
    connectedAt: Date;
    lastActivity: Date;
    metadata?: Record<string, unknown>;
}

/**
 * Base interface for all messages
 */
interface IMessage<TRuntime = any, TWire = any> {
    readonly type: string;
    readonly version: number;
    /**
     * Encode this message to wire format for transmission
     */
    encode(): TWire;
    /**
     * Get the runtime data of this message
     */
    getData(): TRuntime;
}
/**
 * Abstract base class for all messages
 */
declare abstract class BaseMessage<TRuntime = any, TWire = any> implements IMessage<TRuntime, TWire> {
    readonly data: TRuntime;
    abstract readonly type: string;
    abstract readonly version: number;
    protected constructor(data: TRuntime);
    abstract encode(): TWire;
    getData(): TRuntime;
}

/**
 * Connection Acknowledgment Response Runtime Data
 */
interface ConnectionAckResponseData {
    status: 'acknowledged';
    timestamp: string;
}
/**
 * Connection Acknowledgment Response Wire Format
 */
interface ConnectionAckResponseWire {
    type: 'connection_ack_response';
    version: 1;
    status: 'acknowledged';
    timestamp: string;
}
/**
 * Connection Acknowledgment Response Schema (built using Ultra-DRY utilities)
 */
declare const ConnectionAckResponseSchema: io_ts.Type<any, any, unknown>;
type ConnectionAckResponse = TypeOf<typeof ConnectionAckResponseSchema>;
/**
 * Connection Acknowledgment V1 Response Message Class (Ultra-DRY implementation)
 */
declare const ConnectionAckV1ResponseMessage: {
    new (data: ConnectionAckResponseData): {
        readonly type: "connection_ack_response";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckResponseData;
        getData(): ConnectionAckResponseData;
    };
    readonly MESSAGE_TYPE: "connection_ack_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "connection_ack_response";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckResponseData;
        getData(): ConnectionAckResponseData;
    }>;
};

/**
 * Connection Acknowledgment Request Runtime Data
 */
interface ConnectionAckRequestData {
    connectionId?: string;
}
/**
 * Connection Acknowledgment Request Wire Format
 */
interface ConnectionAckRequestWire {
    type: 'connection_ack';
    version: 1;
    connectionId?: string;
}
/**
 * Connection Acknowledgment Request Schema (built using Ultra-DRY utilities)
 */
declare const ConnectionAckRequestSchema: io_ts.Type<any, any, unknown>;
type ConnectionAckRequest = TypeOf<typeof ConnectionAckRequestSchema>;
/**
 * Connection Acknowledgment V1 Request Message Class (Ultra-DRY implementation)
 */
declare const ConnectionAckV1RequestMessage: {
    new (data: ConnectionAckRequestData): {
        readonly type: "connection_ack";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckRequestData;
        getData(): ConnectionAckRequestData;
    };
    readonly MESSAGE_TYPE: "connection_ack";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "connection_ack";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckRequestData;
        getData(): ConnectionAckRequestData;
    }>;
};

/**
 * Sign Message Response Runtime Data
 */
interface SignMessageResponseData {
    signature?: Uint8Array;
    error?: WebSocketError;
}
/**
 * Sign Message Response Wire Format
 */
interface SignMessageResponseWire {
    type: 'signMessage_response';
    version: 1;
    signature?: string;
    error?: WebSocketError;
}
/**
 * Sign Message Response Schema (built using Ultra-DRY utilities)
 * Schema expects wire format types (string for signature)
 */
declare const SignMessageResponseSchema: io_ts.Type<any, any, unknown>;
type SignMessageResponse = TypeOf<typeof SignMessageResponseSchema>;
/**
 * Sign Message V1 Response Message Class (Ultra-DRY implementation)
 */
declare const SignMessageV1ResponseMessage: {
    new (data: SignMessageResponseData): {
        readonly type: "signMessage_response";
        readonly version: 1;
        encode(): SignMessageResponseWire;
        readonly data: SignMessageResponseData;
        getData(): SignMessageResponseData;
    };
    readonly MESSAGE_TYPE: "signMessage_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "signMessage_response";
        readonly version: 1;
        encode(): SignMessageResponseWire;
        readonly data: SignMessageResponseData;
        getData(): SignMessageResponseData;
    }>;
};

/**
 * Base secret share data (what gets encrypted)
 */
interface SecretShareData {
    secretShare: string;
    signingAlgorithm: string;
    timestamp: number;
    nonce: string;
}
/**
 * Decrypted secret share with reconstructed keygen result
 */
interface DecryptedSecretShare {
    keygenResult: any;
    signingAlgorithm: string;
    timestamp: number;
    nonce: string;
}
/**
 * Base interface for signing algorithm implementations
 */
interface ISigningAlgorithm {
    readonly algorithmName: string;
    readonly version: number;
    readonly schema: Type<any>;
    createKeygenResultFromSecretShare(secretShare: string): any;
    createSignRequest(keygenResult: any, params: any): any;
    processSignResult(result: any): Uint8Array;
}
/**
 * Base signing algorithm class
 */
declare abstract class BaseSigningAlgorithm implements ISigningAlgorithm {
    abstract readonly algorithmName: string;
    abstract readonly version: number;
    abstract readonly schema: Type<any>;
    abstract createKeygenResultFromSecretShare(secretShare: string): any;
    abstract createSignRequest(keygenResult: any, params: any): any;
    abstract processSignResult(result: any): Uint8Array;
}

interface Ed25519SignMessageSchema {
    signingAlgo: 'ed25519';
    derivationPath?: Uint32Array;
}
declare class Ed25519SigningAlgorithm extends BaseSigningAlgorithm {
    readonly algorithmName: "ed25519";
    readonly version = 1;
    readonly schema: io_ts.IntersectionC<[io_ts.TypeC<{
        signingAlgo: io_ts.LiteralC<"ed25519">;
    }>, io_ts.PartialC<{
        derivationPath: io_ts.Type<Uint32Array<ArrayBufferLike>, string, unknown>;
    }>]>;
    createKeygenResultFromSecretShare(secretShare: string): any;
    createSignRequest(keygenResult: any, params: any): any;
    processSignResult(_result: any): Uint8Array;
}

interface BIP340SignMessageSchema {
    signingAlgo: 'bip340';
    derivationPath?: Uint32Array;
    tweak?: Uint8Array;
}
declare class BIP340SigningAlgorithm extends BaseSigningAlgorithm {
    readonly algorithmName: "bip340";
    readonly version = 1;
    readonly schema: io_ts.IntersectionC<[io_ts.TypeC<{
        signingAlgo: io_ts.LiteralC<"bip340">;
    }>, io_ts.PartialC<{
        derivationPath: io_ts.Type<Uint32Array<ArrayBufferLike>, string, unknown>;
        tweak: io_ts.Type<Uint8Array<ArrayBufferLike>, string, unknown>;
    }>]>;
    createKeygenResultFromSecretShare(secretShare: string): any;
    createSignRequest(keygenResult: any, params: any): any;
    processSignResult(_result: any): Uint8Array;
}

interface EcdsaSignMessageSchema {
    signingAlgo: 'ecdsa';
    hashAlgo: 'sha256' | 'sha256d' | 'keccak256';
    derivationPath?: Uint32Array;
}
declare class EcdsaSigningAlgorithm extends BaseSigningAlgorithm {
    readonly algorithmName: "ecdsa";
    readonly version = 1;
    readonly schema: io_ts.IntersectionC<[io_ts.TypeC<{
        signingAlgo: io_ts.LiteralC<"ecdsa">;
    }>, io_ts.PartialC<{
        hashAlgo: io_ts.UnionC<[io_ts.LiteralC<"sha256">, io_ts.LiteralC<"sha256d">, io_ts.LiteralC<"keccak256">]>;
        derivationPath: io_ts.Type<Uint32Array<ArrayBufferLike>, string, unknown>;
    }>]>;
    createKeygenResultFromSecretShare(secretShare: string): any;
    createSignRequest(keygenResult: any, params: any): any;
    processSignResult(_result: any): Uint8Array;
}

/**
 * üéØ SINGLE SOURCE OF TRUTH - Add new algorithms here and everything else is automatic!
 * This is the ONLY place you need to add new signing algorithms
 */
declare const SIGNING_ALGORITHM_CLASSES: {
    readonly ed25519: typeof Ed25519SigningAlgorithm;
    readonly bip340: typeof BIP340SigningAlgorithm;
    readonly ecdsa: typeof EcdsaSigningAlgorithm;
};
/**
 * üìù Explicit union type of all signing algorithm schemas
 * (Only other place you need to add new algorithms)
 */
type AllSigningAlgorithmSchemas = Ed25519SignMessageSchema | BIP340SignMessageSchema | EcdsaSignMessageSchema;
/**
 * Derive signing algorithm name type from classes
 */
type SigningAlgorithmName = keyof typeof SIGNING_ALGORITHM_CLASSES;
/**
 * Derive runtime array of algorithm names from classes
 */
declare const ALL_SIGNING_ALGORITHM_NAMES: SigningAlgorithmName[];
/**
 * Create algorithm instances (derived from classes)
 */
declare const SIGNING_ALGORITHM_INSTANCES: Record<SigningAlgorithmName, ISigningAlgorithm>;
/**
 * Create union schema (derived from instances)
 */
declare const ALL_SIGNING_ALGORITHM_SCHEMA: Type<AllSigningAlgorithmSchemas>;
/**
 * Helper type to extract algorithm-specific schema
 */
type SigningAlgorithmSchemaFor<T extends AllSigningAlgorithmSchemas['signingAlgo']> = Extract<AllSigningAlgorithmSchemas, {
    signingAlgo: T;
}>;
/**
 * Utility to check if a string is a valid signing algorithm name
 */
declare function isValidSigningAlgorithm(name: string): name is SigningAlgorithmName;
/**
 * Create keygen result from secret share using algorithm-specific logic
 */
declare function createKeygenResultFromSecretShare(algorithmName: SigningAlgorithmName, secretShare: string): any;

/**
 * Algorithm configurations for complex properties
 * Maps Dynamic SDK enum values to our internal algorithm names
 */
declare const ALGORITHMS: {
    readonly ECDSA: {
        readonly name: "ecdsa";
        readonly dynamicEnum: SigningAlgorithm.ECDSA;
        readonly className: "Ecdsa";
        readonly requiresHashAlgo: true;
        readonly supportsDerivationPath: true;
        readonly supportsTweak: false;
        readonly supportedHashAlgos: readonly ["sha256", "sha256d", "keccak256"];
    };
    readonly ED25519: {
        readonly name: "ed25519";
        readonly dynamicEnum: SigningAlgorithm.ED25519;
        readonly className: "Ed25519";
        readonly requiresHashAlgo: false;
        readonly supportsDerivationPath: true;
        readonly supportsTweak: false;
        readonly supportedHashAlgos: readonly [];
    };
    readonly BIP340: {
        readonly name: "bip340";
        readonly dynamicEnum: SigningAlgorithm.BIP340;
        readonly className: "BIP340";
        readonly requiresHashAlgo: false;
        readonly supportsDerivationPath: true;
        readonly supportsTweak: true;
        readonly supportedHashAlgos: readonly [];
    };
};
/**
 * Type definitions - use Dynamic SDK's SigningAlgorithm enum
 */
type HashAlgorithm = 'sha256' | 'sha256d' | 'keccak256';
/**
 * Helper function to convert our internal algorithm names to Dynamic SDK enum values
 */
declare function toDynamicSigningAlgorithm(algorithmName: SigningAlgorithmName): SigningAlgorithm;
/**
 * Helper function to convert Dynamic SDK enum values to our internal algorithm names
 */
declare function fromDynamicSigningAlgorithm(dynamicAlgorithm: SigningAlgorithm): SigningAlgorithmName;
/**
 * Union schema derived from algorithm instances (no more manual schema generation!)
 */
declare const SignatureAlgoSchema: io_ts.Type<AllSigningAlgorithmSchemas, AllSigningAlgorithmSchemas, unknown>;

/**
 * Encrypted keyshare structure for secure transmission
 * Contains HKDF salt and AES-256-GCM encrypted payload
 */
declare const EncryptedKeyshareCodec: io_ts.TypeC<{
    salt: io_ts.Type<Uint8Array<ArrayBufferLike>, string, unknown>;
    encryptedPayload: io_ts.Type<Uint8Array<ArrayBufferLike>, string, unknown>;
}>;
type EncryptedKeyshare = TypeOf<typeof EncryptedKeyshareCodec>;

/**
 * Sign Message Request Runtime Data
 */
interface SignMessageRequestData {
    relayDomain: string;
    signingAlgo: SigningAlgorithm;
    hashAlgo?: HashAlgorithm;
    derivationPath?: Uint32Array;
    tweak?: Uint8Array;
    keyshare: EncryptedKeyshare;
    message: Uint8Array | string;
    roomUuid: string;
}
/**
 * Sign Message Request Wire Format
 */
interface SignMessageRequestWire {
    type: 'signMessage';
    version: 1;
    relayDomain: string;
    signingAlgo: SigningAlgorithm;
    hashAlgo?: HashAlgorithm;
    derivationPath?: string;
    tweak?: string;
    keyshare: {
        salt: string;
        encryptedPayload: string;
    };
    message: string;
    roomUuid: string;
}
/**
 * Sign Message Request Schema - uses codecs that handle both formats automatically
 */
declare const SignMessageRequestSchema: io_ts.Type<any, any, unknown>;
type SignMessageRequest = TypeOf<typeof SignMessageRequestSchema>;
/**
 * Sign Message V1 Request Message Class - Clean implementation using createComplexEncoder
 */
declare const SignMessageV1RequestMessage: {
    new (data: SignMessageRequestData): {
        readonly type: "signMessage";
        readonly version: 1;
        encode(): unknown;
        readonly data: SignMessageRequestData;
        getData(): SignMessageRequestData;
    };
    readonly MESSAGE_TYPE: "signMessage";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "signMessage";
        readonly version: 1;
        encode(): unknown;
        readonly data: SignMessageRequestData;
        getData(): SignMessageRequestData;
    }>;
};

/**
 * Handshake Response Runtime Data
 */
interface HandshakeResponseData {
    encapsulatedSharedSecret: string;
    attestationDoc: string;
    connectionId: string;
}
/**
 * Handshake Response Wire Format
 */
interface HandshakeResponseWire {
    type: 'handshake_response';
    version: 1;
    encapsulatedSharedSecret: string;
    attestationDoc: string;
    connectionId: string;
}
/**
 * Handshake Response Schema (built using Ultra-DRY utilities)
 */
declare const HandshakeResponseSchema: io_ts.Type<any, any, unknown>;
type HandshakeResponse = TypeOf<typeof HandshakeResponseSchema>;
/**
 * Handshake V1 Response Message Class (Ultra-DRY implementation)
 */
declare const HandshakeV1ResponseMessage: {
    new (data: HandshakeResponseData): {
        readonly type: "handshake_response";
        readonly version: 1;
        encode(): any;
        readonly data: HandshakeResponseData;
        getData(): HandshakeResponseData;
    };
    readonly MESSAGE_TYPE: "handshake_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "handshake_response";
        readonly version: 1;
        encode(): any;
        readonly data: HandshakeResponseData;
        getData(): HandshakeResponseData;
    }>;
};

/**
 * Handshake Request Runtime Data
 */
interface HandshakeRequestData {
    challenge: Uint8Array;
    nonce: Uint8Array;
}
/**
 * Handshake Request Wire Format
 */
interface HandshakeRequestWire {
    type: 'handshake';
    version: 1;
    challenge: string;
    nonce: string;
}
/**
 * Handshake Request Schema (built using Ultra-DRY utilities)
 */
declare const HandshakeRequestSchema: io_ts.Type<any, any, unknown>;
type HandshakeRequest = TypeOf<typeof HandshakeRequestSchema>;
/**
 * Handshake V1 Request Message Class (Ultra-DRY implementation)
 */
declare const HandshakeV1RequestMessage: {
    new (data: HandshakeRequestData): {
        readonly type: "handshake";
        readonly version: 1;
        encode(): HandshakeRequestWire;
        readonly data: HandshakeRequestData;
        getData(): HandshakeRequestData;
    };
    readonly MESSAGE_TYPE: "handshake";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "handshake";
        readonly version: 1;
        encode(): HandshakeRequestWire;
        readonly data: HandshakeRequestData;
        getData(): HandshakeRequestData;
    }>;
};

/**
 * Ultra-DRY Message Registry - everything is derived, no registration needed
 */
declare class MessageRegistry {
    private static instance;
    private constructor();
    static getInstance(): MessageRegistry;
    /**
     * Get a message class by type and version (derived from single source)
     */
    getMessageClass(type: string, version: number): {
        new (data: HandshakeRequestData): {
            readonly type: "handshake";
            readonly version: 1;
            encode(): HandshakeRequestWire;
            readonly data: HandshakeRequestData;
            getData(): HandshakeRequestData;
        };
        readonly MESSAGE_TYPE: "handshake";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "handshake";
            readonly version: 1;
            encode(): HandshakeRequestWire;
            readonly data: HandshakeRequestData;
            getData(): HandshakeRequestData;
        }>;
    } | {
        new (data: HandshakeResponseData): {
            readonly type: "handshake_response";
            readonly version: 1;
            encode(): any;
            readonly data: HandshakeResponseData;
            getData(): HandshakeResponseData;
        };
        readonly MESSAGE_TYPE: "handshake_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "handshake_response";
            readonly version: 1;
            encode(): any;
            readonly data: HandshakeResponseData;
            getData(): HandshakeResponseData;
        }>;
    } | {
        new (data: SignMessageRequestData): {
            readonly type: "signMessage";
            readonly version: 1;
            encode(): unknown;
            readonly data: SignMessageRequestData;
            getData(): SignMessageRequestData;
        };
        readonly MESSAGE_TYPE: "signMessage";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "signMessage";
            readonly version: 1;
            encode(): unknown;
            readonly data: SignMessageRequestData;
            getData(): SignMessageRequestData;
        }>;
    } | {
        new (data: SignMessageResponseData): {
            readonly type: "signMessage_response";
            readonly version: 1;
            encode(): SignMessageResponseWire;
            readonly data: SignMessageResponseData;
            getData(): SignMessageResponseData;
        };
        readonly MESSAGE_TYPE: "signMessage_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "signMessage_response";
            readonly version: 1;
            encode(): SignMessageResponseWire;
            readonly data: SignMessageResponseData;
            getData(): SignMessageResponseData;
        }>;
    } | {
        new (data: ConnectionAckRequestData): {
            readonly type: "connection_ack";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckRequestData;
            getData(): ConnectionAckRequestData;
        };
        readonly MESSAGE_TYPE: "connection_ack";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "connection_ack";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckRequestData;
            getData(): ConnectionAckRequestData;
        }>;
    } | {
        new (data: ConnectionAckResponseData): {
            readonly type: "connection_ack_response";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckResponseData;
            getData(): ConnectionAckResponseData;
        };
        readonly MESSAGE_TYPE: "connection_ack_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): either.Either<io_ts.Errors, {
            readonly type: "connection_ack_response";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckResponseData;
            getData(): ConnectionAckResponseData;
        }>;
    } | undefined;
    /**
     * Create a message instance from wire data (using derived message classes)
     */
    decode(wireData: any): either.Either<string, IMessage>;
    /**
     * Encode a message to wire format
     */
    encode(message: IMessage): any;
    /**
     * Get all registered message types (derived from single source)
     */
    getRegisteredTypes(): string[];
}
declare const messageRegistry: MessageRegistry;

/**
 * üéØ SINGLE SOURCE OF TRUTH - Add new messages here and everything else is automatic!
 * This is the ONLY place you need to add new message types
 */
declare const ALL_MESSAGE_CLASSES: {
    readonly 'handshake@1': {
        new (data: HandshakeRequestData): {
            readonly type: "handshake";
            readonly version: 1;
            encode(): HandshakeRequestWire;
            readonly data: HandshakeRequestData;
            getData(): HandshakeRequestData;
        };
        readonly MESSAGE_TYPE: "handshake";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "handshake";
            readonly version: 1;
            encode(): HandshakeRequestWire;
            readonly data: HandshakeRequestData;
            getData(): HandshakeRequestData;
        }>;
    };
    readonly 'handshake_response@1': {
        new (data: HandshakeResponseData): {
            readonly type: "handshake_response";
            readonly version: 1;
            encode(): any;
            readonly data: HandshakeResponseData;
            getData(): HandshakeResponseData;
        };
        readonly MESSAGE_TYPE: "handshake_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "handshake_response";
            readonly version: 1;
            encode(): any;
            readonly data: HandshakeResponseData;
            getData(): HandshakeResponseData;
        }>;
    };
    readonly 'signMessage@1': {
        new (data: SignMessageRequestData): {
            readonly type: "signMessage";
            readonly version: 1;
            encode(): unknown;
            readonly data: SignMessageRequestData;
            getData(): SignMessageRequestData;
        };
        readonly MESSAGE_TYPE: "signMessage";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "signMessage";
            readonly version: 1;
            encode(): unknown;
            readonly data: SignMessageRequestData;
            getData(): SignMessageRequestData;
        }>;
    };
    readonly 'signMessage_response@1': {
        new (data: SignMessageResponseData): {
            readonly type: "signMessage_response";
            readonly version: 1;
            encode(): SignMessageResponseWire;
            readonly data: SignMessageResponseData;
            getData(): SignMessageResponseData;
        };
        readonly MESSAGE_TYPE: "signMessage_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "signMessage_response";
            readonly version: 1;
            encode(): SignMessageResponseWire;
            readonly data: SignMessageResponseData;
            getData(): SignMessageResponseData;
        }>;
    };
    readonly 'connection_ack@1': {
        new (data: ConnectionAckRequestData): {
            readonly type: "connection_ack";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckRequestData;
            getData(): ConnectionAckRequestData;
        };
        readonly MESSAGE_TYPE: "connection_ack";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "connection_ack";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckRequestData;
            getData(): ConnectionAckRequestData;
        }>;
    };
    readonly 'connection_ack_response@1': {
        new (data: ConnectionAckResponseData): {
            readonly type: "connection_ack_response";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckResponseData;
            getData(): ConnectionAckResponseData;
        };
        readonly MESSAGE_TYPE: "connection_ack_response";
        readonly MESSAGE_VERSION: 1;
        readonly schema: io_ts.Type<any, any, unknown>;
        decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
            readonly type: "connection_ack_response";
            readonly version: 1;
            encode(): any;
            readonly data: ConnectionAckResponseData;
            getData(): ConnectionAckResponseData;
        }>;
    };
};
/**
 * Derive message type union from classes
 */
type AllMessageTypes = keyof typeof ALL_MESSAGE_CLASSES;
/**
 * Derive runtime array of message keys from classes
 */
declare const ALL_MESSAGE_KEYS: AllMessageTypes[];
/**
 * Get message class by type and version (derived from single source)
 */
declare function getMessageClass(type: string, version: number): {
    new (data: HandshakeRequestData): {
        readonly type: "handshake";
        readonly version: 1;
        encode(): HandshakeRequestWire;
        readonly data: HandshakeRequestData;
        getData(): HandshakeRequestData;
    };
    readonly MESSAGE_TYPE: "handshake";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "handshake";
        readonly version: 1;
        encode(): HandshakeRequestWire;
        readonly data: HandshakeRequestData;
        getData(): HandshakeRequestData;
    }>;
} | {
    new (data: HandshakeResponseData): {
        readonly type: "handshake_response";
        readonly version: 1;
        encode(): any;
        readonly data: HandshakeResponseData;
        getData(): HandshakeResponseData;
    };
    readonly MESSAGE_TYPE: "handshake_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "handshake_response";
        readonly version: 1;
        encode(): any;
        readonly data: HandshakeResponseData;
        getData(): HandshakeResponseData;
    }>;
} | {
    new (data: SignMessageRequestData): {
        readonly type: "signMessage";
        readonly version: 1;
        encode(): unknown;
        readonly data: SignMessageRequestData;
        getData(): SignMessageRequestData;
    };
    readonly MESSAGE_TYPE: "signMessage";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "signMessage";
        readonly version: 1;
        encode(): unknown;
        readonly data: SignMessageRequestData;
        getData(): SignMessageRequestData;
    }>;
} | {
    new (data: SignMessageResponseData): {
        readonly type: "signMessage_response";
        readonly version: 1;
        encode(): SignMessageResponseWire;
        readonly data: SignMessageResponseData;
        getData(): SignMessageResponseData;
    };
    readonly MESSAGE_TYPE: "signMessage_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "signMessage_response";
        readonly version: 1;
        encode(): SignMessageResponseWire;
        readonly data: SignMessageResponseData;
        getData(): SignMessageResponseData;
    }>;
} | {
    new (data: ConnectionAckRequestData): {
        readonly type: "connection_ack";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckRequestData;
        getData(): ConnectionAckRequestData;
    };
    readonly MESSAGE_TYPE: "connection_ack";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "connection_ack";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckRequestData;
        getData(): ConnectionAckRequestData;
    }>;
} | {
    new (data: ConnectionAckResponseData): {
        readonly type: "connection_ack_response";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckResponseData;
        getData(): ConnectionAckResponseData;
    };
    readonly MESSAGE_TYPE: "connection_ack_response";
    readonly MESSAGE_VERSION: 1;
    readonly schema: io_ts.Type<any, any, unknown>;
    decode(wireData: unknown): fp_ts_lib_Either.Either<io_ts.Errors, {
        readonly type: "connection_ack_response";
        readonly version: 1;
        encode(): any;
        readonly data: ConnectionAckResponseData;
        getData(): ConnectionAckResponseData;
    }>;
};
/**
 * Type-safe check if message type exists
 */
declare function isValidMessageType(type: string, version: number): boolean;
/**
 * Get all supported message types and versions
 */
declare function getAllSupportedMessages(): Array<{
    type: string;
    version: number;
}>;
/**
 * Helper to extract message type and version from key
 */
declare function parseMessageKey(key: AllMessageTypes): {
    type: string;
    version: number;
};

declare const Uint8ArrayCodec: Type<Uint8Array<ArrayBufferLike>, string, unknown>;

declare const Uint32ArrayCodec: Type<Uint32Array<ArrayBufferLike>, string, unknown>;

declare const generateMlKem768Keypair: () => {
    encapsulationKey: Uint8Array;
    decapsulationKey: Uint8Array;
};

declare const encapsulateMlKem768: (encapsulationKey: Uint8Array) => {
    cipherText: Uint8Array;
    sharedSecret: Uint8Array;
};

declare const decapsulateMlKem768: (decapsulationKey: Uint8Array, cipherText: Uint8Array) => Uint8Array;

declare const AES_256_GCM_KEY_SIZE = 32;
declare const AES_256_GCM_NONCE_SIZE = 12;
declare const AES_256_GCM_TAG_SIZE = 16;
declare const HKDF_SALT_SIZE = 32;
/**
 * Derive AES-256 key from ML-KEM shared secret using HKDF
 * Following NIST SP 800-56C recommendations
 */
declare function deriveAESKey(sharedSecret: Uint8Array, salt: Uint8Array, info: string): Uint8Array;
/**
 * Create standardized context info for HKDF
 */
declare function createKeyDerivationInfo(purpose: 'keyshare' | 'hmac', connectionId: string, version?: number): string;

/**
 * Encrypt keyshare using AES-256-GCM with ML-KEM derived key
 *
 * @param keyshare - The keyshare object from Dynamic Wallet SDK
 * @param sharedSecret - ML-KEM shared secret from handshake
 * @param connectionId - Unique connection identifier
 * @param signingAlgorithm - Algorithm name for context
 * @returns Encrypted keyshare with salt and encrypted payload
 */
declare function encryptKeyshare(keyshare: any, sharedSecret: Uint8Array, connectionId: string, signingAlgorithm: SigningAlgorithmName): Promise<EncryptedKeyshare>;

/**
 * Asserts that a value is defined (not null or undefined)
 * @throws Error if value is null or undefined
 */
declare function assertDefined<T>(value: T | null | undefined, message?: string): asserts value is T;
/**
 * Asserts that a value is not null
 * @throws Error if value is null
 */
declare function assertNotNull<T>(value: T | null, message?: string): asserts value is T;
/**
 * Returns a value if it is defined, otherwise throws an error
 * @throws Error if value is null or undefined
 */
declare function getDefined<T>(value: T | null | undefined, message?: string): T;

/**
 * Ultra-simple registry - everything is derived, no registration needed
 */
declare class SigningAlgorithmRegistry {
    /**
     * Get algorithm instance (derived from single source of truth)
     */
    get(name: SigningAlgorithmName): ISigningAlgorithm;
    /**
     * Type-safe check if algorithm exists
     */
    has(name: string): name is SigningAlgorithmName;
    /**
     * Get all algorithm names (derived from classes)
     */
    getAllNames(): SigningAlgorithmName[];
    /**
     * Get all algorithm instances (derived from classes)
     */
    getAllInstances(): Record<SigningAlgorithmName, ISigningAlgorithm>;
}
declare const signingAlgorithmRegistry: SigningAlgorithmRegistry;

export { AES_256_GCM_KEY_SIZE, AES_256_GCM_NONCE_SIZE, AES_256_GCM_TAG_SIZE, ALGORITHMS, ALL_MESSAGE_CLASSES, ALL_MESSAGE_KEYS, ALL_SIGNING_ALGORITHM_NAMES, ALL_SIGNING_ALGORITHM_SCHEMA, type AllMessageTypes, type AllSigningAlgorithmSchemas, BIP340SigningAlgorithm, BaseMessage, BaseSigningAlgorithm, type BaseWebSocketMessage, type ConnectionAckRequest, type ConnectionAckRequestData, ConnectionAckRequestSchema, type ConnectionAckRequestWire, type ConnectionAckResponse, type ConnectionAckResponseData, ConnectionAckResponseSchema, type ConnectionAckResponseWire, ConnectionAckV1RequestMessage, ConnectionAckV1ResponseMessage, type DecryptedSecretShare, EcdsaSigningAlgorithm, Ed25519SigningAlgorithm, type EncryptedKeyshare, EncryptedKeyshareCodec, type ErrorResponse, HKDF_SALT_SIZE, type HandshakeRequest, type HandshakeRequestData, HandshakeRequestSchema, type HandshakeRequestWire, type HandshakeResponse, type HandshakeResponseData, HandshakeResponseSchema, type HandshakeResponseWire, HandshakeV1RequestMessage, HandshakeV1ResponseMessage, type HashAlgorithm, type IMessage, type ISigningAlgorithm, MessageRegistry, SIGNING_ALGORITHM_CLASSES, SIGNING_ALGORITHM_INSTANCES, type SecretShareData, type SignMessageRequest, type SignMessageRequestData, SignMessageRequestSchema, type SignMessageRequestWire, type SignMessageResponse, type SignMessageResponseData, SignMessageResponseSchema, type SignMessageResponseWire, SignMessageV1RequestMessage, SignMessageV1ResponseMessage, SignatureAlgoSchema, type SigningAlgorithmName, type SigningAlgorithmSchemaFor, type AllSigningAlgorithmSchemas as SigningAlgorithmSchemas, Uint32ArrayCodec, Uint8ArrayCodec, type WebSocketConnectionInfo, type WebSocketError, WebSocketErrorType, assertDefined, assertNotNull, createKeyDerivationInfo, createKeygenResultFromSecretShare, decapsulateMlKem768, deriveAESKey, encapsulateMlKem768, encryptKeyshare, fromDynamicSigningAlgorithm, generateMlKem768Keypair, getAllSupportedMessages, getDefined, getMessageClass, isValidMessageType, isValidSigningAlgorithm, messageRegistry, parseMessageKey, signingAlgorithmRegistry, toDynamicSigningAlgorithm };
