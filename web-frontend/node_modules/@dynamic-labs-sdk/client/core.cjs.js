'use strict';

var assertPackageVersion = require('@dynamic-labs-sdk/assert-package-version');
var constants = require('./constants.cjs.js');
var getNetworkProviderFromNetworkId = require('./getNetworkProviderFromNetworkId.cjs.js');
var getWalletProviderByKey = require('./getWalletProviderByKey.cjs.js');
var getSignedSessionId = require('./getSignedSessionId.cjs.js');
var z = require('zod/mini');
var EventEmitter = require('eventemitter3');
var filterDuplicates = require('./filterDuplicates.cjs.js');
require('@dynamic-labs/sdk-api-core');
require('buffer');
require('./isMfaRequiredForAction.cjs.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var z__namespace = /*#__PURE__*/_interopNamespaceDefault(z);

class ClientsDoNotMatchError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'clients_do_not_match_error',
            docsUrl: null,
            name: 'ClientsDoNotMatchError',
            shortMessage: 'Clients do not match'
        });
    }
}

class MethodNotImplementedError extends constants.BaseError {
    constructor(methodName){
        super({
            cause: null,
            code: 'method_not_implemented_error',
            docsUrl: null,
            name: 'MethodNotImplementedError',
            shortMessage: `This method is not implemented: ${methodName}`
        });
    }
}

class MultipleClientsFoundError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'multiple_clients_found_error',
            docsUrl: null,
            name: 'MultipleClientsFoundError',
            shortMessage: 'Multiple Dynamic clients have been initialized. Please provide the intended client for this action explicitly'
        });
    }
}

/**
 * Registers an extension to the client.
 *
 * Other extensions can be aware of which extensions are present,
 * and allows creating dependencies between extensions.
 *
 * @param client - The client instance.
 * @param extensionKey - The key of the extension to register.
 * @returns The client instance.
 */ const registerExtension = ({ extensionKey }, client)=>{
    const core = constants.getCore(client);
    core.extensions.add(extensionKey);
};

const waitForProjectSettings = async (client)=>{
    const core = constants.getCore(client);
    const projectSettingsTracker = core.initTrack.getTracker(getNetworkProviderFromNetworkId.FETCH_PROJECT_SETTINGS_TRACKER_KEY);
    constants.assertDefined(projectSettingsTracker, 'Project settings tracker not found');
    await projectSettingsTracker.promise;
    constants.assertDefined(client.projectSettings, 'Project settings still not available after awaiting its tracker');
    return client.projectSettings;
};

const createBaseNetworkProvider = (chain, networkData)=>({
        blockExplorerUrls: networkData.blockExplorerUrls,
        chain,
        displayName: networkData.displayName,
        iconUrl: networkData.iconUrl,
        id: `${chain}-${networkData.networkId}`,
        nativeCurrency: networkData.nativeCurrency,
        networkId: networkData.networkId,
        rpcUrls: networkData.rpcUrls,
        testnet: networkData.testnet
    });

const networkRegistryStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema({
    key: 'lastKnownNetworkRegistry',
    schema: z__namespace.record(z__namespace.string(), z__namespace.string())
});

/**
 * Creates the registry that keeps tabs on which wallet provider is
 * connected to which network.
 *
 * Reminder that this will not be used for chains that have an internal way to
 * switch networks (ex EVM).
 */ const createLastKnownNetworkRegistry = (client)=>{
    const core = constants.getCore(client);
    const walletProviderKeyToNetworkId = new Map();
    const getNetworkId = async ({ walletProviderKey })=>{
        // Priorities:
        // 1. In memory
        // 2. Storage
        // 3. First available network for this wallet's chain
        if (walletProviderKeyToNetworkId.has(walletProviderKey)) {
            return {
                networkId: walletProviderKeyToNetworkId.get(walletProviderKey)
            };
        }
        const storageRecords = await core.storage.getItem(networkRegistryStorageKeySchema);
        if (storageRecords && storageRecords[walletProviderKey]) {
            const networkId = storageRecords[walletProviderKey];
            walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
            return {
                networkId
            };
        }
        const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
            walletProviderKey
        }, client);
        const networkProviders = getNetworkProviderFromNetworkId.getNetworkProviders(client);
        if (networkProviders.length === 0) {
            throw new getNetworkProviderFromNetworkId.NoNetworkProvidersError();
        }
        const defaultNetworkProvider = networkProviders.find((networkProvider)=>networkProvider.chain === walletProvider.chain);
        constants.assertDefined(defaultNetworkProvider, `No networks found for chain ${walletProvider.chain}`);
        walletProviderKeyToNetworkId.set(walletProviderKey, defaultNetworkProvider.networkId);
        // No need to set in storage, as we're just falling back to the default
        return {
            networkId: defaultNetworkProvider.networkId
        };
    };
    const setNetworkId = async ({ networkId, walletProviderKey })=>{
        walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
        await core.storage.setItem(networkRegistryStorageKeySchema, Object.fromEntries(walletProviderKeyToNetworkId.entries()));
    };
    return {
        getNetworkId,
        setNetworkId
    };
};

const getLastKnownNetworkRegistry = getWalletProviderByKey.createRuntimeServiceAccessKey('last-known-network-registry', (client)=>createLastKnownNetworkRegistry(client));

const formatWalletProviderGroupKey = (walletName)=>walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();

/* eslint-disable no-restricted-globals */ const getInjectedProviderFromWindow = (path)=>{
    if (typeof window === 'undefined') {
        return null;
    }
    // Traverse the path safely
    const target = path.split('.').reduce(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    (acc, key)=>acc == null ? null : acc[key], window);
    if (typeof target !== 'object' || target === null) {
        return null;
    }
    if (Array.isArray(target)) {
        return target.length > 0 ? target[0] : null;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const providersArray = target.providers;
    if (providersArray && Array.isArray(providersArray)) {
        return providersArray.length > 0 ? providersArray[0] : null;
    }
    return target;
};

const getActiveNetworkIdFromLastKnownRegistry = async ({ client, walletProviderKey })=>{
    const networkRegistry = getLastKnownNetworkRegistry(client);
    return networkRegistry.getNetworkId({
        walletProviderKey
    });
};

const switchActiveNetworkInLastKnownRegistry = async ({ client, networkId, walletProviderKey })=>{
    const networkRegistry = getLastKnownNetworkRegistry(client);
    await networkRegistry.setNetworkId({
        networkId,
        walletProviderKey
    });
};

/**
 * Takes a callback that registers handlers for the external wallet provider.
 * Returns both a getter of an eventEmitter that can be exposed via the wallet provider
 * and a callback that will be used to destroy the listeners.
 */ const createWalletProviderEventEmitter = ({ removeEventListeners, setupEventListeners, supportedEvents = [
    'accountsChanged',
    'disconnected',
    'networkChanged'
] })=>{
    let eventEmitter;
    /** Value returned by setupEventListeners */ let setupReturnValue;
    const handleAccountsChanged = (params)=>{
        constants.assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('accountsChanged', params);
    };
    const handleDisconnected = ()=>{
        constants.assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('disconnected');
    };
    const handleNetworkChanged = (params)=>{
        constants.assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('networkChanged', params);
    };
    const cleanupEventEmitter = ()=>{
        if (!eventEmitter) {
            return;
        }
        removeEventListeners({
            handleAccountsChanged,
            handleDisconnected,
            handleNetworkChanged,
            setupReturnValue
        });
        eventEmitter = undefined;
    };
    const getEventEmitter = ()=>{
        if (!eventEmitter) {
            eventEmitter = new EventEmitter();
            setupReturnValue = setupEventListeners({
                handleAccountsChanged,
                handleDisconnected,
                handleNetworkChanged
            });
        }
        return Object.assign(eventEmitter, {
            supportedEvents
        });
    };
    return {
        cleanupEventEmitter,
        getEventEmitter
    };
};

const bufferToBase64 = (buf)=>{
    const binstr = Array.prototype.map.call(buf, (ch)=>String.fromCharCode(ch)).join('');
    return constants.getBuffer().from(binstr, 'binary').toString('base64');
};

assertPackageVersion.assertPackageVersion(constants.name, constants.version);

exports.APIError = constants.APIError;
exports.CHAINS_INFO_MAP = constants.CHAINS_INFO_MAP;
exports.ClientNotFoundError = constants.ClientNotFoundError;
exports.DYNAMIC_ICONIC_SPRITE_URL = constants.DYNAMIC_ICONIC_SPRITE_URL;
exports.DYNAMIC_SDK_API_VERSION = constants.DYNAMIC_SDK_API_VERSION;
exports.ValueMustBeDefinedError = constants.ValueMustBeDefinedError;
exports.assertDefined = constants.assertDefined;
exports.createApiClient = constants.createApiClient;
exports.getBuffer = constants.getBuffer;
exports.getChainFromVerifiedCredentialChain = constants.getChainFromVerifiedCredentialChain;
exports.getCore = constants.getCore;
exports.getDefaultClient = constants.getDefaultClient;
exports.isCookieEnabled = constants.isCookieEnabled;
exports.CannotTrackError = getNetworkProviderFromNetworkId.CannotTrackError;
exports.InvalidStorageSet = getNetworkProviderFromNetworkId.InvalidStorageSet;
exports.consumeCaptchaToken = getNetworkProviderFromNetworkId.consumeCaptchaToken;
exports.createLocalStorageAdapter = getNetworkProviderFromNetworkId.createLocalStorageAdapter;
exports.createLogger = getNetworkProviderFromNetworkId.createLogger;
exports.createSignInMessageStatement = getNetworkProviderFromNetworkId.createSignInMessageStatement;
exports.createStorage = getNetworkProviderFromNetworkId.createStorage;
exports.createStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema;
exports.createVisit = getNetworkProviderFromNetworkId.createVisit;
exports.formatSignInMessage = getNetworkProviderFromNetworkId.formatSignInMessage;
exports.getNetworkProviderBuilderRegistry = getNetworkProviderFromNetworkId.getNetworkProviderBuilderRegistry;
exports.getNetworkProviderFromNetworkId = getNetworkProviderFromNetworkId.getNetworkProviderFromNetworkId;
exports.getNetworkProviders = getNetworkProviderFromNetworkId.getNetworkProviders;
exports.getVerifiedCredentialForWalletAccount = getNetworkProviderFromNetworkId.getVerifiedCredentialForWalletAccount;
exports.hasExtension = getNetworkProviderFromNetworkId.hasExtension;
exports.setCaptchaToken = getNetworkProviderFromNetworkId.setCaptchaToken;
exports.setUnverifiedWalletAccounts = getNetworkProviderFromNetworkId.setUnverifiedWalletAccounts;
exports.subscribeWithSelector = getNetworkProviderFromNetworkId.subscribeWithSelector;
exports.updateWalletProviderKeysForVerifiedCredentials = getNetworkProviderFromNetworkId.updateWalletProviderKeysForVerifiedCredentials;
exports.verifySignInMessage = getNetworkProviderFromNetworkId.verifySignInMessage;
exports.InvalidWalletProviderKeyError = getWalletProviderByKey.InvalidWalletProviderKeyError;
exports.NoWalletProviderFoundError = getWalletProviderByKey.NoWalletProviderFoundError;
Object.defineProperty(exports, "WalletProviderPriority", {
  enumerable: true,
  get: function () { return getWalletProviderByKey.WalletProviderPriority; }
});
exports.createRuntimeServiceAccessKey = getWalletProviderByKey.createRuntimeServiceAccessKey;
exports.emitEvent = getWalletProviderByKey.emitEvent;
exports.emitWalletAccountsChangedEvent = getWalletProviderByKey.emitWalletAccountsChangedEvent;
exports.formatWalletAccountId = getWalletProviderByKey.formatWalletAccountId;
exports.formatWalletProviderKey = getWalletProviderByKey.formatWalletProviderKey;
exports.getWalletProviderFromWalletAccount = getWalletProviderByKey.getWalletProviderFromWalletAccount;
exports.getWalletProviderRegistry = getWalletProviderByKey.getWalletProviderRegistry;
exports.getWalletProviders = getWalletProviderByKey.getWalletProviders;
exports.normalizeWalletNameWithChain = getWalletProviderByKey.normalizeWalletNameWithChain;
exports.splitWalletProviderKey = getWalletProviderByKey.splitWalletProviderKey;
exports.updateAuthFromVerifyResponse = getWalletProviderByKey.updateAuthFromVerifyResponse;
exports.consumeMfaTokenIfRequiredForAction = getSignedSessionId.consumeMfaTokenIfRequiredForAction;
exports.getSignedSessionId = getSignedSessionId.getSignedSessionId;
exports.filterDuplicates = filterDuplicates.filterDuplicates;
exports.ClientsDoNotMatchError = ClientsDoNotMatchError;
exports.MethodNotImplementedError = MethodNotImplementedError;
exports.MultipleClientsFoundError = MultipleClientsFoundError;
exports.bufferToBase64 = bufferToBase64;
exports.createBaseNetworkProvider = createBaseNetworkProvider;
exports.createWalletProviderEventEmitter = createWalletProviderEventEmitter;
exports.formatWalletProviderGroupKey = formatWalletProviderGroupKey;
exports.getActiveNetworkIdFromLastKnownRegistry = getActiveNetworkIdFromLastKnownRegistry;
exports.getInjectedProviderFromWindow = getInjectedProviderFromWindow;
exports.getLastKnownNetworkRegistry = getLastKnownNetworkRegistry;
exports.registerExtension = registerExtension;
exports.switchActiveNetworkInLastKnownRegistry = switchActiveNetworkInLastKnownRegistry;
exports.waitForProjectSettings = waitForProjectSettings;
