import EventEmitter from 'eventemitter3';
import { IChainRpcProviders } from '@dynamic-labs/rpc-providers';
import type { JwtVerifiedCredential, WalletAdditionalAddress } from '@dynamic-labs/sdk-api-core';
import { GenericNetwork, MobileExperience } from '@dynamic-labs/types';
import { WalletBookSchema, WalletSchema } from '@dynamic-labs/wallet-book';
import { WalletConnectorEventEmitter } from '../events';
import { WalletMetadata } from '../types';
import { WalletConstructor, WalletProps } from '../Wallet';
import { WalletBookSingleton } from '../WalletBookSingleton';
import { Chain, GetAddressOpts, InternalWalletConnector, NameServiceData, WalletConnectorEventTypes, WalletConnectorExtension } from './types';
declare module '../types' {
    namespace WalletConnectorCore {
        interface WalletConnector extends WalletConnectorBase {
        }
    }
}
export declare abstract class WalletConnectorBase<C extends WalletConstructor<any> = WalletConstructor<any>> extends EventEmitter<WalletConnectorEventTypes> {
    #private;
    abstract ChainWallet: C;
    createWallet(props: WalletProps<InternalWalletConnector>): import("../Wallet").Wallet<any>;
    chainRpcProviders: IChainRpcProviders | undefined;
    constructorProps: any;
    _walletBookInstance: WalletBookSingleton;
    _metadata: WalletMetadata | undefined;
    walletConnectorEventsEmitter: WalletConnectorEventEmitter;
    walletFallback: WalletSchema | undefined;
    isGlobalTransaction: boolean;
    /**
     * We store the constructor props so that we can use them later on
     * in getMobileOrInstalledWallet which may fall back to a different class
     * but will need the original constructor props.
     * @param props - constructor props
     */
    constructor(props: {
        walletBook: WalletBookSchema;
        metadata?: WalletMetadata;
    });
    extend(extension: WalletConnectorExtension, settings?: {
        walletConnectDappProjectId?: string;
    }): void;
    didSetup: boolean;
    /**
     * Add the event listeners for the wallet and connect
     * with event emitter.
     */
    initEventListener(): void;
    get walletBook(): WalletBookSchema;
    filter(): boolean;
    get mobileExperience(): MobileExperience | undefined;
    /**
     * This flag corresponds to whether this wallet connector also requires its own email otp outside dynamic
     * @default false
     */
    requiresNonDynamicEmailOtp: boolean;
    /**
     * IF the wallet needs to be connected via a custodial service
     * such as Blocto, this will be true.
     * @default false
     */
    canConnectViaCustodialService: boolean;
    /**
     * If the wallet is not installed, and can be connected via a QR code,
     * this will be true.
     * @default false
     */
    canConnectViaQrCode: boolean;
    /**
     * Whether this connector can be connected via social login.
     * @default false
     */
    canConnectViaSocial: boolean;
    /**
     * Whether this connector can handle multiple connections
     * @default true
     */
    canHandleMultipleConnections: boolean;
    /**
     * Prompt the user to choose accounts to connect (see behavior in MM)
     * @default Promise<[]>
     */
    chooseAccountsToConnect(): Promise<string[]>;
    /**
     * Connect to the wallet or custodial service
     *
     * Historically, this was used for starting the connect process to be able to fetch
     * public address. But it can be used for different connection initialization.
     *
     * @default string - the public address of the wallet
     */
    connect(args?: unknown): Promise<void>;
    connect<T = undefined>(args: T): Promise<void>;
    /**
     * The chain this wallet is connected
     */
    abstract connectedChain: Chain;
    /**
     * Generic function to close the wallet connection
     *
     * Originally implemented for WalletConnect, but it is used
     * for anything that needs to be "logged out" or cleaned up.
     *
     * Remember to call teardownEventListeners() in the implementation.
     *
     * @default Promise<undefined>
     */
    endSession(): Promise<void>;
    /**
     * Gets the public address of the wallet
     *
     * @default Promise<undefined>
     */
    getAddress(opts?: GetAddressOpts): Promise<string | undefined>;
    /**
     * Parses a public address to ensure it follows a correct format.
     *
     * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
     *
     * @default string
     */
    parseAddress(address: string): string;
    /**
     * Whether this wallet connector is targeting a testnet.
     * So far only supported for EVM connectors.
     *
     * @default Promise<false>
     */
    isTestnet(): Promise<boolean>;
    /**
     * Gets the additional addresses of the wallet, given the main address
     *
     * @default Promise<[]>
     */
    getAdditionalAddresses(mainAddress?: string): Promise<WalletAdditionalAddress[]>;
    /**
     * Sets the additional addresses of the wallet, given the main address
     *
     * @default Promise<void>
     */
    setAdditionalAddresses(mainAddress: string, additionalAddresses: WalletAdditionalAddress[]): Promise<void>;
    /**
     * Gets the balance of the wallet
     *
     * @default Promise<undefined>
     */
    getBalance(address: string): Promise<string | undefined>;
    /**
     * Get the address silently
     *
     * This is used to check which accounts are already connected and
     * should silently attempt to reconnect. If the user refreshes their
     * page and gets disconnected, there's likely an issue with the
     * implementation of this method.
     *
     * @default Promise<[]>
     */
    getConnectedAccounts(): Promise<string[]>;
    /**
     * Gets the deep link of the wallet
     *
     * @default undefined
     */
    getDeepLink(): string | undefined;
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     * @param returnDynamicNetworkId - For SOL chain, if returnDynamicNetworkId is true,
     * the dynamic network ID (101, 102, 201, etc) will be returned instead of the network
     * cluster (mainnet, testnet, etc)
     */
    getNetwork(returnDynamicNetworkId?: boolean): Promise<number | string | undefined>;
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     */
    getNameService(address: string): Promise<NameServiceData | undefined>;
    /**
     * Get the RPC provider for the wallet
     *
     * @default Promise<undefined>
     */
    getPublicClient(): Promise<unknown>;
    getPublicClient<T>(): Promise<T>;
    /**
     * Get the session for the wallet
     * @default Promise<undefined>
     */
    getSession(): unknown;
    getSession<T>(): Promise<T>;
    /**
     * Get the signer for the wallet
     *
     * @default Promise<undefined>
     */
    getSigner(): Promise<unknown>;
    getSigner<T>(): Promise<T>;
    /**
     * Get the wallet client
     *
     * @default undefined
     */
    getWalletClient(chainId?: string): unknown;
    getWalletClient<T>(chainId?: string): T;
    /**
     * Initialize the wallet connector with any async operations
     *
     * @default Promise<void>
     */
    init(): Promise<void>;
    /**
     * Flag if connector/provider is available
     *
     * @default true
     */
    isAvailable: boolean;
    /**
     * If the wallet generated by a valid embedded wallet provider
     * For example: magic wallets
     * @default false
     */
    isEmbeddedWallet: boolean;
    /**
     * Check if the wallet is installed on the browser
     *
     * @default false
     */
    isInstalledOnBrowser(): boolean;
    /**
     * Flag if it is wallet Connect
     *
     * @default false
     */
    isWalletConnect: boolean;
    /**
     * Override key or the normalized wallet name if needed
     */
    get key(): string;
    get metadata(): WalletMetadata;
    /**
     * Wallet name
     */
    abstract name: string;
    /**
     * Override key for the wallet (used for injected wallet linking)
     *
     * This is used to help group wallets by chain and should be set for multichain wallets.
     */
    overrideKey: string | undefined;
    /**
     * Whether the wallet connector should fall back to a different wallet connector
     * This is called after the object is instantiated, so it can't be a static property
     * and will return the appropriate instance of the wallet connector
     * @returns WalletConnector
     * @default this
     */
    getMobileOrInstalledWallet(): InternalWalletConnector;
    /**
     * In most cases this is an alias for `signMessage`
     *
     * @default Promise<undefined>
     */
    proveOwnership(address: string, messageToSign: string): Promise<string | undefined>;
    /**
     * Additional resources to add to the message to be signed
     *
     * @default undefined
     */
    providerResources: string[] | undefined;
    /**
     * Set up event listeners for the wallet
     *
     * @default void
     */
    setupEventListeners(): void;
    /**
     * Sign a message
     *
     * @default Promise<undefined>
     */
    signMessage(messageToSign: string, options?: {
        address?: string;
    }): Promise<string | undefined>;
    /**
     * Returns the array of block explorer URLs available for the current network
     */
    getBlockExplorerUrlsForCurrentNetwork(): Promise<string[]>;
    /**
     * List of supported chains for this wallet
     */
    abstract readonly supportedChains: Chain[];
    /**
     * Whether the wallet supports network switching
     *
     * @default false
     */
    supportsNetworkSwitching(): boolean;
    /**
     * Switch the network
     * @default Promise<undefined>
     */
    switchNetwork({ networkName, networkChainId, }: {
        networkChainId?: number | string;
        networkName?: string;
    }): Promise<void>;
    /**
     * Requires switching network in the wallet itself
     * @default undefined
     */
    switchNetworkOnlyFromWallet: boolean | undefined;
    /**
     * Tear down event listeners for the wallet
     * @default void
     */
    teardownEventListeners(): void;
    /**
     * Whether the connector has been initialized
     * @default true
     */
    isInitialized: boolean;
    /**
     * Receive the user verified credentials
     */
    setVerifiedCredentials(verifiedCredentials: JwtVerifiedCredential[]): void;
    /**
     * Whether the wallet allow for getting the address in the
     * current chain.
     * This is used for multi chain wallets.
     * @default true
     */
    canGetChainAddress(): boolean;
    /**
     * Prompts the user to make expected wallet active
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
     * otherwise rejects with an error.
     */
    handleWalletNotActive({ activeAddress, expectedAddress, reconnectedAddress, }: {
        expectedAddress: string;
        activeAddress?: string;
        reconnectedAddress?: string;
    }): Promise<void>;
    /**
     * Validates if the address is connected and active in the wallet app
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
     * otherwise rejects with an error.
     */
    validateActiveWallet(expectedAddress: string): Promise<void>;
    /**
     * Get the enabled networks for the wallet.
     *
     * These are normally set in the opts prop of the wallet connector constructor. The
     * network values are passed from project settings and can require an update to
     * [getWalletConnectorConstructorOptions] for new chains.
     *
     * @returns {GenericNetwork[]} The enabled networks
     */
    getEnabledNetworks(): GenericNetwork[];
    /**
     * Retry the deeplink connection for mobile wallets
     * @default Promise<void>
     */
    retryDeeplinkConnection(): void;
    /**
     * Check if retryDeeplinkConnection has been implemented by a subclass
     */
    hasRetryDeeplinkConnection(): boolean;
    /**
     * Open the inAppBrowser if required
     * @returns True if the inAppBrowser was opened, false otherwise.
     */
    openInAppBrowserIfRequired(): boolean;
}
