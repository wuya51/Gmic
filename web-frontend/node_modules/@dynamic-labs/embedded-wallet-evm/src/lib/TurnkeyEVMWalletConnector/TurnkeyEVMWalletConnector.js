'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';
import { IframeStamper } from '@turnkey/iframe-stamper';
import { createAccount } from '@turnkey/viem';
import { WebauthnStamper } from '@turnkey/webauthn-stamper';
import { http, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { hashAuthorization } from 'viem/utils';
import { TurnkeyWalletConnectorBase, logger, findTurnkeyVerifiedCredentialsWithSmartWalletRef, TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS } from '@dynamic-labs/embedded-wallet';
import { EthereumWallet, createWalletClientWithUiConfirmation, getOrMapViemChain, createViemUiTransaction } from '@dynamic-labs/ethereum-core';
import { parseEvmNetworks, DynamicError } from '@dynamic-labs/utils';
import { getRpcUrlForChain, isSameAddress } from '@dynamic-labs/wallet-connector-core';

class TurnkeyEVMWalletConnector extends TurnkeyWalletConnectorBase {
    constructor(nameAndKey, props) {
        var _a, _b, _c;
        super(nameAndKey, props);
        this.walletFallback = {
            brand: {
                alt: 'Turnkey Wallet',
                spriteId: 'turnkey',
            },
            name: 'Turnkey HD',
        };
        // Public fields
        this.ChainWallet = EthereumWallet;
        this.connectedChain = 'EVM';
        this.supportedChains = ['ETH', 'EVM'];
        this.verifiedCredentialChain = 'eip155';
        this.evmNetworks = parseEvmNetworks(props.evmNetworks);
        this.walletUiUtils = props.walletUiUtils;
        this._turnkeyAccount = undefined;
        this._selectedChainId = this.getLastUsedChainId();
        this.providersConfig = (_a = props.providersConfig) !== null && _a !== void 0 ? _a : {};
        this.chainRpcProviders = props.chainRpcProviders;
        (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.registerEvmProviders((_c = this.providersConfig) !== null && _c !== void 0 ? _c : {});
        this.getTurnkeyClient()
            .then((client) => {
            this.__turnkeyClient = client;
        })
            .catch((error) => logger.error('Error getting turnkey client', error));
    }
    getLastUsedChainId() {
        var _a;
        logger.logVerboseTroubleshootingMessage('[TurnkeyEVMWalletConnector] getLastUsedChainId', {
            evmNetworks: this.evmNetworks,
            lastUsedChainId: this.lastUsedChainId,
        });
        if (this.lastUsedChainId) {
            return this.lastUsedChainId;
        }
        if (!((_a = this.evmNetworks) === null || _a === void 0 ? void 0 : _a.length)) {
            return undefined;
        }
        return this.evmNetworks[0].chainId;
    }
    // Public methods
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return (_a = (yield this.getSigner())) === null || _a === void 0 ? void 0 : _a.getChainId();
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!networkChainId) {
                return;
            }
            if (typeof networkChainId === 'string') {
                networkChainId = parseInt(networkChainId);
            }
            this.lastUsedChainId = networkChainId;
            this._selectedChainId = networkChainId;
            yield this.refreshTurnkeyAccount();
            this.emit('chainChange', {
                chain: networkChainId.toString(),
            });
        });
    }
    setVerifiedCredentials(verifiedCredentials) {
        const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentialsWithSmartWalletRef(verifiedCredentials, 'eip155');
        const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
        const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !==
            JSON.stringify(turnkeyVerifiedCredentials);
        if (!didTurnkeyVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = turnkeyVerifiedCredential;
        this.verifiedCredentials = turnkeyVerifiedCredentials;
        this.refreshTurnkeyAccount();
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const activeAddress = ((_a = this.verifiedCredential) === null || _a === void 0 ? void 0 : _a.address) || '';
            const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (!isWalletActive) {
                const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc) => (vc === null || vc === void 0 ? void 0 : vc.address) === expectedAddress);
                if (!targetActiveAccount) {
                    throw new DynamicError('Account not found');
                }
                this.verifiedCredential = targetActiveAccount;
                this.refreshTurnkeyAccount();
            }
        });
    }
    signAuthorization(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { address: contractAddress, nonce, chainId } = parameters;
            yield this.createOrRestoreSession();
            if (!contractAddress) {
                throw new Error('Contract address not found');
            }
            const [signer, publicClient] = yield Promise.all([
                this.getSigner(),
                this.getPublicClient(),
            ]);
            if (!signer || !publicClient) {
                throw new Error('Required clients not found');
            }
            const { turnkeySubOrganizationId } = (_a = this.walletProperties) !== null && _a !== void 0 ? _a : {};
            if (!turnkeySubOrganizationId) {
                throw new Error('Turnkey sub organization id not found');
            }
            const { address } = signer.account;
            const signature = yield this.internalSign({
                address,
                hash: hashAuthorization({
                    address: contractAddress,
                    chainId,
                    nonce,
                }),
                turnkeySubOrganizationId,
            });
            return {
                address: contractAddress,
                chainId,
                nonce,
                r: signature.r,
                s: signature.s,
                v: BigInt(signature.v),
                yParity: signature.yParity,
            };
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getPublicClient();
            if (!client) {
                return undefined;
            }
            const balance = yield client.getBalance({
                address: address,
            });
            return formatEther(balance);
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = yield this.getSigner();
            if (!signer) {
                throw new Error('Signer not found');
            }
            return signer.signMessage({
                message: messageToSign,
            });
        });
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.evmNetworks.length === 0) {
                return undefined;
            }
            const networkId = (_a = (yield this.getNetwork())) !== null && _a !== void 0 ? _a : 1;
            const configurations = {
                cosmos: [],
                evm: this.evmNetworks,
                solana: [],
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getTurnkeyAccount();
            return this.getWalletClient();
        });
    }
    // decides in runtime which stamper to use and creates the corresponding account
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (this.isSessionKeyCompatible() &&
                ((_a = this.__turnkeyClient) === null || _a === void 0 ? void 0 : _a.stamper) instanceof ApiKeyStamper) {
                return this._turnkeyAccount;
            }
            if ((this.getAuthenticatorHandler().recoveryType === 'passkey' &&
                ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper) ||
                (this.getAuthenticatorHandler().recoveryType === 'email' &&
                    ((_c = this.__turnkeyClient) === null || _c === void 0 ? void 0 : _c.stamper) instanceof WebauthnStamper) ||
                this.__turnkeyClient !== this.getAuthenticatorHandler().client) {
                yield this.refreshTurnkeyAccount();
            }
            return this._turnkeyAccount;
        });
    }
    getWalletClient() {
        const rpcUrl = this.networkRpcUrl;
        const account = this._turnkeyAccount;
        const evmNetwork = this.currentEvmNetwork;
        if (!account || !rpcUrl || !evmNetwork) {
            return undefined;
        }
        return createWalletClientWithUiConfirmation({
            account: this.getAccount.bind(this),
            address: this.turnkeyAddress,
            chain: getOrMapViemChain(evmNetwork),
            transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this.walletUiUtils,
        });
    }
    // Private methods
    get currentChainId() {
        var _a, _b, _c;
        return (_a = this._selectedChainId) !== null && _a !== void 0 ? _a : (_c = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.chainId;
    }
    get lastUsedChainId() {
        const lastUsedChainIdLS = localStorage.getItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
        if (!lastUsedChainIdLS)
            return undefined;
        try {
            const chainId = parseInt(lastUsedChainIdLS);
            if (isNaN(chainId)) {
                return undefined;
            }
            const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
            if (!isChainCurrentlyEnabled) {
                const lastUsedChainId = this.evmNetworks[0].chainId;
                this.lastUsedChainId = lastUsedChainId;
                return this.lastUsedChainId;
            }
            return chainId;
        }
        catch (err) {
            logger.error(err);
            return undefined;
        }
    }
    set lastUsedChainId(chainId) {
        if (chainId === undefined) {
            localStorage.removeItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
        }
        else {
            localStorage.setItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey, chainId.toString());
        }
    }
    get networkRpcUrl() {
        const chainId = this.currentChainId;
        const evmNetwork = this.evmNetworks.find((network) => network.chainId === chainId);
        if (!evmNetwork) {
            return undefined;
        }
        const rpcUrl = getRpcUrlForChain({
            chainId: chainId,
            networks: this.evmNetworks,
        });
        return rpcUrl;
    }
    get currentEvmNetwork() {
        const chainId = this.currentChainId;
        logger.logVerboseTroubleshootingMessage('[TurnkeyEVMWalletConnector] currentEvmNetwork', {
            chainId,
            evmNetworks: this.evmNetworks,
        });
        return this.evmNetworks.find((network) => network.chainId === chainId);
    }
    internalSign(_a) {
        return __awaiter(this, arguments, void 0, function* ({ hash, address, turnkeySubOrganizationId, }) {
            var _b;
            const client = yield this.getTurnkeyClient();
            const { activity } = yield client.signRawPayload({
                organizationId: turnkeySubOrganizationId,
                parameters: {
                    encoding: 'PAYLOAD_ENCODING_HEXADECIMAL',
                    hashFunction: 'HASH_FUNCTION_NO_OP',
                    payload: hash,
                    signWith: address,
                },
                timestampMs: Date.now().toString(),
                type: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2',
            });
            const result = (_b = activity === null || activity === void 0 ? void 0 : activity.result) === null || _b === void 0 ? void 0 : _b.signRawPayloadResult;
            if (!result) {
                throw new Error('Sign raw payload result not found');
            }
            return {
                r: `0x${result.r}`,
                s: `0x${result.s}`,
                v: result.v,
                yParity: Number(result.v) % 2,
            };
        });
    }
    internalSignTransaction(_a) {
        return __awaiter(this, arguments, void 0, function* ({ transaction, args, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signTransaction(transaction, args),
                activityType: 'SignTransaction',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    internalSignTypedData(_a) {
        return __awaiter(this, arguments, void 0, function* ({ typedData, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signTypedData(typedData),
                activityType: 'SignTypedData',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    internalSignMessage(_a) {
        return __awaiter(this, arguments, void 0, function* ({ message, address, turnkeySubOrganizationId, }) {
            return this.doRetryableTurnkeyAction({
                action: (turnkeyAccount) => turnkeyAccount.signMessage({ message }),
                activityType: 'SignMessage',
                address,
                turnkeySubOrganizationId,
            });
        });
    }
    doRetryableTurnkeyAction(_a) {
        return __awaiter(this, arguments, void 0, function* ({ action, activityType, address, turnkeySubOrganizationId, }) {
            yield this.createOrRestoreSession();
            let newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
                address,
                turnkeySubOrganizationId,
            });
            try {
                return yield action(newTurnkeyAccountRaw);
            }
            catch (err) {
                if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message
                    .toLowerCase()
                    .includes(errorMsg.toLowerCase()))) {
                    yield this.removeSessionKeys();
                    yield this.createOrRestoreSession({
                        ignoreRestore: true,
                    });
                    newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
                        address,
                        turnkeySubOrganizationId,
                    });
                    logger.error(`[TK - removeSessionKeys] failed to perform ${activityType} activity`, {
                        activityType,
                        address,
                        err,
                        turnkeySubOrganizationId,
                    });
                    return action(newTurnkeyAccountRaw);
                }
                throw err;
            }
        });
    }
    createTurnkeyAccount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ address, turnkeySubOrganizationId, }) {
            return createAccount({
                client: (yield this.getTurnkeyClient()),
                ethereumAddress: address,
                organizationId: turnkeySubOrganizationId,
                signWith: address,
            });
        });
    }
    refreshTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            this._turnkeyAccount = undefined;
            return this.getTurnkeyAccount();
        });
    }
    getTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this._turnkeyAccount) {
                return this._turnkeyAccount;
            }
            const { turnkeySubOrganizationId } = (_a = this.walletProperties) !== null && _a !== void 0 ? _a : {};
            const { address } = (_b = this.verifiedCredential) !== null && _b !== void 0 ? _b : {};
            if (!turnkeySubOrganizationId || !address) {
                return;
            }
            this._turnkeyAccount = toAccount({
                address: address,
                signAuthorization: (...args) => __awaiter(this, void 0, void 0, function* () { return this.signAuthorization(...args); }),
                signMessage: (_c) => __awaiter(this, [_c], void 0, function* ({ message, }) {
                    return this.internalSignMessage({
                        address: address,
                        message,
                        turnkeySubOrganizationId,
                    });
                }),
                signTransaction: (transaction, args) => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTransaction({
                        address: address,
                        args,
                        transaction,
                        turnkeySubOrganizationId,
                    });
                }),
                signTypedData: (typedData) => __awaiter(this, void 0, void 0, function* () {
                    return this.internalSignTypedData({
                        address: address,
                        turnkeySubOrganizationId,
                        typedData,
                    });
                }),
            });
            this.setLoggerMetadata();
            return this._turnkeyAccount;
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return createViemUiTransaction({ from, publicClient, walletClient });
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const currentNetwork = yield this.getNetwork();
            return ((_b = (_a = this.evmNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a === void 0 ? void 0 : _a.blockExplorerUrls) !== null && _b !== void 0 ? _b : []);
        });
    }
    getEnabledNetworks() {
        return this.evmNetworks;
    }
    isSignAuthorizationSupported() {
        return true;
    }
}
TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey = 'turnkey-last-used-chain-id';

export { TurnkeyEVMWalletConnector };
