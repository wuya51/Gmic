import { i as isMfaRequiredForAction, c as consumeMfaToken, b as bufferToHex } from './isMfaRequiredForAction.esm.js';
import { m as getSessionKeys, d as assertDefined, a as getCore } from './constants.esm.js';

const consumeMfaTokenIfRequiredForAction = async ({ mfaAction }, client)=>{
    const isRequiredForAction = await isMfaRequiredForAction({
        mfaAction
    }, client);
    if (!isRequiredForAction) {
        return;
    }
    return consumeMfaToken(client);
};

const p256Sign = async ({ privateKeyJwk, message })=>{
    const privateKey = await crypto.subtle.importKey('jwk', privateKeyJwk, {
        name: 'ECDSA',
        namedCurve: 'P-256'
    }, false, [
        'sign'
    ]);
    const signature = await crypto.subtle.sign({
        hash: 'SHA-256',
        name: 'ECDSA'
    }, privateKey, new TextEncoder().encode(message));
    return bufferToHex(signature);
};

const generateSessionSignature = async ({ sessionId }, client)=>{
    const sessionKeys = getSessionKeys(client);
    assertDefined(sessionKeys, 'Session keys not found');
    const { privateKeyJwk } = sessionKeys;
    const signature = await p256Sign({
        message: sessionId,
        privateKeyJwk
    });
    return {
        signature
    };
};

const getSignedSessionId = async (client)=>{
    var _core_state_get_user;
    const core = getCore(client);
    const sessionId = (_core_state_get_user = core.state.get().user) == null ? void 0 : _core_state_get_user.sessionId;
    assertDefined(sessionId, 'Session ID is required');
    const { signature } = await generateSessionSignature({
        sessionId
    }, client);
    assertDefined(signature, 'Signed session ID is required');
    return {
        signature
    };
};

export { consumeMfaTokenIfRequiredForAction as c, getSignedSessionId as g };
