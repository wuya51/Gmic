import type { ForwardMPCClient } from '@dynamic-labs-wallet/forward-mpc-client';
import type { SignMessageEvmTransaction, SignMessageEvmUserOperation, SignMessageSvmTransaction } from '@dynamic-labs/sdk-api-core';
import { type BackupLocation } from '../constants.js';
import type { ThresholdSignatureScheme } from '../mpc/constants.js';
import { AuthMode, type BackupLocationWithExternalKeyShareId, type EncryptedDelegatedKeyShareEnvelope, type KeygenCompleteResponse, type OpenRoomResponse, type ReshareResponse, type WaasWalletResponse } from '../types.js';
import { BaseClient } from './client.js';
export declare class DynamicApiClient extends BaseClient {
    constructor({ environmentId, authToken, baseApiUrl, authMode, sdkVersion, forwardMPCClient, }: {
        environmentId: string;
        authToken?: string;
        baseApiUrl?: string;
        authMode?: AuthMode;
        sdkVersion?: string;
        forwardMPCClient?: ForwardMPCClient;
    });
    authenticateApiToken({ environmentId }: {
        environmentId: string;
    }): Promise<import("axios").AxiosResponse<any, any, {}>>;
    createWalletAccount({ chainName, clientKeygenIds, dynamicRequestId, thresholdSignatureScheme, skipLock, onError, onCeremonyComplete, }: {
        chainName: string;
        dynamicRequestId?: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        skipLock?: boolean;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<KeygenCompleteResponse>;
    signMessage({ dynamicRequestId, walletId, message, onError, isFormatted, mfaToken, context, forwardMPCClientEnabled, }: {
        dynamicRequestId?: string;
        walletId: string;
        message: string;
        onError?: (error: Error) => void;
        isFormatted?: boolean;
        mfaToken?: string;
        context?: SignMessageEvmTransaction | SignMessageSvmTransaction | SignMessageEvmUserOperation;
        forwardMPCClientEnabled?: boolean;
    }): Promise<OpenRoomResponse>;
    refreshWalletAccountShares({ dynamicRequestId, walletId, onError, mfaToken, }: {
        dynamicRequestId?: string;
        walletId: string;
        onError?: (error: Error) => void;
        mfaToken?: string;
    }): Promise<{
        roomId: string;
        serverKeygenIds: string[];
    }>;
    reshare({ walletId, dynamicRequestId, clientKeygenIds, oldThresholdSignatureScheme, newThresholdSignatureScheme, delegateToProjectEnvironment, revokeDelegation, mfaToken, onError, }: {
        dynamicRequestId?: string;
        walletId: string;
        clientKeygenIds: string[];
        oldThresholdSignatureScheme: ThresholdSignatureScheme;
        newThresholdSignatureScheme: ThresholdSignatureScheme;
        delegateToProjectEnvironment?: boolean;
        revokeDelegation?: boolean;
        mfaToken?: string;
        onError?: (error: Error) => void;
    }): Promise<ReshareResponse>;
    exportKey({ mfaToken, dynamicRequestId, walletId, exportId, onError, }: {
        mfaToken?: string;
        dynamicRequestId?: string;
        walletId: string;
        exportId: string;
        onError?: (error: Error) => void;
    }): Promise<OpenRoomResponse>;
    getDelegatedEncryptionKey({ environmentId, }: {
        environmentId: string;
    }): Promise<any>;
    publishDelegatedKeyShare({ walletId, encryptedKeyShare, signedSessionId, requiresSignedSessionId, dynamicRequestId, }: {
        walletId: string;
        encryptedKeyShare: EncryptedDelegatedKeyShareEnvelope;
        dynamicRequestId: string;
        signedSessionId?: string;
        requiresSignedSessionId?: boolean;
    }): Promise<{
        data: any;
        status: number;
    }>;
    storeEncryptedBackupByWallet({ walletId, encryptedKeyShares, passwordEncrypted, signedSessionId, encryptionVersion, requiresSignedSessionId, authMode, dynamicRequestId, }: {
        walletId: string;
        encryptedKeyShares: string[];
        passwordEncrypted: boolean;
        dynamicRequestId: string;
        signedSessionId?: string;
        encryptionVersion?: string;
        requiresSignedSessionId?: boolean;
        authMode?: AuthMode;
    }): Promise<any>;
    markKeySharesAsBackedUpGoogleDrive({ walletId }: {
        walletId: string;
    }): Promise<any>;
    markKeySharesAsBackedUp({ walletId, locations, dynamicRequestId, }: {
        walletId: string;
        locations: BackupLocationWithExternalKeyShareId[];
        dynamicRequestId: string;
    }): Promise<{
        message: string;
        walletId: string;
        locationsWithKeyShares: {
            location: BackupLocation;
            keyShareId: string;
            externalKeyShareId?: string;
        }[];
    }>;
    recoverEncryptedBackupByWallet({ walletId, keyShareIds, signedSessionId, mfaToken, requiresSignedSessionId, authMode, }: {
        walletId: string;
        keyShareIds?: string[];
        signedSessionId?: string;
        mfaToken?: string;
        requiresSignedSessionId?: boolean;
        authMode?: AuthMode;
    }): Promise<any>;
    getAccessToken({ oauthAccountId }: {
        oauthAccountId: string;
    }): Promise<any>;
    importPrivateKey({ chainName, dynamicRequestId, clientKeygenIds, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        dynamicRequestId?: string;
        chainName: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<KeygenCompleteResponse>;
    getUser(dynamicRequestId: string): Promise<any>;
    refreshUser(): Promise<any>;
    getEnvironmentSettings(): Promise<any>;
    getWaasWalletById({ walletId, }: {
        walletId: string;
    }): Promise<WaasWalletResponse>;
    delegatedSignMessage({ walletId, message, isFormatted, dynamicRequestId, onError, context, }: {
        walletId: string;
        message: string;
        isFormatted?: boolean;
        dynamicRequestId: string;
        onError?: (error: Error) => void;
        context?: SignMessageEvmTransaction | SignMessageSvmTransaction | SignMessageEvmUserOperation;
    }): Promise<OpenRoomResponse>;
}
//# sourceMappingURL=api.d.ts.map