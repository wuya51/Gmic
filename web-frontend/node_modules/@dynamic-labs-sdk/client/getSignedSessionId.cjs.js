'use strict';

var isMfaRequiredForAction = require('./isMfaRequiredForAction.cjs.js');
var constants = require('./constants.cjs.js');

const consumeMfaTokenIfRequiredForAction = async ({ mfaAction }, client)=>{
    const isRequiredForAction = await isMfaRequiredForAction.isMfaRequiredForAction({
        mfaAction
    }, client);
    if (!isRequiredForAction) {
        return;
    }
    return isMfaRequiredForAction.consumeMfaToken(client);
};

const p256Sign = async ({ privateKeyJwk, message })=>{
    const privateKey = await crypto.subtle.importKey('jwk', privateKeyJwk, {
        name: 'ECDSA',
        namedCurve: 'P-256'
    }, false, [
        'sign'
    ]);
    const signature = await crypto.subtle.sign({
        hash: 'SHA-256',
        name: 'ECDSA'
    }, privateKey, new TextEncoder().encode(message));
    return isMfaRequiredForAction.bufferToHex(signature);
};

const generateSessionSignature = async ({ sessionId }, client)=>{
    const sessionKeys = constants.getSessionKeys(client);
    constants.assertDefined(sessionKeys, 'Session keys not found');
    const { privateKeyJwk } = sessionKeys;
    const signature = await p256Sign({
        message: sessionId,
        privateKeyJwk
    });
    return {
        signature
    };
};

const getSignedSessionId = async (client)=>{
    var _core_state_get_user;
    const core = constants.getCore(client);
    const sessionId = (_core_state_get_user = core.state.get().user) == null ? void 0 : _core_state_get_user.sessionId;
    constants.assertDefined(sessionId, 'Session ID is required');
    const { signature } = await generateSessionSignature({
        sessionId
    }, client);
    constants.assertDefined(signature, 'Signed session ID is required');
    return {
        signature
    };
};

exports.consumeMfaTokenIfRequiredForAction = consumeMfaTokenIfRequiredForAction;
exports.getSignedSessionId = getSignedSessionId;
