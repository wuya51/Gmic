import { Account, Hex, Transport, Chain as ViemChain, WalletClient } from 'viem';
import { LocalAccount, SignAuthorizationParameters, SignAuthorizationReturnType } from 'viem/accounts';
import { EthereumWalletConnector, EthereumWalletConnectorOpts, SwitchNetworkOps } from '@dynamic-labs/ethereum-core';
import { JwtVerifiedCredential, MFAAction, SignMessageContext } from '@dynamic-labs/sdk-api-core';
import { IUITransaction } from '@dynamic-labs/types';
import { WaasExportHandler } from '@dynamic-labs/waas';
import { IDynamicWaasConnector } from '@dynamic-labs/wallet-connector-core';
interface JwtVerifiedCredentialWithSmartWalletRef extends JwtVerifiedCredential {
    smartWalletRefId?: string;
    smartWalletRefAddress?: string;
}
type SignAuthorizationParametersWithoutPrivateKey = Omit<SignAuthorizationParameters, 'privateKey'>;
declare const DynamicWaasEVMConnector_base: (abstract new (...args: any[]) => {
    [x: string]: any;
    name: string;
    overrideKey: string;
    isEmbeddedWallet: boolean;
    getSignedSessionId?: (() => Promise<string>) | undefined;
    getMfaToken?: ((props?: {
        mfaAction?: MFAAction | undefined;
    } | undefined) => Promise<string | undefined>) | undefined;
    getAuthToken?: (() => string) | undefined;
    environmentId?: string | undefined;
    baseApiUrl?: string | undefined;
    relayUrl?: string | undefined;
    dynamicWaasClient: import("@dynamic-labs-wallet/browser-wallet-client").DynamicWalletClient | undefined;
    chainName: string;
    authMode: "cookie" | "header";
    __exportHandler: WaasExportHandler;
    validateActiveWallet(expectedAddress: string): Promise<void>;
    setGetAuthTokenFunction(getAuthToken: () => string): void;
    setWaasAuthMode(authMode: "cookie" | "header"): void;
    setGetMfaTokenFunction(getMfaToken: (props?: {
        mfaAction?: MFAAction | undefined;
    } | undefined) => Promise<string | undefined>): void;
    setEnvironmentId(environmentId: string): void;
    setBaseApiUrl(baseApiUrl: string): void;
    setRelayUrl(relayUrl: string): void;
    setGetSignedSessionIdFunction(getSignedSessionId: () => Promise<string>): void;
    delegateKeyShares({ accountAddress, password, }: {
        accountAddress: string;
        password?: string | undefined;
    }): Promise<void>;
    createDynamicWaasClient(): Promise<import("@dynamic-labs-wallet/browser-wallet-client").DynamicWalletClient>;
    getWaasWalletClient(): Promise<import("@dynamic-labs-wallet/browser-wallet-client").DynamicWalletClient>;
    createWalletAccount({ thresholdSignatureScheme, password, }?: {
        thresholdSignatureScheme?: string | undefined;
        password?: string | undefined;
    } | undefined): Promise<{
        chainName: string;
        accountAddress: string;
        publicKeyHex: string;
        rawPublicKey: string | Uint8Array | undefined;
    }>;
    importPrivateKey({ privateKey, thresholdSignatureScheme, publicAddressCheck, }: {
        privateKey: string;
        thresholdSignatureScheme?: string | undefined;
        publicAddressCheck?: string | undefined;
    }): Promise<void>;
    exportPrivateKey({ accountAddress, displayContainer, password, }?: {
        accountAddress?: string | undefined;
        displayContainer?: HTMLIFrameElement | undefined;
        password?: string | undefined;
    } | undefined): Promise<void>;
    getExportHandler(): {
        clear: () => void;
    };
    exportClientKeyshares({ accountAddress, password, }: {
        accountAddress: string;
        password?: string | undefined;
    }): Promise<void>;
    backupKeySharesToGoogleDrive({ accountAddress, password, }: {
        accountAddress: string;
        password?: string | undefined;
    }): Promise<void>;
    refreshWalletAccountShares({ accountAddress, password, }: {
        accountAddress: string;
        password?: string | undefined;
    }): Promise<void>;
    reshareWalletAccountShares({ accountAddress, thresholdSignatureScheme, password, }: {
        accountAddress: string;
        thresholdSignatureScheme: string;
        password?: string | undefined;
    }): Promise<void>;
    revokeDelegation({ accountAddress, password, }: {
        accountAddress: string;
        password?: string | undefined;
    }): Promise<void>;
    updatePassword({ accountAddress, existingPassword, newPassword, }: {
        accountAddress: string;
        existingPassword: string;
        newPassword: string;
    }): Promise<void>;
    signRawMessage({ accountAddress, message, password, }: {
        accountAddress: string;
        message: string;
        password?: string | undefined;
    }): Promise<string>;
    endSession(): Promise<void>;
    getActiveAccountAddress(): Promise<string | undefined>;
}) & typeof EthereumWalletConnector;
export declare class DynamicWaasEVMConnector extends DynamicWaasEVMConnector_base implements IDynamicWaasConnector {
    name: string;
    overrideKey: string;
    isEmbeddedWallet: boolean;
    /**
     * Relationship between verifiedCredential and verifiedCredentials:
     * - verifiedCredential: The first/primary credential from the array (used for active account)
     * - verifiedCredentials: The full array of all credentials
     * When setVerifiedCredentials is called, it processes the input array and sets both properties
     * The first credential (verifiedCredential) is specifically filtered to be a "dynamicwaas"
     */
    private _verifiedCredential;
    private _verifiedCredentials;
    static lastUsedChainIdStorageKey: string;
    private _selectedChainId;
    constructor(props: EthereumWalletConnectorOpts);
    private getLastUsedChainId;
    set verifiedCredentials(verifiedCredentials: JwtVerifiedCredentialWithSmartWalletRef[] | undefined);
    get verifiedCredentials(): JwtVerifiedCredentialWithSmartWalletRef[] | undefined;
    set verifiedCredential(verifiedCredential: JwtVerifiedCredentialWithSmartWalletRef | undefined);
    get verifiedCredential(): JwtVerifiedCredentialWithSmartWalletRef | undefined;
    setVerifiedCredentials(verifiedCredentials: JwtVerifiedCredential[]): void;
    set lastUsedChainId(chainId: number | undefined);
    get lastUsedChainId(): number | undefined;
    private get currentChainId();
    getNetwork(): Promise<number | undefined>;
    private getEvmNetworkByChainId;
    private currentEvmNetwork;
    switchNetwork({ networkChainId, }: SwitchNetworkOps): Promise<void>;
    private getRpcUrl;
    validateActiveWallet(expectedAddress: string): Promise<void>;
    getActiveAccountAddress(): Promise<string | undefined>;
    getViemAccount({ accountAddress, }: {
        accountAddress: string;
    }): Promise<LocalAccount>;
    getWalletClient(chainId?: string): WalletClient<Transport, ViemChain, Account> | undefined;
    signMessage(message: string): Promise<Hex>;
    signMessageWithContext({ message, context, }: {
        message: string;
        context: SignMessageContext;
    }): Promise<string>;
    getSigner(): Promise<any>;
    getWalletClientByAddress({ accountAddress, }: {
        accountAddress: string;
    }): WalletClient<Transport, ViemChain, Account> | undefined;
    exportClientKeyshares({ accountAddress, password, }: {
        accountAddress: string;
        password?: string;
    }): Promise<void>;
    backupKeySharesToGoogleDrive({ accountAddress, password, }: {
        accountAddress: string;
        password?: string;
    }): Promise<void>;
    refreshWalletAccountShares({ accountAddress, password, }: {
        accountAddress: string;
        password?: string;
    }): Promise<void>;
    reshareWalletAccountShares({ accountAddress, password, thresholdSignatureScheme, }: {
        accountAddress: string;
        password?: string;
        thresholdSignatureScheme: string;
    }): Promise<void>;
    updatePassword({ accountAddress, existingPassword, newPassword, }: {
        accountAddress: string;
        existingPassword: string;
        newPassword: string;
    }): Promise<void>;
    createUiTransaction(from: string): Promise<IUITransaction>;
    getConnectedAccounts(): Promise<string[]>;
    getAddress(): Promise<string>;
    signAuthorization(parameters: SignAuthorizationParametersWithoutPrivateKey, password?: string): Promise<SignAuthorizationReturnType>;
    isAtomicSupported(chainId?: number): Promise<boolean>;
    isPaymasterServiceSupported(chainId?: number): Promise<boolean>;
    isSignAuthorizationSupported(): boolean;
    endSession(): Promise<void>;
}
export {};
