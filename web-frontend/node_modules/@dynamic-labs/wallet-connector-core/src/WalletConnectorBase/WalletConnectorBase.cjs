'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var EventEmitter = require('eventemitter3');
var utils = require('@dynamic-labs/utils');
var walletConnectorEvents = require('../events/walletConnectorEvents.cjs');
var logger = require('../utils/logger.cjs');
var isSameAddress = require('../utils/isSameAddress/isSameAddress.cjs');
var getMobileExperience = require('../utils/getMobileExperience/getMobileExperience.cjs');
var getWalletMetadataFromWalletBook = require('../utils/getWalletMetadataFromWalletBook/getWalletMetadataFromWalletBook.cjs');
var isConnectorMethodSupported = require('../utils/isConnectorMethodSupported/isConnectorMethodSupported.cjs');
require('@dynamic-labs/wallet-book');
require('@dynamic-labs/sdk-api-core');
var WalletBookSingleton = require('../WalletBookSingleton/WalletBookSingleton.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

/* eslint-disable @typescript-eslint/triple-slash-reference */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable prefer-arrow/prefer-arrow-functions */
/* eslint-disable @typescript-eslint/no-unused-vars */
var _WalletConnectorBase_registeredExtensions;
class WalletConnectorBase extends EventEmitter__default["default"] {
    createWallet(props) {
        const wallet = new this.ChainWallet(props);
        return wallet;
    }
    /**
     * We store the constructor props so that we can use them later on
     * in getMobileOrInstalledWallet which may fall back to a different class
     * but will need the original constructor props.
     * @param props - constructor props
     */
    constructor(props) {
        super();
        this.chainRpcProviders = undefined;
        this.isGlobalTransaction = false;
        _WalletConnectorBase_registeredExtensions.set(this, []);
        this.didSetup = false;
        /**
         * This flag corresponds to whether this wallet connector also requires its own email otp outside dynamic
         * @default false
         */
        this.requiresNonDynamicEmailOtp = false;
        /**
         * IF the wallet needs to be connected via a custodial service
         * such as Blocto, this will be true.
         * @default false
         */
        this.canConnectViaCustodialService = false;
        /**
         * If the wallet is not installed, and can be connected via a QR code,
         * this will be true.
         * @default false
         */
        this.canConnectViaQrCode = false;
        /**
         * Whether this connector can be connected via social login.
         * @default false
         */
        this.canConnectViaSocial = false;
        /**
         * Whether this connector can handle multiple connections
         * @default true
         */
        this.canHandleMultipleConnections = true;
        /**
         * Flag if connector/provider is available
         *
         * @default true
         */
        this.isAvailable = true;
        /**
         * If the wallet generated by a valid embedded wallet provider
         * For example: magic wallets
         * @default false
         */
        this.isEmbeddedWallet = false;
        /**
         * Flag if it is wallet Connect
         *
         * @default false
         */
        this.isWalletConnect = false;
        /**
         * Override key for the wallet (used for injected wallet linking)
         *
         * This is used to help group wallets by chain and should be set for multichain wallets.
         */
        this.overrideKey = undefined;
        /**
         * Additional resources to add to the message to be signed
         *
         * @default undefined
         */
        this.providerResources = undefined;
        /**
         * Requires switching network in the wallet itself
         * @default undefined
         */
        this.switchNetworkOnlyFromWallet = undefined;
        /**
         * Whether the connector has been initialized
         * @default true
         */
        this.isInitialized = true;
        this.constructorProps = props;
        this._walletBookInstance = WalletBookSingleton.WalletBookSingleton.getOrCreate(props.walletBook);
        this._metadata = props.metadata;
        this.walletConnectorEventsEmitter =
            this.constructorProps.walletConnectorEventsEmitter ||
                walletConnectorEvents.walletConnectorEvents;
        if (this.walletBook === undefined) {
            throw new Error('WalletConnectorBase was not called with super(props) and is missing wallet-book');
        }
    }
    extend(extension, settings) {
        if (_tslib.__classPrivateFieldGet(this, _WalletConnectorBase_registeredExtensions, "f").includes(extension.name)) {
            throw new Error(`You can only register a single extension of: ${extension.name}`);
        }
        if (extension.name === 'global-wallet-extension') {
            // only allow global wallet extension for evm embedded wallets
            if (!this.isEmbeddedWallet || !this.supportedChains.includes('EVM'))
                return;
        }
        _tslib.__classPrivateFieldGet(this, _WalletConnectorBase_registeredExtensions, "f").push(extension.name);
        extension.extend(this, settings !== null && settings !== void 0 ? settings : {});
    }
    /**
     * Add the event listeners for the wallet and connect
     * with event emitter.
     */
    initEventListener() {
        if (this.didSetup)
            return;
        this.didSetup = true;
        this.setupEventListeners();
    }
    get walletBook() {
        return this._walletBookInstance.walletBook;
    }
    filter() {
        return true;
    }
    get mobileExperience() {
        return getMobileExperience.getMobileExperience({
            mobileExperienceProp: this.constructorProps.mobileExperience,
            walletBook: this.walletBook,
            walletConnector: this,
            walletKey: this.key,
        });
    }
    /**
     * Prompt the user to choose accounts to connect (see behavior in MM)
     * @default Promise<[]>
     */
    chooseAccountsToConnect() {
        return Promise.resolve([]);
    }
    connect() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.getAddress();
        });
    }
    /**
     * Generic function to close the wallet connection
     *
     * Originally implemented for WalletConnect, but it is used
     * for anything that needs to be "logged out" or cleaned up.
     *
     * Remember to call teardownEventListeners() in the implementation.
     *
     * @default Promise<undefined>
     */
    endSession() {
        return Promise.resolve();
    }
    /**
     * Gets the public address of the wallet
     *
     * @default Promise<undefined>
     */
    getAddress(opts) {
        return Promise.resolve(undefined);
    }
    /**
     * Parses a public address to ensure it follows a correct format.
     *
     * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
     *
     * @default string
     */
    parseAddress(address) {
        return address;
    }
    /**
     * Whether this wallet connector is targeting a testnet.
     * So far only supported for EVM connectors.
     *
     * @default Promise<false>
     */
    isTestnet() {
        return Promise.resolve(false);
    }
    /**
     * Gets the additional addresses of the wallet, given the main address
     *
     * @default Promise<[]>
     */
    getAdditionalAddresses(mainAddress) {
        return Promise.resolve([]);
    }
    /**
     * Sets the additional addresses of the wallet, given the main address
     *
     * @default Promise<void>
     */
    setAdditionalAddresses(mainAddress, additionalAddresses) {
        return Promise.resolve();
    }
    /**
     * Gets the balance of the wallet
     *
     * @default Promise<undefined>
     */
    getBalance(address) {
        return Promise.resolve(undefined);
    }
    /**
     * Get the address silently
     *
     * This is used to check which accounts are already connected and
     * should silently attempt to reconnect. If the user refreshes their
     * page and gets disconnected, there's likely an issue with the
     * implementation of this method.
     *
     * @default Promise<[]>
     */
    getConnectedAccounts() {
        return Promise.resolve([]);
    }
    /**
     * Gets the deep link of the wallet
     *
     * @default undefined
     */
    getDeepLink() {
        return undefined;
    }
    getNetwork() {
        return Promise.resolve(undefined);
    }
    /**
     * Gets current network of connected wallet
     *
     * @default Promise<undefined>
     */
    getNameService(address) {
        return Promise.resolve(undefined);
    }
    getPublicClient() {
        return Promise.resolve(undefined);
    }
    getSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    getSigner() {
        return Promise.resolve(undefined);
    }
    getWalletClient(chainId) {
        return undefined;
    }
    /**
     * Initialize the wallet connector with any async operations
     *
     * @default Promise<void>
     */
    init() {
        return Promise.resolve();
    }
    /**
     * Check if the wallet is installed on the browser
     *
     * @default false
     */
    isInstalledOnBrowser() {
        return false;
    }
    /**
     * Override key or the normalized wallet name if needed
     */
    get key() {
        return this.overrideKey || this.name.replace(/\W/g, '').toLowerCase();
    }
    get metadata() {
        var _a;
        if (!this._metadata) {
            this._metadata = getWalletMetadataFromWalletBook.getWalletMetadataFromWalletBook({
                walletBook: this.walletBook,
                walletKey: this.key,
            });
        }
        return (_a = this._metadata) !== null && _a !== void 0 ? _a : { icon: '', id: this.key, name: this.name };
    }
    /**
     * Whether the wallet connector should fall back to a different wallet connector
     * This is called after the object is instantiated, so it can't be a static property
     * and will return the appropriate instance of the wallet connector
     * @returns WalletConnector
     * @default this
     */
    getMobileOrInstalledWallet() {
        return this;
    }
    /**
     * In most cases this is an alias for `signMessage`
     *
     * @default Promise<undefined>
     */
    proveOwnership(address, messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            return this.signMessage(messageToSign);
        });
    }
    /**
     * Set up event listeners for the wallet
     *
     * @default void
     */
    setupEventListeners() {
        return;
    }
    /**
     * Sign a message
     *
     * @default Promise<undefined>
     */
    signMessage(messageToSign, options) {
        return Promise.resolve(undefined);
    }
    /**
     * Returns the array of block explorer URLs available for the current network
     */
    getBlockExplorerUrlsForCurrentNetwork() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    /**
     * Whether the wallet supports network switching
     *
     * @default false
     */
    supportsNetworkSwitching() {
        return false;
    }
    switchNetwork({ networkName, networkChainId, }) {
        return Promise.resolve(undefined);
    }
    /**
     * Tear down event listeners for the wallet
     * @default void
     */
    teardownEventListeners() {
        return;
    }
    /**
     * Receive the user verified credentials
     */
    setVerifiedCredentials(verifiedCredentials) {
        return;
    }
    /**
     * Whether the wallet allow for getting the address in the
     * current chain.
     * This is used for multi chain wallets.
     * @default true
     */
    canGetChainAddress() {
        return true;
    }
    /**
     * Prompts the user to make expected wallet active
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
     * otherwise rejects with an error.
     */
    handleWalletNotActive(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ activeAddress, expectedAddress, reconnectedAddress, }) {
            logger.logger.debug('validateActiveWallet - wallet is not active', {
                activeAddress,
                expectedAddress,
                reconnectedAddress,
            });
            const currentActiveAddress = activeAddress || reconnectedAddress || '';
            const walletUiUtils = this.constructorProps
                .walletUiUtils;
            if (!walletUiUtils) {
                throw new utils.WalletAddressMismatchError(`Wallet ${expectedAddress !== null && expectedAddress !== void 0 ? expectedAddress : ''} is not currently active in ${this.name || this.key}.`, {
                    activeAddress: currentActiveAddress,
                    expectedAddress,
                    walletName: this.name || this.key,
                });
            }
            return walletUiUtils.syncWallet({
                activeAddress: currentActiveAddress,
                expectedAddress,
                walletConnector: this,
            });
        });
    }
    /**
     * Validates if the address is connected and active in the wallet app
     *
     * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
     * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
     * otherwise rejects with an error.
     */
    validateActiveWallet(expectedAddress) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            logger.logger.debug('validateActiveWallet - validating wallet', expectedAddress);
            const canFetchConnectedAccounts = isConnectorMethodSupported.isConnectorMethodSupported(this, 'getConnectedAccounts', 'desktop');
            logger.logger.debug('validateActiveWallet - getting connected accounts', {
                canFetchConnectedAccounts,
            });
            const [activeAddress] = canFetchConnectedAccounts
                ? yield this.getConnectedAccounts()
                : [];
            const isWalletActive = activeAddress &&
                isSameAddress.isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (isWalletActive) {
                logger.logger.debug('validateActiveWallet - wallet is active');
                return;
            }
            logger.logger.debug('validateActiveWallet - trying to reconnect wallet...');
            const getReconnectedAddress = () => _tslib.__awaiter(this, void 0, void 0, function* () {
                if (!this.canHandleMultipleConnections || !this.canGetChainAddress()) {
                    return undefined;
                }
                return this.getAddress().catch((err) => {
                    logger.logger.debug('validateActiveWallet - error getting address', err);
                    return undefined;
                });
            });
            //  not possible to auto-reconnect walletconnect
            const reconnectedAddress = yield getReconnectedAddress();
            if (reconnectedAddress &&
                isSameAddress.isSameAddress(reconnectedAddress, expectedAddress, this.connectedChain)) {
                logger.logger.debug('validateActiveWallet - wallet reconnected successfuly');
                return;
            }
            return this.handleWalletNotActive({
                activeAddress,
                expectedAddress,
                reconnectedAddress,
            });
        });
    }
    /**
     * Get the enabled networks for the wallet.
     *
     * These are normally set in the opts prop of the wallet connector constructor. The
     * network values are passed from project settings and can require an update to
     * [getWalletConnectorConstructorOptions] for new chains.
     *
     * @returns {GenericNetwork[]} The enabled networks
     */
    getEnabledNetworks() {
        return [];
    }
    /**
     * Retry the deeplink connection for mobile wallets
     * @default Promise<void>
     */
    retryDeeplinkConnection() {
        return;
    }
    /**
     * Check if retryDeeplinkConnection has been implemented by a subclass
     */
    hasRetryDeeplinkConnection() {
        return (this.retryDeeplinkConnection !==
            WalletConnectorBase.prototype.retryDeeplinkConnection);
    }
    /**
     * Open the inAppBrowser if required
     * @returns True if the inAppBrowser was opened, false otherwise.
     */
    openInAppBrowserIfRequired() {
        var _a;
        if (this.isInstalledOnBrowser() ||
            !utils.isMobile() ||
            !((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl) ||
            this.mobileExperience === 'redirect') {
            return false;
        }
        const inAppBrowserCompiledTemplate = utils.template(this.metadata.inAppBrowserUrl);
        const { href } = utils.PlatformService.getUrl();
        const deepLink = inAppBrowserCompiledTemplate({
            encodedDappURI: encodeURIComponent(href),
        });
        utils.PlatformService.openURL(deepLink);
        return true;
    }
}
_WalletConnectorBase_registeredExtensions = new WeakMap();

exports.WalletConnectorBase = WalletConnectorBase;
