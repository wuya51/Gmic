'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { getAddress, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { parseEvmNetworks, retryableFn, FALLBACK_UNDEFINED, DynamicError, UserRejectedRequestError, isMobile } from '@dynamic-labs/utils';
import { WalletConnectorBase, logger } from '@dynamic-labs/wallet-connector-core';
import '../utils/logger.js';
import '../utils/viem/estimateL1Fee/opStack/estimateL1Fee.js';
import { chainsMap } from '../utils/viem/chainsMap/chainsMap.js';
import { createViemUiTransaction } from '../utils/viem/createViemUiTransaction/createViemUiTransaction.js';
import { getOrMapViemChain } from '../utils/viem/getOrMapViemChain/getOrMapViemChain.js';
import { hasAtomicStatusCapability } from '../utils/viem/hasAtomicStatusCapability/hasAtomicStatusCapability.js';
import { hasPaymasterServiceCapability } from '../utils/viem/hasPaymasterServiceCapability/hasPaymasterServiceCapability.js';
import { findEvmNetwork } from '../utils/findEvmNetwork/findEvmNetwork.js';
import { getNameservice } from '../utils/getNameservice/getNameservice.js';
import { EthereumWallet } from '../wallet/EthereumWallet.js';

class EthereumWalletConnector extends WalletConnectorBase {
    constructor(props) {
        var _a, _b, _c;
        super(props);
        this.supportedChains = ['EVM', 'ETH'];
        this.connectedChain = 'EVM';
        this.ChainWallet = EthereumWallet;
        this.evmNetworkRpcMap = () => this.evmNetworks.reduce((acc, network) => {
            var _a;
            [acc[network.chainId]] = ((_a = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a.length)
                ? network.privateCustomerRpcUrls
                : network.rpcUrls;
            return acc;
        }, {});
        this.walletUiUtils = props.walletUiUtils;
        this.evmNetworks = parseEvmNetworks(props.evmNetworks);
        this.providersConfig = (_a = props.providersConfig) !== null && _a !== void 0 ? _a : {};
        this.chainRpcProviders = props.chainRpcProviders;
        (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.registerEvmProviders((_c = this.providersConfig) !== null && _c !== void 0 ? _c : {});
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const networkId = (_a = (yield this.getNetwork())) !== null && _a !== void 0 ? _a : 1;
            if (this.evmNetworks.length === 0) {
                return undefined;
            }
            const configurations = {
                cosmos: [],
                evm: this.evmNetworks,
                solana: [],
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!this.supportsNetworkSwitching || !provider) {
                return Promise.resolve(undefined);
            }
            const chainId = yield retryableFn(provider.getChainId, {
                fallbackValue: FALLBACK_UNDEFINED,
                /**
                 * The timeout is set to 1 second because the getChainId method
                 * takes around 500ms to resolve on Brave. If the timeout is not set
                 * it will use 100ms by default and the method will fail.
                 * QNTM-815
                 */
                timeoutMs: 1000,
            });
            this.setActiveChain(chainsMap[chainId]);
            return chainId;
        });
    }
    getNameService(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcProvider = yield this.getPublicClient();
            if (!rpcProvider) {
                return;
            }
            return getNameservice({ address, rpcProvider });
        });
    }
    isTestnet() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const chain = (_a = (yield this.getPublicClient())) === null || _a === void 0 ? void 0 : _a.chain;
            const evmNetwork = this.evmNetworks.find((n) => n.chainId === (chain === null || chain === void 0 ? void 0 : chain.id));
            logger.logVerboseTroubleshootingMessage('[EthereumWalletConnector] isTestnet', {
                evmNetwork,
                viemChain: chain,
            });
            // this is a workaround to an issue with Hyperliquid Mainnet, where its chainId
            // conflicts with another chain in viem, so viem thinks it's a testnet, but it's not
            // we should use the value coming from our api and only fallback to viem if it's not set
            if ((evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.isTestnet) !== undefined) {
                return evmNetwork.isTestnet;
            }
            return (_b = chain === null || chain === void 0 ? void 0 : chain.testnet) !== null && _b !== void 0 ? _b : false;
        });
    }
    parseAddress(address) {
        try {
            // Ensures the address follows the EIP55 format.
            // see: https://eips.ethereum.org/EIPS/eip-55
            return getAddress(address);
        }
        catch (err) {
            logger.debug(`Failed to parse EVM address into EIP55 format: error getting checksum, returning default ${address}`, err);
        }
        return address;
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWalletClient();
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getPublicClient();
            const result = yield (client === null || client === void 0 ? void 0 : client.getBalance({
                address: address,
            }));
            if (!result && result !== BigInt(0))
                return;
            return formatEther(result);
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkName, networkChainId, }) {
            const network = findEvmNetwork({
                chainId: networkChainId,
                name: networkName,
                networks: this.evmNetworks,
            });
            if (!network) {
                throw new DynamicError(`Could not find network mapping for chain ${networkName ? networkName : networkChainId}`);
            }
            if (!this.supportsNetworkSwitching()) {
                throw new DynamicError('Network switching is not supported');
            }
            logger.logVerboseTroubleshootingMessage('[EthereumWalletConnector] switchNetwork', { network, networkChainId, networkName });
            const provider = this.getWalletClient();
            logger.logVerboseTroubleshootingMessage('[EthereumWalletConnector] switchNetwork - got provider', { provider });
            if (!provider) {
                throw new DynamicError('Provider not found');
            }
            return this.providerSwitchNetwork({ network, provider });
        });
    }
    chooseAccountsToConnect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const provider = this.getWalletClient();
            if (!provider)
                return [];
            try {
                const result = yield provider.requestPermissions({ eth_accounts: {} });
                logger.debug('chooseAccountsToConnect - requestPermissions result', result);
                // this should return the connected addresses for MM
                const addresses = (_c = (_b = (_a = result === null || result === void 0 ? void 0 : result.find((r) => r.parentCapability === 'eth_accounts')) === null || _a === void 0 ? void 0 : _a.caveats) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.value;
                if (typeof addresses === 'string') {
                    return [addresses];
                }
                if (Array.isArray(addresses)) {
                    return addresses;
                }
                return [];
            }
            catch (error) {
                logger.debug('chooseAccountsToConnect - error', error);
                // might fail if method is not supported, but just throw if user rejected
                if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {
                    throw new UserRejectedRequestError();
                }
            }
            return [];
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!provider)
                return [];
            const addresses = yield retryableFn(provider.getAddresses, {
                fallbackValue: [],
                timeoutMs: 500,
            });
            if (addresses.length) {
                this.setActiveAccount(addresses[0]);
            }
            return addresses;
        });
    }
    providerSwitchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b, _c, _d, _e, _f;
            const { chainId } = network;
            const currentNetworkId = yield this.getNetwork();
            if (currentNetworkId && currentNetworkId === chainId) {
                return;
            }
            try {
                if (!this.supportsNetworkSwitching()) {
                    throw new DynamicError('Network switching is not supported');
                }
                const viemChain = getOrMapViemChain(network);
                yield provider.switchChain({ id: viemChain.id });
                if (this.key === 'magiceden') {
                    const newChainId = yield provider.getChainId();
                    this.emit('chainChange', { chain: newChainId.toString() });
                }
                else {
                    this.setActiveChain(viemChain);
                    this.emit('chainChange', { chain: viemChain.id.toString() });
                }
            }
            catch (error) {
                if ((_b = error.details) === null || _b === void 0 ? void 0 : _b.includes('"wallet_switchEthereumChain" not implemented')) {
                    throw new DynamicError('Network switching is not available at this time. The user should manually switch network in their wallet');
                }
                // we need to check for unrecognized chain error first because it also contains 'rejected' in message
                if (error.code === 4902 ||
                    ((_c = error.message) === null || _c === void 0 ? void 0 : _c.includes('Unrecognized chain')) ||
                    // https://github.com/MetaMask/metamask-mobile/issues/3312#issuecomment-1065923294
                    ((_e = (_d = error.data) === null || _d === void 0 ? void 0 : _d.orginalError) === null || _e === void 0 ? void 0 : _e.code) === 4902) {
                    // error code indicates the chain has not been added yet
                    // https://docs.metamask.io/guide/rpc-api.html#usage-with-wallet-switchethereumchain
                    return this.providerAddNetwork({ network, provider });
                }
                else if (((_f = error.message) === null || _f === void 0 ? void 0 : _f.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to switch network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    providerAddNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b;
            try {
                if (isMobile()) {
                    yield this.walletUiUtils.addNetwork({
                        handler: () => provider.addChain({ chain: getOrMapViemChain(network) }),
                        network,
                        walletConnector: this,
                    });
                }
                else {
                    yield provider.addChain({ chain: getOrMapViemChain(network) });
                }
            }
            catch (error) {
                if (((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to add network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    setActiveAccount(account) {
        this.activeAccount = account ? toAccount(account) : undefined;
    }
    getActiveAccount() {
        return this.activeAccount;
    }
    setActiveChain(chain) {
        this.activeChain = chain;
    }
    getActiveChain() {
        return this.activeChain;
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = yield this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return createViemUiTransaction({
                from,
                publicClient,
                walletClient,
            });
        });
    }
    confirmTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicClient = yield this.getPublicClient();
            if (!publicClient) {
                throw new DynamicError('No public client available');
            }
            // The number of confirmations (blocks that have passed) to wait before resolving.
            const confirmations = 3;
            return publicClient.waitForTransactionReceipt({
                confirmations,
                hash: txHash,
            });
        });
    }
    getBlockExplorerUrlsForCurrentNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const currentNetwork = yield this.getNetwork();
            return ((_b = (_a = this.evmNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a === void 0 ? void 0 : _a.blockExplorerUrls) !== null && _b !== void 0 ? _b : []);
        });
    }
    getEnabledNetworks() {
        return this.evmNetworks;
    }
    isAtomicSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletClient = yield this.getWalletClient();
            if (!walletClient) {
                return false;
            }
            const capabilities = yield walletClient.getCapabilities();
            const chainIdToCheck = chainId !== null && chainId !== void 0 ? chainId : (yield walletClient.getChainId());
            logger.debug('[EthereumWalletConnector] isAtomicSupported', {
                capabilities,
                chainId: chainIdToCheck,
            });
            return hasAtomicStatusCapability(capabilities, chainIdToCheck);
        });
    }
    isPaymasterServiceSupported(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletClient = yield this.getWalletClient();
            if (!walletClient) {
                return false;
            }
            const capabilities = yield walletClient.getCapabilities();
            const chainIdToCheck = chainId !== null && chainId !== void 0 ? chainId : (yield walletClient.getChainId());
            logger.debug('[EthereumWalletConnector] isPaymasterServiceSupported', {
                capabilities,
                chainId: chainIdToCheck,
            });
            return hasPaymasterServiceCapability(capabilities, chainIdToCheck);
        });
    }
    /**
     * Whether the wallet supports sign authorization for eip-7702.
     *
     * @returns {boolean} Whether the wallet supports sign authorization
     */
    isSignAuthorizationSupported() {
        return false;
    }
}

export { EthereumWalletConnector };
