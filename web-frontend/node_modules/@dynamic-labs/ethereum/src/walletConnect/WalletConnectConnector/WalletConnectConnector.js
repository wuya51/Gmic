'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { createWalletClient, custom } from 'viem';
import { toAccount } from 'viem/accounts';
import { EthereumWalletConnector, chainsMap, normalizeRpcError } from '@dynamic-labs/ethereum-core';
import { StorageService, parseIntSafe, DynamicError, isMobile, PlatformService } from '@dynamic-labs/utils';
import { logger, getDeepLink, isSameAddress } from '@dynamic-labs/wallet-connector-core';
import { WalletConnectProvider } from '../WalletConnectProvider/WalletConnectProvider.js';

const WC_CURRENT_CHAIN_KEY = 'dynamic-wc2-current-chain';
class WalletConnectConnector extends EthereumWalletConnector {
    constructor(opts) {
        super(opts);
        this.canConnectViaQrCode = true;
        this.isWalletConnect = true;
        this.canHandleMultipleConnections = false;
        this.name = opts.walletName;
        this.deepLinkPreference = opts.deepLinkPreference || 'native';
        const storedChainId = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
        if (storedChainId) {
            this.currentChainId = parseIntSafe(storedChainId);
        }
        if (!opts.projectId) {
            throw new DynamicError('WalletConnect project ID is required');
        }
        // set provider props generic to all wallets
        WalletConnectProvider.projectId = opts.projectId;
        WalletConnectProvider.enabledNetworks = opts.evmNetworks;
        WalletConnectProvider.preferredChains =
            opts.walletConnectPreferredChains || [];
        WalletConnectProvider.evmNetworkRpcMap = this.evmNetworkRpcMap();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.logVerboseTroubleshootingMessage('[WalletConnect] init called', {
                isInitialized: WalletConnectProvider.isInitialized,
                isInitializing: WalletConnectProvider.isInitializing,
            });
            // we should only init the provider once as soon as possible
            // the connection is established when a wallet is selected (with getAddress)
            if (WalletConnectProvider.isInitialized ||
                WalletConnectProvider.isInitializing) {
                logger.debug('[WalletConnect] init - already initialized or initializing - skipping');
                return;
            }
            logger.debug('[WalletConnect] init');
            this.walletConnectorEventsEmitter.emit('connectorInitStarted', 'walletconnect');
            try {
                yield WalletConnectProvider.init();
            }
            catch (error) {
                logger.error('[WalletConnect] init - error', error);
                throw new DynamicError('WalletConnectProvider failed to initialize');
            }
            this.setupWCEventListeners();
            this.walletConnectorEventsEmitter.emit('connectorInitCompleted', 'walletconnect');
        });
    }
    setupWCEventListeners() {
        logger.debug('[WalletConnect] setupWCEventListeners');
        WalletConnectProvider.teardownEventListeners();
        WalletConnectProvider.setupEventListeners({
            onAccountChanged: (account) => {
                logger.debug('[WalletConnect] onAccountChanged', { account });
                this.emit('accountChange', { accounts: [account] });
            },
            onChainChanged: (chainId) => {
                logger.debug('[WalletConnect] onChainChange', { chainId });
                if (chainId === this.currentChainId) {
                    logger.debug(`[WalletConnect] onChainChange - ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
                    return;
                }
                this.currentChainId = chainId;
                this.emit('chainChange', { chain: String(chainId) });
            },
            onDisconnect: () => {
                logger.debug('[WalletConnect] onDisconnect');
                this.endSession();
                this.emit('disconnect');
            },
        });
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[WalletConnect] endSession');
            this.currentChainId = undefined;
            yield WalletConnectProvider.disconnect();
        });
    }
    getAddress(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            logger.debug('[WalletConnect] getAddress', opts);
            logger.logVerboseTroubleshootingMessage('[WalletConnectConnector] getAddress', {
                inAppBrowserUrl: (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.inAppBrowserUrl,
                isMobile: isMobile(),
                mobileExperience: this.mobileExperience,
            });
            const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
            if (didOpenInAppBrowser) {
                return;
            }
            const provider = yield WalletConnectProvider.awaitAndGetProvider();
            logger.debug('[WalletConnect] getAddress - connecting to WalletConnect', {
                provider,
            });
            const addresses = yield WalletConnectProvider.connect({
                connectionOpts: opts,
                deepLinkPreference: this.deepLinkPreference,
                deepLinks: this.metadata.deepLinks,
            });
            logger.debug('[WalletConnect] getAddress - connection result', addresses);
            const address = addresses === null || addresses === void 0 ? void 0 : addresses[0];
            return address;
        });
    }
    getWalletClient(chainId) {
        logger.logVerboseTroubleshootingMessage('[WalletConnect] getWalletClient was called - chainId', chainId);
        const provider = WalletConnectProvider.getProvider();
        if (!provider) {
            logger.debug('[WalletConnect] getWalletClient - provider is not initialized');
            throw new DynamicError('WalletConnectProvider is not initialized');
        }
        const walletClient = createWalletClient({
            account: this.getActiveAccount(),
            chain: chainsMap[chainId !== null && chainId !== void 0 ? chainId : String(this.currentChainId)],
            transport: custom({
                request: (args) => {
                    this.deepLinkIfApplicable(args.method);
                    return provider.request(args).catch(normalizeRpcError);
                },
            }, this.providersConfig.httpTransportConfig),
        });
        return walletClient;
    }
    deepLinkIfApplicable(method) {
        const methodsThatRequireDeepLink = [
            'personal_sign',
            'eth_sendTransaction',
            'eth_signTypedData_v4',
        ];
        const deepLink = this.getDeepLink();
        if (isMobile() && deepLink && methodsThatRequireDeepLink.includes(method)) {
            PlatformService.openURL(deepLink);
        }
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.logVerboseTroubleshootingMessage('[WalletConnect] signMessage', messageToSign);
            const activeAccount = this.getActiveAccount();
            logger.logVerboseTroubleshootingMessage('[WalletConnect] signMessage - activeAccount', activeAccount);
            if (!activeAccount) {
                return;
            }
            const walletClient = yield this.getWalletClient();
            return walletClient.signMessage({
                account: activeAccount,
                message: messageToSign,
            });
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const activeAccount = this.getActiveAccount();
            logger.logVerboseTroubleshootingMessage('[WalletConnect] getConnectedAccounts - activeAccount', activeAccount);
            return activeAccount ? [activeAccount.address] : [];
        });
    }
    getActiveAccount() {
        var _a;
        const provider = WalletConnectProvider.getProvider();
        const connectedAccount = (_a = provider === null || provider === void 0 ? void 0 : provider.accounts) === null || _a === void 0 ? void 0 : _a[0];
        logger.logVerboseTroubleshootingMessage('[WalletConnect] getActiveAccount - connectedAccount', connectedAccount);
        if (!connectedAccount) {
            return undefined;
        }
        return toAccount(connectedAccount);
    }
    get currentChainId() {
        const lsCurrentChain = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
        try {
            return lsCurrentChain ? parseIntSafe(lsCurrentChain) : undefined;
        }
        catch (e) {
            logger.debug('[WalletConnect] getCurrentChainId - error', e);
            return undefined;
        }
    }
    set currentChainId(value) {
        if (value) {
            StorageService.setItem(WC_CURRENT_CHAIN_KEY, value.toString());
        }
        else {
            StorageService.removeItem(WC_CURRENT_CHAIN_KEY);
        }
    }
    getActiveChain() {
        if (!this.currentChainId) {
            return undefined;
        }
        return chainsMap[this.currentChainId];
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.logVerboseTroubleshootingMessage('[WalletConnect] getNetwork');
            const provider = yield WalletConnectProvider.awaitAndGetProvider();
            if (provider === null || provider === void 0 ? void 0 : provider.chainId) {
                const network = provider.chainId;
                this.currentChainId = network;
                logger.logVerboseTroubleshootingMessage('[WalletConnect] getNetwork - provider network', network);
                return network;
            }
            logger.logVerboseTroubleshootingMessage('[WalletConnect] getNetwork - no provider found, returning current chain id', {
                currentChainId: this.currentChainId,
            });
            return this.currentChainId;
        });
    }
    providerSwitchNetwork(_a) {
        const _super = Object.create(null, {
            providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
        });
        return __awaiter(this, arguments, void 0, function* ({ network, }) {
            logger.logVerboseTroubleshootingMessage('[WalletConnect] providerSwitchNetwork - network', {
                network,
                switchNetworkOnlyFromWallet: this.switchNetworkOnlyFromWallet,
            });
            yield this.reconnectIfRequired();
            const currentNetworkId = yield this.getNetwork();
            logger.logVerboseTroubleshootingMessage('[WalletConnect] providerSwitchNetwork - currentNetworkId', currentNetworkId);
            if (currentNetworkId && currentNetworkId === network.chainId) {
                return;
            }
            if (this.switchNetworkOnlyFromWallet) {
                throw new DynamicError('Network switching is only supported through the wallet');
            }
            const walletClient = yield this.getWalletClient();
            logger.logVerboseTroubleshootingMessage('[WalletConnect] providerSwitchNetwork - will switch network');
            yield _super.providerSwitchNetwork.call(this, { network, provider: walletClient });
            this.currentChainId = network.chainId;
            logger.logVerboseTroubleshootingMessage('[WalletConnect] providerSwitchNetwork - switched network', network.chainId);
            this.emit('chainChange', { chain: String(network.chainId) });
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    getSupportedNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const enabledNetworks = this.evmNetworks.map((network) => network.chainId.toString());
            const provider = yield WalletConnectProvider.awaitAndGetProvider();
            // if there is no session to determine supported networks, we need to return the enabled networks
            if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
                return enabledNetworks;
            }
            const sessionNetworks = [];
            // Some wallet (i.e ZenGo) use namespaces.account to list supported chains
            // while others use keys within the namespaces object
            Object.keys(provider === null || provider === void 0 ? void 0 : provider.session.namespaces).forEach((key) => {
                if (key.startsWith('eip155:')) {
                    sessionNetworks.push(key.split(':')[1]);
                }
            });
            (_a = provider === null || provider === void 0 ? void 0 : provider.session.namespaces.eip155) === null || _a === void 0 ? void 0 : _a.accounts.forEach((account) => sessionNetworks.push(account.split(':')[1]));
            return sessionNetworks.length ? sessionNetworks : enabledNetworks;
        });
    }
    getDeepLink() {
        var _a;
        const provider = WalletConnectProvider.getProvider();
        logger.debug('[WalletConnect] getDeepLink', {
            hasSession: Boolean(provider === null || provider === void 0 ? void 0 : provider.session),
            topic: (_a = provider === null || provider === void 0 ? void 0 : provider.session) === null || _a === void 0 ? void 0 : _a.topic,
            uri: provider === null || provider === void 0 ? void 0 : provider.signer.uri,
        });
        if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
            return;
        }
        const deepLink = getDeepLink({
            deepLinks: this.metadata.deepLinks,
            mode: 'regular',
            preference: this.deepLinkPreference,
            uri: provider.signer.uri,
        });
        logger.logVerboseTroubleshootingMessage('[WalletConnect] getDeepLink - deepLink', deepLink);
        if (!deepLink) {
            return;
        }
        // we need to include the session topic here because it helps the wallet
        // auto redirect back to the dapp after signing
        return `${deepLink}?sessionTopic=${provider.session.topic}`;
    }
    getConnectionUri() {
        return WalletConnectProvider.getConnectionUri();
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[WalletConnect] validateActiveWallet - validating wallet', expectedAddress);
            const [activeAddress] = yield this.getConnectedAccounts();
            const isWalletActive = activeAddress &&
                isSameAddress(activeAddress, expectedAddress, this.connectedChain);
            if (isWalletActive) {
                logger.debug('[WalletConnect] validateActiveWallet - wallet is active');
                return;
            }
            // if the was an existing session, we need to end it before prompting the user to connect
            // with the wallet they want to use
            if (activeAddress) {
                logger.debug('[WalletConnect] validateActiveWallet - ending existing WC session');
                yield this.endSession();
            }
            logger.debug('[WalletConnect] validateActiveWallet - trying to reconnect WalletConnect wallet...');
            return this.handleWalletNotActive({
                activeAddress,
                expectedAddress,
            });
        });
    }
    reconnectIfRequired() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const wcProvider = yield WalletConnectProvider.awaitAndGetProvider();
            if (wcProvider === null || wcProvider === void 0 ? void 0 : wcProvider.session) {
                return;
            }
            // we don't really need the address in the WC reconnect view
            yield this.handleWalletNotActive({
                expectedAddress: (_b = (_a = this.getActiveAccount()) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '',
            });
        });
    }
}

export { WalletConnectConnector };
