'use strict';

var eventemitter3 = require('eventemitter3');
var ws = require('ws');
var forwardMpcShared = require('@dynamic-labs-wallet/forward-mpc-shared');
var init = require('@evervault/wasm-attestation-bindings');
var sha2_js = require('@noble/hashes/sha2.js');
var utils_js = require('@noble/hashes/utils.js');
var fpTs = require('fp-ts');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var ws__namespace = /*#__PURE__*/_interopNamespace(ws);
var init__default = /*#__PURE__*/_interopDefault(init);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/attestation/constants.ts
var ATTESTATION_CONSTANTS = {
  // Maximum age of attestation document in milliseconds
  MAX_ATTESTATION_AGE: 5 * 60 * 1e3};
var NitroAttestationVerifier = class {
  static {
    __name(this, "NitroAttestationVerifier");
  }
  config;
  wasmInitialized = false;
  constructor(config) {
    this.config = {
      strictCertValidation: true,
      maxAge: ATTESTATION_CONSTANTS.MAX_ATTESTATION_AGE,
      ...config
    };
  }
  /**
  * Initialize WASM module if not already initialized
  */
  async ensureWasmInitialized() {
    if (!this.wasmInitialized) {
      try {
        await init__default.default();
        this.wasmInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize WASM module: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  /**
  * Verify an attestation document using Evervault WASM bindings
  * Accepts base64-encoded attestation document directly
  *
  * @param attestationDocBase64 - Base64-encoded attestation document
  * @param expectedChallenge - Expected challenge (ciphertext hash)
  * @param expectedNonce - Expected nonce (REQUIRED for security)
  */
  async verify(attestationDocBase64, expectedChallenge, expectedNonce) {
    try {
      await this.ensureWasmInitialized();
      const expectedPcrs = init.PCRs.empty();
      expectedPcrs.pcr8 = this.config.expectedPcr8;
      const isValid = init.validateAttestationDocPcrs(attestationDocBase64, [
        expectedPcrs
      ]);
      if (!isValid) {
        return {
          valid: false,
          errors: [
            "Attestation document PCR verification failed"
          ],
          timestamp: Date.now()
        };
      }
      if (expectedChallenge) {
        try {
          const userData = init.getUserData(attestationDocBase64);
          if (!userData) {
            return {
              valid: false,
              errors: [
                "No user data found in attestation document"
              ],
              timestamp: Date.now()
            };
          }
          const userDataString = new TextDecoder("utf-8").decode(userData);
          if (!userDataString.includes(expectedChallenge)) {
            return {
              valid: false,
              errors: [
                "Ciphertext hash verification failed - challenge not found in attestation user data"
              ],
              timestamp: Date.now()
            };
          }
        } catch (error) {
          return {
            valid: false,
            errors: [
              `Failed to extract or verify ciphertext hash: ${error instanceof Error ? error.message : String(error)}`
            ],
            timestamp: Date.now()
          };
        }
      }
      try {
        const extractedNonceRaw = init.getNonce(attestationDocBase64);
        if (!extractedNonceRaw) {
          return {
            valid: false,
            errors: [
              "No nonce found in attestation document"
            ],
            timestamp: Date.now()
          };
        }
        let extractedNonce;
        try {
          const nonceString = new TextDecoder().decode(extractedNonceRaw);
          if (typeof atob !== "undefined") {
            const binaryString = atob(nonceString);
            extractedNonce = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              extractedNonce[i] = binaryString.charCodeAt(i);
            }
          } else {
            const decodedBuffer = Buffer.from(nonceString, "base64");
            extractedNonce = new Uint8Array(decodedBuffer);
          }
        } catch (decodeError) {
          return {
            valid: false,
            errors: [
              `Failed to decode nonce from base64: ${decodeError instanceof Error ? decodeError.message : String(decodeError)}`
            ],
            timestamp: Date.now()
          };
        }
        if (extractedNonce.length !== expectedNonce.length) {
          return {
            valid: false,
            errors: [
              `Nonce length mismatch: expected ${expectedNonce.length} bytes, got ${extractedNonce.length} bytes`
            ],
            timestamp: Date.now()
          };
        }
        for (let i = 0; i < expectedNonce.length; i++) {
          if (extractedNonce[i] !== expectedNonce[i]) {
            return {
              valid: false,
              errors: [
                "Nonce verification failed - nonce mismatch"
              ],
              timestamp: Date.now()
            };
          }
        }
      } catch (error) {
        return {
          valid: false,
          errors: [
            `Failed to extract or verify nonce: ${error instanceof Error ? error.message : String(error)}`
          ],
          timestamp: Date.now()
        };
      }
      return {
        valid: true,
        errors: [],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        valid: false,
        errors: [
          `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`
        ],
        timestamp: Date.now()
      };
    }
  }
};
var isWindow = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined";
var WebSocketImpl = isWindow ? globalThis.WebSocket : ws__namespace.WebSocket;
var ForwardMPCClient = class extends eventemitter3.EventEmitter {
  static {
    __name(this, "ForwardMPCClient");
  }
  ws = null;
  url;
  options;
  attestationVerifier = null;
  isConnected = false;
  messageId = 0;
  pendingRequests = /* @__PURE__ */ new Map();
  sharedSecret = null;
  decapsulationKey = null;
  connectionId;
  handshakeNonce = null;
  constructor(url, options = {}) {
    super();
    this.url = url;
    this.connectionId = "";
    this.options = {
      reconnectAttempts: options.reconnectAttempts ?? 3,
      reconnectInterval: options.reconnectInterval ?? 1e3,
      connectionTimeout: options.connectionTimeout ?? 1e4,
      heartbeatInterval: options.heartbeatInterval ?? 3e4,
      attestationConfig: options.attestationConfig,
      attestationVerifier: options.attestationVerifier
    };
    if (options.attestationVerifier) {
      this.attestationVerifier = options.attestationVerifier;
    } else if (this.options.attestationConfig) {
      this.attestationVerifier = new NitroAttestationVerifier(this.options.attestationConfig);
    }
  }
  async connect() {
    return new Promise((resolve, reject) => {
      if (this.isConnected) {
        resolve();
        return;
      }
      const timeout = setTimeout(() => {
        reject(new Error("Connection timeout"));
      }, this.options.connectionTimeout);
      this.ws = new WebSocketImpl(this.url);
      if (isWindow) {
        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        };
        this.ws.onerror = (_error) => {
          clearTimeout(timeout);
          this.emit("error", new Error("WebSocket error"));
          reject(new Error("WebSocket error"));
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onclose = () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        };
      } else {
        this.ws.on("open", () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        });
        this.ws.on("error", (error) => {
          clearTimeout(timeout);
          this.emit("error", error);
          reject(error);
        });
        this.ws.on("message", (data) => {
          this.handleMessage(data.toString());
        });
        this.ws.on("close", () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        });
      }
    });
  }
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.cleanup();
  }
  cleanup() {
    for (const [, request] of this.pendingRequests) {
      clearTimeout(request.timeout);
      request.reject(new Error("Connection closed"));
    }
    this.pendingRequests.clear();
    if (this.sharedSecret) {
      this.sharedSecret.fill(0);
      this.sharedSecret = null;
    }
    if (this.decapsulationKey) {
      this.decapsulationKey.fill(0);
      this.decapsulationKey = null;
    }
    if (this.handshakeNonce) {
      this.handshakeNonce.fill(0);
      this.handshakeNonce = null;
    }
    this.connectionId = "";
  }
  /**
  * Ensures the WebSocket connection is active and handshake is completed.
  * Automatically connects and performs handshake if needed.
  * @returns Object containing the shared secret and connection ID
  * @throws Error if connection or handshake fails
  */
  async ensureWsConnection() {
    if (!this.isConnected || !this.ws) {
      await this.connect();
    }
    if (!this.sharedSecret || !this.connectionId) {
      await this.handshake();
    }
    if (!this.sharedSecret || !this.connectionId) {
      throw new Error("Failed to establish connection and handshake");
    }
    return {
      sharedSecret: this.sharedSecret,
      connectionId: this.connectionId
    };
  }
  handleMessage(data) {
    try {
      const parsed = JSON.parse(data);
      const requestId = parsed.requestId;
      if (requestId) {
        delete parsed.requestId;
      }
      const message = this.deserializeMessage(JSON.stringify(parsed));
      if (requestId && this.pendingRequests.has(requestId)) {
        const request = this.pendingRequests.get(requestId);
        this.pendingRequests.delete(requestId);
        clearTimeout(request.timeout);
        if (message.type === "error") {
          const errorMsg = message;
          request.reject(new Error(errorMsg.error.message));
        } else if (message.type.endsWith("_response")) {
          const responseData = message.getData ? message.getData() : message;
          if (responseData.error) {
            request.reject(new Error(responseData.error.message));
          } else {
            request.resolve(message);
          }
        } else {
          request.resolve(message);
        }
        return;
      }
      this.emit("message", message);
    } catch (error) {
      this.emit("error", new Error(`Failed to parse message: ${error}`));
    }
  }
  sendRequest(message) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.ws) {
        reject(new Error("Not connected"));
        return;
      }
      const requestId = `req_${++this.messageId}_${Date.now()}`;
      const messageWithId = message;
      messageWithId.requestId = requestId;
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error("Request timeout"));
      }, 3e4);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout
      });
      try {
        const serializedMessage = this.serializeMessage(messageWithId);
        this.ws.send(serializedMessage);
      } catch (error) {
        this.pendingRequests.delete(requestId);
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  serializeMessage(message) {
    try {
      if (message && typeof message.encode === "function") {
        const encoded = message.encode();
        if (message.requestId) {
          encoded.requestId = message.requestId;
        }
        return JSON.stringify(encoded);
      }
      return JSON.stringify(message);
    } catch (error) {
      throw new Error(`Failed to serialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  deserializeMessage(data) {
    try {
      const parsed = JSON.parse(data);
      if (!forwardMpcShared.messageRegistry) {
        throw new Error("messageRegistry is undefined");
      }
      if (typeof forwardMpcShared.messageRegistry.decode !== "function") {
        throw new Error("messageRegistry.decode is not a function");
      }
      const result = forwardMpcShared.messageRegistry.decode(parsed);
      if (fpTs.either.isLeft(result)) {
        return parsed;
      }
      return result.right;
    } catch (error) {
      throw new Error(`Failed to deserialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async handshake() {
    const { encapsulationKey, decapsulationKey } = forwardMpcShared.generateMlKem768Keypair();
    this.decapsulationKey = decapsulationKey;
    const nonceBytes = utils_js.randomBytes(32);
    this.handshakeNonce = nonceBytes;
    const request = new forwardMpcShared.HandshakeV1RequestMessage({
      challenge: encapsulationKey,
      nonce: nonceBytes
    });
    const response = await this.sendRequest(request);
    const responseData = response.getData();
    if (responseData.encapsulatedSharedSecret && responseData.connectionId && this.decapsulationKey) {
      this.connectionId = responseData.connectionId;
      const cipherText = utils_js.hexToBytes(responseData.encapsulatedSharedSecret);
      this.sharedSecret = forwardMpcShared.decapsulateMlKem768(this.decapsulationKey, cipherText);
    }
    if (this.attestationVerifier && responseData.attestationDoc && responseData.encapsulatedSharedSecret) {
      const cipherText = utils_js.hexToBytes(responseData.encapsulatedSharedSecret);
      this.verifyAttestationDocument(responseData.attestationDoc, cipherText).catch((error) => {
        this.emit("error", new Error(`Background attestation verification failed: ${error.message}`));
      });
    }
    return response;
  }
  async signMessage(params) {
    const { sharedSecret, connectionId } = await this.ensureWsConnection();
    let messageToSign;
    if (typeof params.message === "string") {
      const cleanHex = params.message.startsWith("0x") ? params.message.slice(2) : params.message;
      messageToSign = utils_js.hexToBytes(cleanHex);
    } else {
      messageToSign = params.message;
    }
    const encryptedKeyshare = await forwardMpcShared.encryptKeyshare(params.keyshare, sharedSecret, connectionId, params.signingAlgo);
    const request = new forwardMpcShared.SignMessageV1RequestMessage({
      relayDomain: params.relayDomain,
      signingAlgo: params.signingAlgo,
      hashAlgo: params.hashAlgo,
      derivationPath: params.derivationPath,
      tweak: params.tweak,
      keyshare: encryptedKeyshare,
      message: messageToSign,
      roomUuid: params.roomUuid
    });
    return this.sendRequest(request);
  }
  get connected() {
    return this.isConnected;
  }
  /**
  * Generate a unique connection ID
  */
  /**
  * Verify attestation document from handshake response
  * Uses base64-encoded attestation document directly
  */
  async verifyAttestationDocument(attestationDocBase64, cipherText) {
    if (!this.attestationVerifier) {
      return;
    }
    try {
      const challengeHash = sha2_js.sha256(cipherText);
      const expectedChallenge = Array.from(challengeHash).map((b) => b.toString(16).padStart(2, "0")).join("");
      if (!this.handshakeNonce) {
        throw new Error("Nonce not found - handshake may not have completed properly");
      }
      const result = await this.attestationVerifier.verify(attestationDocBase64, expectedChallenge, this.handshakeNonce);
      if (!result.valid) {
        const errorMsg = `Attestation verification failed: ${result.errors.join(", ")}`;
        this.emit("error", new Error(errorMsg));
        throw new Error(errorMsg);
      }
      this.emit("message", {
        type: "attestation-verified",
        timestamp: Date.now(),
        data: result
      });
    } catch (error) {
      const errorMsg = `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`;
      this.emit("error", new Error(errorMsg));
      throw new Error(errorMsg);
    }
  }
};

exports.ForwardMPCClient = ForwardMPCClient;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map