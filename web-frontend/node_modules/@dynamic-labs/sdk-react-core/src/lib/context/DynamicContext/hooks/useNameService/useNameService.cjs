'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../../_virtual/_tslib.cjs');
var React = require('react');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
require('react/jsx-runtime');
require('../../../ViewContext/ViewContext.cjs');
require('../../../../shared/logger.cjs');
require('@dynamic-labs/wallet-book');
require('@dynamic-labs/utils');
var localStorage = require('../../../../utils/constants/localStorage.cjs');
require('../../../../utils/constants/colors.cjs');
require('../../../../utils/constants/values.cjs');
require('@dynamic-labs/sdk-api-core');
var useLocalStorage = require('../../../../shared/utils/hooks/useLocalStorage/useLocalStorage.cjs');
require('../../../../shared/consts/index.cjs');
var getWalletVerifiedCredential = require('../../../../utils/functions/getWalletVerifiedCredential/getWalletVerifiedCredential.cjs');

const useNameService = ({ currentWallet, user }) => {
    const [connectedNameService, setConnectedNameService, removeConnectedNameService,] = useLocalStorage.useLocalStorage(localStorage.CONNECTED_WALLET_NAME_SERVICE, null);
    const lastFetchedNameServiceAddress = React.useRef();
    const lastFetchedNameServiceNetwork = React.useRef();
    const fetchNameServiceFromBlockchain = React.useCallback((wallet) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        const { address, connector } = wallet;
        const network = yield connector.getNetwork(true);
        if (address === lastFetchedNameServiceAddress.current &&
            network === lastFetchedNameServiceNetwork.current) {
            return;
        }
        setConnectedNameService(null);
        // store last address used to fetch name service so we can check for it when promise resolves
        // to avoid race conditions
        lastFetchedNameServiceAddress.current = address;
        lastFetchedNameServiceNetwork.current = network;
        let ns;
        try {
            ns = yield wallet.getNameService();
        }
        catch (e) {
            // do nothing
        }
        // only sets name service if the address used to fetch it is the last one used for fetching
        // this avoid issues with promises not resolving in the correct order
        if (lastFetchedNameServiceAddress.current === address &&
            lastFetchedNameServiceNetwork.current === network) {
            setConnectedNameService({
                address,
                avatar: ns === null || ns === void 0 ? void 0 : ns.avatar,
                name: ns === null || ns === void 0 ? void 0 : ns.name,
                network,
            });
            return ns;
        }
        return undefined;
    }), [setConnectedNameService]);
    const getNameService = React.useCallback((address) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (!currentWallet) {
            return;
        }
        const network = yield currentWallet.connector.getNetwork(true);
        const verifiedCredentials = user === null || user === void 0 ? void 0 : user.verifiedCredentials;
        //if there are verified credentials, check if there is a name service for the current wallet
        if (verifiedCredentials) {
            const verifiedCredential = getWalletVerifiedCredential.getWalletVerifiedCredential(currentWallet === null || currentWallet === void 0 ? void 0 : currentWallet.address, verifiedCredentials, currentWallet.chain);
            if (verifiedCredential && ((_a = verifiedCredential.nameService) === null || _a === void 0 ? void 0 : _a.name)) {
                return verifiedCredential.nameService;
            }
        }
        // don't look for name service in blockchain if provided address doesn't match current wallet
        if (address && (currentWallet === null || currentWallet === void 0 ? void 0 : currentWallet.address) !== address) {
            return;
        }
        // if finds name service info in local storage and its related address matches the connected wallet address,
        // return it
        if (connectedNameService &&
            connectedNameService.address === (currentWallet === null || currentWallet === void 0 ? void 0 : currentWallet.address) &&
            connectedNameService.network === network) {
            return {
                avatar: connectedNameService.avatar,
                name: connectedNameService.name,
            };
        }
        // if doesn't find correct name service in verified credentials or local storage, fetch it from blockchain
        return fetchNameServiceFromBlockchain(currentWallet);
    }), [
        currentWallet,
        user === null || user === void 0 ? void 0 : user.verifiedCredentials,
        connectedNameService,
        fetchNameServiceFromBlockchain,
    ]);
    return { getNameService, removeConnectedNameService };
};

exports.useNameService = useNameService;
