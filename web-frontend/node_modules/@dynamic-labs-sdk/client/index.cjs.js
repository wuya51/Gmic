'use strict';

var assertPackageVersion = require('@dynamic-labs-sdk/assert-package-version');
var constants = require('./constants.cjs.js');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var getNetworkProviderFromNetworkId = require('./getNetworkProviderFromNetworkId.cjs.js');
var getWalletProviderByKey = require('./getWalletProviderByKey.cjs.js');
var z = require('zod/mini');
var isMfaRequiredForAction = require('./isMfaRequiredForAction.cjs.js');
var NotWaasWalletAccountError = require('./NotWaasWalletAccountError.cjs.js');
var EventEmitter = require('eventemitter3');
var browser = require('@simplewebauthn/browser');
var InvalidParamError = require('./InvalidParamError.cjs.js');
require('buffer');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var z__namespace = /*#__PURE__*/_interopNamespaceDefault(z);

/**
 * Maps the state keys to the event names.
 *
 * This is mainly to ensure that whenever a new state key is added, the developer
 * will have to come to this file and remember to add it here and in the interface.
 */ const stateChangeEvents = {
    initStatus: 'initStatusChanged',
    mfaToken: 'mfaTokenChanged',
    projectSettings: 'projectSettingsChanged',
    sessionExpiresAt: 'sessionExpiresAtChanged',
    token: 'tokenChanged',
    user: 'userChanged'
};

/**
 * This error is thrown when the `retryOnFail` function is called with an invalid
 * number of retries (i.e. less than 0).
 */ class InvalidRetryOnFailCallError extends constants.BaseError {
    constructor(maxRetries){
        super({
            cause: null,
            code: 'invalid_retry_on_fail_call_error',
            docsUrl: null,
            name: 'InvalidRetryOnFailCallError',
            shortMessage: `Invalid retries parameter for retryOnFail call: ${maxRetries}`
        });
    }
}

const retryOnFail = async ({ delay = 0, fn, maxRetries })=>{
    for(let retry = 0; retry <= maxRetries; retry++){
        try {
            return await fn();
        } catch (error) {
            if (retry >= maxRetries) {
                throw error;
            }
            if (delay > 0) {
                await new Promise((resolve)=>setTimeout(resolve, delay));
            }
        }
    }
    /**
   * Reaching this point should never happen and this
   * error is thrown to help us debug the issue.
   */ throw new InvalidRetryOnFailCallError(maxRetries);
};

/**
 * Checks if the user is currently signed in to the Dynamic client.
 *
 * The client is considered to be in a signed in state if a user has
 * authenticated or if the client has at least one wallet connected.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns True if the user is signed in, false otherwise.
 */ const isSignedIn = (client = constants.getDefaultClient())=>Boolean(client.user || getWalletProviderByKey.getWalletAccounts(client).length > 0);

/**
 * The schema to track the expiration time of the project settings.
 */ const projectSettingsExpirationStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema({
    key: 'projectSettingsExpiration',
    schema: z__namespace.number()
});

/**
 * Expiration time of the project settings in milliseconds.
 */ const PROJECT_SETTINGS_EXPIRATION_TIME = 1000 * 60 * 5; // 5 minutes
/**
 * Fetches and updates the project settings from the API.
 *
 * This function retrieves the latest project configuration settings
 * from Dynamic's servers, including authentication options, enabled chains,
 * and security configurations. The settings are cached for performance.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the updated project settings.
 */ const fetchProjectSettings = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const currentExpiration = await core.storage.getItem(projectSettingsExpirationStorageKeySchema);
    const hasProjectSettings = Boolean(client.projectSettings);
    const isExpired = currentExpiration && currentExpiration < Date.now();
    // We want to cache the project settings if its valid and user is connected.
    // This avoids unnecessary API calls and speeds up the initial load.
    if (hasProjectSettings && !isExpired && isSignedIn(client)) {
        return client.projectSettings;
    }
    const apiClient = constants.createApiClient({}, client);
    const doFetch = async ()=>apiClient.getEnvironmentSettings({
            environmentId: core.environmentId,
            sdkVersion: `${constants.CLIENT_SDK_NAME}/${core.version}`
        }, {
            credentials: 'omit'
        });
    const projectSettings = await retryOnFail({
        fn: doFetch,
        maxRetries: 2
    });
    core.state.set({
        projectSettings: projectSettings != null ? projectSettings : null
    });
    await core.storage.setItem(projectSettingsExpirationStorageKeySchema, Date.now() + PROJECT_SETTINGS_EXPIRATION_TIME);
    return projectSettings;
};

/**
 * Takes a base64url-encoded string (e.g. "nMueRPiAm51YXEjRtka8S_8Ura3HaqbmqDqMJCZmvkM")
 * and return the corresponding bytes, as an array buffer.
 */ const base64UrlDecode = (s)=>{
    // Go from base64url encoding to base64 encoding
    s = (s == null ? void 0 : s.replace(/-/g, '+').replace(/_/g, '/')) || '';
    // use `atob` to decode base64
    return Uint8Array.from(atob(s), (c)=>c.charCodeAt(0));
};

/**
 * Accepts a public key array buffer, and returns a buffer with the compressed version of the public key
 */ const compressRawPublicKey = (rawPublicKey)=>{
    const rawPublicKeyBytes = new Uint8Array(rawPublicKey);
    const len = rawPublicKeyBytes.byteLength;
    // Drop the y coordinate
    const compressedBytes = rawPublicKeyBytes.slice(0, 1 + len >>> 1);
    // Encode the parity of `y` in first bit
    compressedBytes[0] = 0x2 | rawPublicKeyBytes[len - 1] & 0x01;
    return compressedBytes.buffer;
};

const p256Keygen = async ()=>{
    // Create a new P-256 keypair
    const p256Keypair = await crypto.subtle.generateKey({
        name: 'ECDSA',
        namedCurve: 'P-256'
    }, true, [
        'sign',
        'verify'
    ]);
    // Export the raw public key. By default this will export in uncompressed format
    const rawPublicKey = await crypto.subtle.exportKey('raw', p256Keypair.publicKey);
    // We need to export with JWK format because exporting EC private keys with "raw" isn't supported
    const privateKeyJwk = await crypto.subtle.exportKey('jwk', p256Keypair.privateKey);
    const compressedPublicKeyBuffer = compressRawPublicKey(rawPublicKey);
    const privateKeyBuffer = base64UrlDecode(privateKeyJwk.d);
    return {
        private: isMfaRequiredForAction.bufferToHex(privateKeyBuffer),
        privateJwk: privateKeyJwk,
        public: isMfaRequiredForAction.bufferToHex(compressedPublicKeyBuffer)
    };
};

const generateSessionKeys = async (client)=>{
    const { private: privateKey, public: publicKey, privateJwk: privateKeyJwk } = await p256Keygen();
    const core = constants.getCore(client);
    // stringify and encode the session keys to store in storage
    const stringifiedSessionKeys = JSON.stringify({
        privateKey,
        privateKeyJwk,
        publicKey,
        registered: false
    });
    const encodedSessionKeys = constants.getBuffer().from(stringifiedSessionKeys).toString('base64');
    core.state.set({
        sessionKeys: encodedSessionKeys
    });
    return {
        privateKey,
        privateKeyJwk,
        publicKey
    };
};

/**
 * Creates a new runtime services instance that manages service registration and retrieval.
 *
 * @returns A RuntimeServices object with methods to get, register, and unregister services
 */ const createRuntimeServices = ()=>{
    const registry = new Map();
    return {
        getByKey: (key)=>registry.get(key),
        register: (key, service)=>registry.set(key, service),
        unregister: (key)=>registry.delete(key)
    };
};

const getAvailableWalletProvidersFromWalletAccounts = (client)=>{
    const core = constants.getCore(client);
    const walletProvidersMap = new Map();
    const walletAccounts = getWalletProviderByKey.getWalletAccounts(client);
    walletAccounts.forEach((walletAccount)=>{
        if (walletProvidersMap.has(walletAccount.walletProviderKey)) {
            return;
        }
        try {
            const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
                walletAccount
            }, client);
            walletProvidersMap.set(walletAccount.walletProviderKey, walletProvider);
        } catch (error) {
            core.logger.debug('Wallet provider not found for wallet account', {
                error,
                walletAccount: walletAccount.address
            });
        }
    });
    return Array.from(walletProvidersMap.values());
};

/**
 * Disconnect and terminate each wallet provider, if available.
 */ const disconnectAndTerminateWalletProviders = async (client)=>{
    const core = constants.getCore(client);
    const walletProviders = getAvailableWalletProvidersFromWalletAccounts(client);
    await Promise.all(walletProviders.map(async (walletProvider)=>{
        if (walletProvider.terminate) {
            await walletProvider.terminate();
        }
        if (walletProvider.disconnect) {
            try {
                await walletProvider.disconnect();
            } catch (err) {
                core.logger.error(`Error disconnecting from wallet ${walletProvider.key}`, err);
            }
        }
    }));
};

/**
 * Logs out the current user and clears all authentication data.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the logout process is complete.
 */ const logout = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    await disconnectAndTerminateWalletProviders(client);
    if (client.user !== null) {
        const apiClient = constants.createApiClient({}, client);
        try {
            await apiClient.revokeSession({
                environmentId: core.environmentId
            });
        } catch (error) {
            core.logger.error('Failed to revoke session', error);
        }
        /**
     * This deletes the auth cookie if it exists.
     * If the cookie doesn't exist, this sets a new cookie that expires immediately.
     */ if (constants.isCookieEnabled(client)) {
            getWalletProviderByKey.setCookie(`${getWalletProviderByKey.DYNAMIC_AUTH_COOKIE_NAME}=; Max-Age=-99999999; path=/; SameSite=Lax`);
        }
    }
    core.state.set({
        captchaToken: null,
        legacyToken: null,
        mfaToken: null,
        sessionExpiresAt: null,
        sessionKeys: null,
        token: null,
        unverifiedWalletAccounts: [],
        user: null
    });
    getWalletProviderByKey.emitEvent({
        event: 'logout'
    }, client);
    // Refetch project settings
    void fetchProjectSettings(client);
    // Regenerate session keys
    void generateSessionKeys(client);
};

/**
 * A replacement for setTimeout that supports delays longer than 2147483647ms (~24.8 days).
 */ const setLongTimeout = (callback, delay)=>{
    const MAX_DELAY = 2147483647; // Maximum delay for setTimeout (2^31 - 1)
    let timeoutId = null;
    let remaining = delay;
    const run = ()=>{
        if (remaining <= MAX_DELAY) {
            timeoutId = setTimeout(callback, remaining);
        } else {
            timeoutId = setTimeout(()=>{
                remaining -= MAX_DELAY;
                run();
            }, MAX_DELAY);
        }
    };
    run();
    // Return a cancel function
    return ()=>{
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
        }
    };
};

/**
 * Sets up a timeout to log out the user when their token expires.
 */ const initializeAuth = (client)=>{
    const core = constants.getCore(client);
    let clearExpirationTimeout = null;
    const onChangeExpiration = getNetworkProviderFromNetworkId.subscribeWithSelector(core.state, (state)=>state.sessionExpiresAt);
    const checkExpiration = ()=>{
        const expiration = core.state.get().sessionExpiresAt;
        clearExpirationTimeout == null ? void 0 : clearExpirationTimeout();
        if (!expiration) {
            return;
        }
        const now = new Date();
        const timeUntilExpiration = expiration.getTime() - now.getTime();
        if (timeUntilExpiration <= 0) {
            void logout(client);
            return;
        }
        // Wait for token expiration
        clearExpirationTimeout = setLongTimeout(checkExpiration, timeUntilExpiration);
    };
    onChangeExpiration(checkExpiration);
    checkExpiration();
};

const raiseStateEvents = (client)=>{
    const core = constants.getCore(client);
    core.state.subscribe((value, previous)=>{
        const eventEntries = Object.entries(stateChangeEvents);
        eventEntries.forEach(([key, event])=>{
            // Check if this key had a change
            if (getNetworkProviderFromNetworkId.isEqualShallow(value[key], previous[key])) return;
            getWalletProviderByKey.emitEvent({
                args: {
                    [key]: value[key]
                },
                event
            }, client);
        });
    });
};

const unverifiedWalletAccountSchema = z__namespace.object({
    address: z__namespace.string(),
    addressesWithTypes: z__namespace.optional(z__namespace.array(z__namespace.object({
        address: z__namespace.string(),
        publicKey: z__namespace.optional(z__namespace.string()),
        type: z__namespace.custom((val)=>typeof val === 'string')
    }))),
    chain: z__namespace.custom((val)=>typeof val === 'string'),
    id: z__namespace.string(),
    lastSelectedAt: z__namespace.nullable(z__namespace.date()),
    walletProviderKey: z__namespace.string()
});

const walletProviderKeyMapSchema = z__namespace.record(z__namespace.string(), z__namespace.string());

const stateStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema({
    key: 'state',
    schema: z__namespace.object({
        apiVersion: z__namespace.string(),
        projectSettings: z__namespace.custom(),
        unverifiedWalletAccounts: z__namespace.array(unverifiedWalletAccountSchema),
        user: z__namespace.custom(),
        walletProviderKeyMap: walletProviderKeyMapSchema
    })
});
const sessionStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema({
    key: 'session',
    schema: z__namespace.object({
        /**
     * The current available captcha token.
     */ captchaToken: z__namespace.nullable(z__namespace.string()),
        /**
     * Legacy token will be undefined in environments with cookie based sessions.
     *
     * @deprecated Use `token` instead.
     */ legacyToken: z__namespace.nullable(z__namespace.string()),
        /**
     * The current available MFA token.
     */ mfaToken: z__namespace.nullable(z__namespace.string()),
        /**
     * Milliseconds since epoch of session expiration.
     */ sessionExpiration: z__namespace.number(),
        /**
     * The current session keys.
     */ sessionKeys: z__namespace.nullable(z__namespace.string()),
        /**
     * Token will be undefined in environments with cookie based sessions.
     */ token: z__namespace.nullable(z__namespace.string())
    })
});

const hydrateStateWithStorage = async (client)=>{
    const core = constants.getCore(client);
    const stateChanges = {};
    // ================ TOKEN =================
    const session = await core.storage.getItem(sessionStorageKeySchema);
    const isSessionValid = (session == null ? void 0 : session.sessionExpiration) && session.sessionExpiration > Date.now();
    if (isSessionValid) {
        stateChanges.token = session.token;
        stateChanges.legacyToken = session.legacyToken;
        stateChanges.sessionExpiresAt = new Date(session.sessionExpiration);
        stateChanges.mfaToken = session.mfaToken;
        stateChanges.captchaToken = session.captchaToken;
        stateChanges.sessionKeys = session.sessionKeys;
    }
    // ================ STATE =================
    const storedState = await core.storage.getItem(stateStorageKeySchema);
    // Only hydrate state if it came from an API with the same version as the current SDK
    if ((storedState == null ? void 0 : storedState.apiVersion) === constants.SDK_API_CORE_VERSION) {
        stateChanges.unverifiedWalletAccounts = storedState.unverifiedWalletAccounts;
        stateChanges.walletProviderKeyMap = storedState.walletProviderKeyMap;
        // Variables that should only be hydrated if the session is valid
        if (isSessionValid) {
            stateChanges.user = storedState.user;
        }
        var _storedState_unverifiedWalletAccounts;
        // if there's a session/user or connected unverified wallets, we should hydrate project settings
        // so we don't refetch it on initial load
        if (isSessionValid || ((_storedState_unverifiedWalletAccounts = storedState.unverifiedWalletAccounts) != null ? _storedState_unverifiedWalletAccounts : []).length > 0) {
            stateChanges.projectSettings = storedState.projectSettings;
        }
    }
    if (Object.keys(stateChanges).length > 0) {
        core.state.set(stateChanges);
    }
};

const syncStateWithStorage = (client)=>{
    const core = constants.getCore(client);
    core.state.subscribe((state)=>{
        if (state.sessionExpiresAt === null) {
            void core.storage.removeItem(sessionStorageKeySchema);
        } else {
            void core.storage.setItem(sessionStorageKeySchema, {
                captchaToken: state.captchaToken,
                legacyToken: state.legacyToken,
                mfaToken: state.mfaToken,
                sessionExpiration: state.sessionExpiresAt.getTime(),
                sessionKeys: state.sessionKeys,
                token: state.token
            });
        }
        void core.storage.setItem(stateStorageKeySchema, {
            apiVersion: constants.SDK_API_CORE_VERSION,
            projectSettings: state.projectSettings,
            unverifiedWalletAccounts: state.unverifiedWalletAccounts,
            user: state.user,
            walletProviderKeyMap: state.walletProviderKeyMap
        });
    });
};

const initializeStorageSync = async (client)=>{
    // Initialize the state value with what's stored in the storage
    await hydrateStateWithStorage(client);
    // Keep the storage up to date with the state
    syncStateWithStorage(client);
};

class ClientAlreadyInitializedError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'client_already_initialized_error',
            docsUrl: null,
            name: 'ClientAlreadyInitializedError',
            shortMessage: 'Client must not be initialized more than once'
        });
    }
}

/**
 * Initializes the Dynamic client and all its modules and services.
 *
 * This function orchestrates the initialization of authentication, project settings,
 * session keys, and storage sync. It manages the initialization status and handles
 * any errors that occur during the process.
 *
 * You only need to call this function if you are not using `autoInitialize: true` in createDynamicClient.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when initialization is complete.
 * @throws ClientAlreadyInitializedError If the client is already initialized.
 */ const initializeClient = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    if (core.state.get().initStatus !== 'uninitialized') {
        throw new ClientAlreadyInitializedError();
    }
    core.state.set({
        initStatus: 'in-progress'
    });
    initializeAuth(client);
    raiseStateEvents(client);
    const initializeStorageSyncPromise = initializeStorageSync(client);
    const fetchProjectSettingsPromise = initializeStorageSyncPromise.then(async ()=>{
        if (!core.state.get().projectSettings) {
            await fetchProjectSettings(client);
        }
    });
    /**
   * Generate session keys if they don't exist
   */ const generateSessionKeysPromise = fetchProjectSettingsPromise.then(async ()=>{
        if (!core.state.get().sessionKeys) {
            await generateSessionKeys(client);
        }
    });
    /**
   * Refresh user state on initialization when cookie is enabled.
   * This is necessary for supporting multiple subdomain domains.
   *
   * When a user logs in on sub1.example.com, they will have a cookie set. However, when they access
   * sub2.example.com, the cookie will be present but the user state will not be present.
   * We need to fetch the user to access the expiration date of the cookie on the new subdomain.
   *
   * This is also needed in case a user logs in with a new user on sub1.example.com and then accesses
   * sub2.example.com that had the original logged-in user. We need to fetch the user to refresh
   * the user state with the correct logged-in user.
   */ const refreshUserStateFromCookiePromise = fetchProjectSettingsPromise.then(async ()=>{
        /**
       * When cookies are enabled, we need to refresh the user as part of the initialization process
       * to ensure the user is logged in and sync the auth state with the server.
       *
       * This call can fail with a 401 error if the user is not logged in and the SDK should finish its initialization process
       * without throwing an error because that is an expected behavior.
       */ if (constants.isCookieEnabled(client)) {
            await NotWaasWalletAccountError.refreshUser(client).catch(async (error)=>{
                if (error.status === 401) {
                    if (client.user) {
                        await logout(client);
                    }
                } else {
                    throw error;
                }
            });
        }
    });
    core.initTrack.track({
        name: getNetworkProviderFromNetworkId.INITIALIZE_STORAGE_SYNC_TRACKER_KEY,
        promise: initializeStorageSyncPromise
    });
    core.initTrack.track({
        name: getNetworkProviderFromNetworkId.FETCH_PROJECT_SETTINGS_TRACKER_KEY,
        promise: fetchProjectSettingsPromise
    });
    core.initTrack.track({
        name: getNetworkProviderFromNetworkId.GENERATE_SESSION_KEYS_TRACKER_KEY,
        promise: generateSessionKeysPromise
    });
    core.initTrack.track({
        name: getNetworkProviderFromNetworkId.REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY,
        promise: refreshUserStateFromCookiePromise
    });
    try {
        await core.initTrack.waitForAll();
        core.state.set({
            initStatus: 'finished'
        });
    } catch (error) {
        core.state.set({
            initStatus: 'failed'
        });
        throw error;
    }
};

/**
 * Indicates if the code is running in a server-side environment.
 */ // eslint-disable-next-line no-restricted-globals
const isServerSideRendering = ()=>typeof window === 'undefined';

const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = _resolve;
        reject = _reject;
    });
    return {
        promise,
        reject: (reason)=>reject == null ? void 0 : reject(reason),
        resolve: (value)=>resolve == null ? void 0 : resolve(value)
    };
};

/**
 * Creates a tracker that associates names with promises and raises as promises resolve.
 */ const createAsyncTrack = ()=>{
    /**
   * Whether tracking is enabled.
   * All processes must be tracked on the same node tick.
   *
   * This ensures no process is missed (as it would throw when tracked on a different node tick).
   */ let isTrackEnabled = true;
    const eventEmitter = new EventEmitter.EventEmitter();
    const allSettledPromise = createDeferredPromise();
    const tracker = new Map();
    /**
   * Checks if all processes are initialized and resolves the main promise if they are.
   */ const checkIfAllSettled = ()=>{
        const allSettled = Array.from(tracker.values()).every(({ status })=>status === 'resolved');
        if (!allSettled) return;
        allSettledPromise.resolve();
    };
    const track = ({ name, promise })=>{
        if (!isTrackEnabled) {
            throw new getNetworkProviderFromNetworkId.CannotTrackError();
        }
        // Disable tracking in the next node tick
        void Promise.resolve().then(()=>isTrackEnabled = false);
        tracker.set(name, {
            promise,
            status: 'pending'
        });
        promise.then(()=>{
            tracker.set(name, {
                promise,
                status: 'resolved'
            });
            eventEmitter.emit('resolved', name);
            checkIfAllSettled();
        }).catch((error)=>{
            tracker.set(name, {
                promise,
                status: 'failed'
            });
            eventEmitter.emit('failed', name, error);
            allSettledPromise.reject(error);
        });
    };
    const waitForAll = ()=>allSettledPromise.promise;
    const getTracker = (trackerKey)=>tracker.get(trackerKey);
    return {
        getTracker,
        off: eventEmitter.off.bind(eventEmitter),
        on: eventEmitter.on.bind(eventEmitter),
        track,
        waitForAll
    };
};

const createEventEmitter = ()=>new EventEmitter();

class UnavailableInServerSideError extends constants.BaseError {
    constructor(unavailableFeature){
        super({
            cause: null,
            code: 'unavailable_in_server_side_error',
            docsUrl: null,
            name: 'UnavailableInServerSideError',
            shortMessage: `This function is not available in server-side rendering: ${unavailableFeature}`
        });
    }
}

/**
 * Creates a fetch instance that uses the native window.fetch API.
 */ const createWebFetch = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createWebFetch'));
    }
    // eslint-disable-next-line no-restricted-globals -- this is the abstraction for fetch
    return window.fetch.bind(window);
};

/**
 * Creates a navigation handler that uses the native window.location API.
 */ const createNavigationHandler = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createNavigationHandler'));
    }
    return async (url)=>{
        // eslint-disable-next-line no-restricted-globals -- this is the abstraction for navigation
        window.location.href = url;
    };
};

/**
 * Creates a deeplink opener that uses the native window.open API.
 */ const createWebDeeplinkOpener = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createWebDeeplinkOpener'));
    }
    return async (url)=>{
        // eslint-disable-next-line no-restricted-globals -- this is the abstraction for opening a deeplink
        window.open(url, '_blank');
    };
};

/**
 * Create a passkey service that uses the browser's WebAuthn API.
 */ const createWebPasskeyService = ()=>({
        authenticate: (options)=>browser.startAuthentication(options),
        isSupported: ()=>browser.browserSupportsWebAuthn(),
        register: (options)=>browser.startRegistration(options)
    });

const createDebouncedMutex = ()=>{
    const mutexState = new Map();
    return async ({ lockKey, callback, debounceTime = 0 })=>{
        const resolutionPromise = createDeferredPromise();
        // Prefill the state for this key if it doesn't exist to avoid needing to check for existence later.
        if (!mutexState.has(lockKey)) {
            mutexState.set(lockKey, {
                nextCallback: null,
                queuePromise: Promise.resolve(),
                resolutionPromises: [],
                timer: null
            });
        }
        const currentState = mutexState.get(lockKey);
        // This should never happen, but we'll assert it for TS safety.
        constants.assertDefined(currentState, `Mutex state for key ${lockKey} not found`);
        currentState.resolutionPromises.push(resolutionPromise);
        if (currentState.timer) {
            clearTimeout(currentState.timer);
        }
        // The last invocation wins. Always.
        currentState.nextCallback = callback;
        const addCallbackToQueue = async ()=>{
            currentState.queuePromise = currentState.queuePromise.then(async ()=>{
                if (!currentState.nextCallback) {
                    return;
                }
                // We can't just use the callback param directly because later invocations
                // should override previous ones.
                // Scenario to illustrate this (none of these will use the timer param for simplicity):
                // 1. Very long running promise callback A runs
                // 2. While it's running, we invoke callback B, which queues itself with "then" and overrides nextCallback with B.
                // 3. While A is still running, we invoke callback C, same thing happens, now nextCallback is C.
                // 4. A resolves, nextCallback is invoked with C.
                // 5. After C resolves, nextCallback is invoked with null, so it doesn't run.
                // Conclusion: B was never executed and only the last invocation runs.
                const { nextCallback } = currentState;
                currentState.nextCallback = null;
                const promisesToResolve = currentState.resolutionPromises;
                currentState.resolutionPromises = [];
                try {
                    await nextCallback();
                    promisesToResolve.forEach((resolutionPromise)=>resolutionPromise.resolve());
                } catch (error) {
                    promisesToResolve.forEach((resolutionPromise)=>resolutionPromise.reject(error));
                }
            });
        };
        if (debounceTime > 0) {
            currentState.timer = setTimeout(addCallbackToQueue, debounceTime);
        } else {
            await addCallbackToQueue();
        }
        return resolutionPromise.promise;
    };
};

class InvalidStorageValue extends constants.BaseError {
    constructor(key, value){
        super({
            cause: null,
            code: 'invalid_storage_value',
            docsUrl: null,
            name: 'InvalidStorageValue',
            shortMessage: `Tried to store state with a forbidden value. Key: ${key}, Value: ${value}`
        });
    }
}

/**
 * Creates an observable state object that allows subscribing to immutable state changes.
 *
 * This function creates a state management system with the following capabilities:
 * - Get the current state
 * - Update state partially
 * - Subscribe to state changes
 * - Unsubscribe from state changes
 *
 * @param getInitialState - A function that returns the initial state object
 * @returns An ObservableState object with methods to manage and observe state changes
 * @example
 * ```typescript
 * const state = createObservableState(() => ({
 *   count: 0,
 *   name: 'John'
 * }));
 *
 * // Subscribe to changes
 * const unsubscribe = state.subscribe((current, previous) => {
 *   console.log('State changed:', current, 'Previous:', previous);
 * });
 *
 * // Update state
 * state.set({ count: 1 });
 *
 * // Get current state
 * const currentState = state.get();
 *
 * // Unsubscribe when done
 * unsubscribe();
 * ```
 */ const createObservableState = (getInitialState)=>{
    // ===============
    // NOTIFICATIONS
    // ===============
    const subscribers = new Set();
    const notifySubscribers = (value, previous)=>{
        subscribers.forEach((callback)=>callback(value, previous));
    };
    const subscribe = (callback)=>{
        subscribers.add(callback);
        return ()=>unsubscribe(callback);
    };
    const unsubscribe = (callback)=>{
        subscribers.delete(callback);
    };
    // ===============
    // STATE
    // ===============
    let currentState = getInitialState();
    const get = ()=>currentState;
    const set = (partial)=>{
        const previous = currentState;
        Object.entries(partial).forEach(([key, value])=>{
            if (value === undefined) {
                throw new InvalidStorageValue(key, value);
            }
        });
        currentState = Object.assign({}, currentState, partial);
        notifySubscribers(currentState, previous);
    };
    return {
        get,
        getInitialState,
        set,
        subscribe,
        unsubscribe
    };
};

/**
 * The default API base URL for Dynamic apps in production.
 */ const DEFAULT_API_BASE_URL = 'https://app.dynamicauth.com/api/v0';

/**
 * The initial values for the state of the client.
 */ const getInitialState = ()=>({
        captchaToken: null,
        initStatus: 'uninitialized',
        legacyToken: null,
        mfaToken: null,
        projectSettings: null,
        sessionExpiresAt: null,
        sessionKeys: null,
        token: null,
        unverifiedWalletAccounts: [],
        user: null,
        walletProviderKeyMap: {}
    });

/**
 * Creates a core instance that contains all the services and state of the Dynamic SDK client.
 */ const createCore = (config)=>{
    var _config_coreConfig, _config_coreConfig1, _config_coreConfig2, _config_coreConfig3, _config_coreConfig4, _config_coreConfig5, _config_coreConfig6, _config_coreConfig7;
    var _config_coreConfig_apiBaseUrl;
    const apiBaseUrl = (_config_coreConfig_apiBaseUrl = (_config_coreConfig = config.coreConfig) == null ? void 0 : _config_coreConfig.apiBaseUrl) != null ? _config_coreConfig_apiBaseUrl : DEFAULT_API_BASE_URL;
    var _config_coreConfig_logger;
    const logger = (_config_coreConfig_logger = (_config_coreConfig1 = config.coreConfig) == null ? void 0 : _config_coreConfig1.logger) != null ? _config_coreConfig_logger : getNetworkProviderFromNetworkId.createLogger();
    var _config_coreConfig_storageAdapter;
    const storage = getNetworkProviderFromNetworkId.createStorage({
        prefix: `dynamic_${config.environmentId}`,
        storageAdapter: (_config_coreConfig_storageAdapter = (_config_coreConfig2 = config.coreConfig) == null ? void 0 : _config_coreConfig2.storageAdapter) != null ? _config_coreConfig_storageAdapter : getNetworkProviderFromNetworkId.createLocalStorageAdapter()
    });
    var _config_coreConfig_fetch;
    const fetch = (_config_coreConfig_fetch = (_config_coreConfig3 = config.coreConfig) == null ? void 0 : _config_coreConfig3.fetch) != null ? _config_coreConfig_fetch : createWebFetch();
    var _config_coreConfig_openDeeplink;
    const openDeeplink = (_config_coreConfig_openDeeplink = (_config_coreConfig4 = config.coreConfig) == null ? void 0 : _config_coreConfig4.openDeeplink) != null ? _config_coreConfig_openDeeplink : createWebDeeplinkOpener();
    var _config_coreConfig_navigate;
    const navigate = (_config_coreConfig_navigate = (_config_coreConfig5 = config.coreConfig) == null ? void 0 : _config_coreConfig5.navigate) != null ? _config_coreConfig_navigate : createNavigationHandler();
    const state = createObservableState(getInitialState);
    const debouncedMutex = createDebouncedMutex();
    const eventEmitter = createEventEmitter();
    const initTrack = createAsyncTrack();
    const runtimeServices = createRuntimeServices();
    var _config_coreConfig_passkey;
    const passkey = (_config_coreConfig_passkey = (_config_coreConfig6 = config.coreConfig) == null ? void 0 : _config_coreConfig6.passkey) != null ? _config_coreConfig_passkey : createWebPasskeyService();
    var _config_coreConfig_getApiHeaders;
    return {
        apiBaseUrl,
        debouncedMutex,
        environmentId: config.environmentId,
        eventEmitter,
        extensions: new Set(),
        fetch,
        getApiHeaders: (_config_coreConfig_getApiHeaders = (_config_coreConfig7 = config.coreConfig) == null ? void 0 : _config_coreConfig7.getApiHeaders) != null ? _config_coreConfig_getApiHeaders : ()=>({}),
        initTrack,
        logger,
        metadata: config.metadata,
        navigate,
        openDeeplink,
        passkey,
        runtimeServices,
        state,
        storage,
        version: constants.version
    };
};

/**
 * Creates a new DynamicClient instance.
 *
 * Notice the `autoInitialize` flag is true by default (unless you're running
 * in SSR), so the client will be automatically initialized when created â€” if
 * you want to manually initialize the client, you can set the `autoInitialize`
 * flag to false and then later call the `initializeClient` function.
 *
 * Manually calling `initializeClient` also allows you to catch any potential
 * errors that may occur during initialization.
 *
 * @param config - The configuration for the Dynamic client, like the environment ID, app url, etc.
 * @returns The Dynamic client instance.
 */ const createDynamicClient = (config)=>{
    const core = createCore(config);
    const client = {
        get __core () {
            return core;
        },
        get initStatus () {
            return core.state.get().initStatus;
        },
        get mfaToken () {
            return core.state.get().mfaToken;
        },
        get projectSettings () {
            return core.state.get().projectSettings;
        },
        get sessionExpiresAt () {
            return core.state.get().sessionExpiresAt;
        },
        get token () {
            return core.state.get().token;
        },
        get user () {
            return core.state.get().user;
        }
    };
    var _config_autoInitialize;
    // Define if SDK should auto initialize, default to true
    const autoInitialize = (_config_autoInitialize = config.autoInitialize) != null ? _config_autoInitialize : true;
    // Prevent the auto initialization in SSR
    const shouldAutoInitialize = isServerSideRendering() ? false : autoInitialize;
    if (shouldAutoInitialize) {
        void initializeClient(client);
    }
    constants.setDefaultClient(client);
    return client;
};

class InvalidRedirectStorageStateError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'invalid_redirect_storage_state_error',
            docsUrl: null,
            name: 'InvalidRedirectStorageStateError',
            shortMessage: 'The social redirect data found in local storage does not match the expected state. Try connecting again.'
        });
    }
}

class MissingRedirectStorageStateError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'missing_redirect_storage_state_error',
            docsUrl: null,
            name: 'MissingRedirectStorageStateError',
            shortMessage: 'The social redirect data was not found in local storage. Try connecting again.'
        });
    }
}

class MissingSocialUrlParamError extends constants.BaseError {
    constructor(param){
        super({
            cause: null,
            code: 'missing_social_url_param_error',
            docsUrl: null,
            name: 'MissingSocialParamError',
            shortMessage: `To complete social sign in, the following URL query parameter is required to be set but was not found: ${param}`
        });
    }
}

class NetworkSwitchingUnavailableError extends constants.BaseError {
    constructor({ walletProviderKey, originalError, extraMessages }){
        const cause = originalError instanceof Error ? originalError : null;
        super({
            cause,
            code: 'network_switching_unavailable',
            docsUrl: null,
            metaMessages: [
                `Wallet provider key: ${walletProviderKey}`,
                ...extraMessages != null ? extraMessages : []
            ],
            name: 'NetworkSwitchingUnavailableError',
            shortMessage: `Network switching is not available at this time. The user should manually switch networks in their wallet`
        });
    }
}

class NoAddressFoundError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_address_found_error',
            docsUrl: null,
            name: 'NoAddressFoundError',
            shortMessage: 'No address is connected to the wallet'
        });
    }
}

class NoPasskeyCredentialsFoundError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_passkey_credentials_found_error',
            docsUrl: null,
            name: 'NoPasskeyCredentialsFoundError',
            shortMessage: 'No passkey credentials found'
        });
    }
}

class NoSmartWalletAccountSignerFoundError extends constants.BaseError {
    constructor(smartWalletAddress){
        super({
            cause: null,
            code: 'no_smart_wallet_account_signer_found_error',
            docsUrl: null,
            name: 'NoSmartWalletAccountSignerFoundError',
            shortMessage: `No signer wallet account found for smart wallet account ${smartWalletAddress}`
        });
    }
}

class NoWebAuthNSupportError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_webauthn_support_error',
            docsUrl: null,
            name: 'NoWebAuthNSupportError',
            shortMessage: 'Browser does not support WebAuthn'
        });
    }
}

class UnrecognizedNetworkError extends constants.BaseError {
    constructor({ networkId, originalError, walletProviderKey }){
        const cause = originalError instanceof Error ? originalError : null;
        super({
            cause,
            code: 'unrecognized_network',
            docsUrl: null,
            metaMessages: [
                `Wallet provider key: ${walletProviderKey}`
            ],
            name: 'UnrecognizedNetworkError',
            shortMessage: `Attempt to switch to unrecognized network of ID ${networkId}. Please enable this network in your dashboard configuration first.`
        });
    }
}

class UserNotAuthenticatedError extends constants.BaseError {
    constructor({ shortMessage } = {}){
        super({
            cause: null,
            code: 'user_not_authenticated_error',
            docsUrl: null,
            name: 'UserNotAuthenticatedError',
            shortMessage: shortMessage != null ? shortMessage : 'User not authenticated'
        });
    }
}

class UserRejectedError extends constants.BaseError {
    constructor({ action }){
        super({
            cause: null,
            code: 'user_rejected',
            docsUrl: null,
            name: 'UserRejectedError',
            shortMessage: `User rejected action "${action}"`
        });
    }
}

class WalletAccountAlreadyVerifiedError extends constants.BaseError {
    constructor(address){
        super({
            cause: null,
            code: 'wallet_account_already_verified_error',
            docsUrl: null,
            name: 'WalletAccountAlreadyVerifiedError',
            shortMessage: `Wallet account ${address} is already verified`
        });
    }
}

class WalletAccountNotSelectedError extends constants.BaseError {
    constructor(params){
        const currentAccountInfo = params.selectedAddress ? ` (currently ${params.selectedAddress})` : '';
        super({
            cause: null,
            code: 'wallet_account_not_selected_error',
            docsUrl: null,
            name: 'WalletAccountNotSelected',
            shortMessage: `This wallet only supports signing with its selected account${currentAccountInfo}. Please select account ${params.expectedAddress} in your wallet app and try again`
        });
        this.expectedAddress = params.expectedAddress;
        this.selectedAddress = params.selectedAddress;
    }
}

class WalletProviderMethodUnavailableError extends constants.BaseError {
    constructor({ methodName, walletProviderKey }){
        super({
            cause: null,
            code: 'wallet_provider_method_unavailable_error',
            docsUrl: null,
            name: 'WalletProviderMethodUnavailableError',
            shortMessage: `Wallet provider ${walletProviderKey} does not have ${methodName} available`
        });
    }
}

/**
 * Signs in a user using an external JWT token.
 *
 * This function allows authentication using JWT tokens from external providers,
 * enabling integration with custom authentication systems.
 *
 * @param [params.externalJwt] - Optional external JWT token to authenticate with. Not required when using cookie based auth.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the authentication response from the server.
 */ const signInWithExternalJwt = async ({ externalJwt, sessionPublicKey } = {}, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.externalAuthSignin({
        environmentId: core.environmentId,
        externalAuthSigninRequest: {
            jwt: externalJwt,
            sessionPublicKey
        }
    });
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    return response;
};

/**
 * Deletes a passkey for the current user.
 *
 * @param params.passkeyId - The unique identifier of the passkey to delete.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the passkey is successfully deleted.
 */ const deletePasskey = async ({ passkeyId }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({
        includeMfaToken: true
    }, client);
    await apiClient.deletePasskey({
        deleteUserPasskeyRequest: {
            passkeyId
        },
        environmentId: core.environmentId
    });
};

/**
 * Retrieves all passkeys associated with the current user.
 *
 * This function fetches the list of registered passkeys (WebAuthn credentials)
 * that the user can use for multi-factor authentication.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an array of the user's registered passkeys.
 */ const getPasskeys = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.getUserPasskeys({
        environmentId: core.environmentId
    });
    return response.passkeys;
};

const getPasskeyRegistrationOptions = async (client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const options = await apiClient.getPasskeyRegistrationOptions({
        environmentId: core.environmentId
    });
    return options;
};

const serverRegisterPasskey = async ({ registration }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.registerPasskey({
        environmentId: core.environmentId,
        passkeyRegisterRequest: constants._extends({}, registration, {
            response: constants._extends({}, registration.response, {
                clientDataJson: registration.response.clientDataJSON
            })
        })
    });
    return response;
};

/**
 * Registers a new passkey for the current user.
 *
 * This function creates a new WebAuthn credential that can be used for
 * passwordless authentication. The user will be prompted to create a passkey
 * using their device's biometric authentication or security key.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the registration response.
 * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
 */ const registerPasskey = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    if (!core.passkey.isSupported()) {
        throw new NoWebAuthNSupportError();
    }
    const options = await getPasskeyRegistrationOptions(client);
    const registration = await core.passkey.register({
        optionsJSON: options
    });
    const response = await serverRegisterPasskey({
        registration
    }, client);
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    return response;
};

const getPasskeyAuthenticationSignInOptions = async ({ relatedOriginRpId } = {}, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const options = await apiClient.getPasskeyAuthenticationSigninOptions({
        environmentId: core.environmentId,
        relatedOriginRpId: relatedOriginRpId
    });
    return options;
};

const serverSigninPasskey = async ({ authentication, createMfaToken }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.signinWithPasskey({
        environmentId: core.environmentId,
        passkeyAuthRequest: constants._extends({}, authentication, {
            createMfaToken,
            response: constants._extends({}, authentication.response, {
                clientDataJson: authentication.response.clientDataJSON
            })
        })
    });
    return response;
};

/**
 * Signs in the user using a registered passkey.
 *
 * This function authenticates the user with a previously registered WebAuthn
 * credential, providing passwordless authentication using biometrics or
 * security keys.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the authentication response.
 * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
 */ const signInWithPasskey = async ({ relatedOriginRpId } = {}, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    if (!core.passkey.isSupported()) {
        throw new NoWebAuthNSupportError();
    }
    const options = await getPasskeyAuthenticationSignInOptions({
        relatedOriginRpId
    }, client);
    const formattedOptions = constants._extends({}, options);
    const authentication = await core.passkey.authenticate({
        optionsJSON: formattedOptions
    });
    const response = await serverSigninPasskey({
        authentication
    }, client);
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    return response;
};

/**
 * Retrieves all social accounts associated with the current user.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns An array of `SocialAccount` objects associated with the user.
 */ const getUserSocialAccounts = (client = constants.getDefaultClient())=>{
    const { user } = client;
    constants.assertDefined(user, 'User is not authenticated');
    var _user_verifiedCredentials_filter;
    const socialCredentials = (_user_verifiedCredentials_filter = user.verifiedCredentials.filter((credential)=>credential.format === sdkApiCore.JwtVerifiedCredentialFormatEnum.Oauth)) != null ? _user_verifiedCredentials_filter : [];
    return socialCredentials.map((credential)=>{
        var _credential_oauthAccountId, _credential_oauthDisplayName, _credential_oauthEmails, _credential_oauthAccountPhotos, _credential_oauthUsername;
        return {
            accountId: (_credential_oauthAccountId = credential.oauthAccountId) != null ? _credential_oauthAccountId : undefined,
            displayName: (_credential_oauthDisplayName = credential.oauthDisplayName) != null ? _credential_oauthDisplayName : undefined,
            emails: (_credential_oauthEmails = credential.oauthEmails) != null ? _credential_oauthEmails : [],
            photos: (_credential_oauthAccountPhotos = credential.oauthAccountPhotos) != null ? _credential_oauthAccountPhotos : [],
            provider: credential.oauthProvider,
            username: (_credential_oauthUsername = credential.oauthUsername) != null ? _credential_oauthUsername : undefined,
            verifiedCredentialId: credential.id
        };
    });
};

const removeDynamicOauthParamsFromUrl = (url)=>{
    const urlObject = new URL(url);
    urlObject.searchParams.delete('dynamicOauthState');
    urlObject.searchParams.delete('dynamicOauthCode');
    return urlObject.toString();
};

/** The schema to track the state of the OAuth flow. */ const redirectStateStorageKeySchema = getNetworkProviderFromNetworkId.createStorageKeySchema({
    key: 'redirectState',
    schema: z__namespace.object({
        codeVerifier: z__namespace.optional(z__namespace.string()),
        provider: z__namespace.enum(sdkApiCore.ProviderEnum),
        state: z__namespace.string()
    })
});

const digestSHA256 = (str)=>{
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    return crypto.subtle.digest('SHA-256', data);
};

/**
 * Encodes a string to base64url.
 *
 * @param str - The string to encode as an ArrayBuffer.
 * @returns The base64url encoded string.
 */ const encodeBase64Url = (str)=>{
    const numberArray = [];
    new Uint8Array(str).forEach((item)=>numberArray.push(item));
    // Deprecated btoa used for web compatibility
    return btoa(String.fromCharCode.apply(null, numberArray)).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};

const APPLE_RESPONSE_MODE = 'form_post';
const APPLE_RESPONSE_TYPE = 'code id_token';
/** Helper function to add OAuth URL parameters to a given base URL. */ const addOAuthUrlParams = (provider, baseUrl)=>{
    constants.assertDefined(provider.clientId, 'Client ID not found');
    constants.assertDefined(provider.provider, 'Provider type not found');
    constants.assertDefined(provider.redirectUrl, 'Redirect URL not found');
    const providerType = provider.provider;
    baseUrl.searchParams.set('client_id', provider.clientId);
    baseUrl.searchParams.set('response_type', 'code');
    baseUrl.searchParams.set('redirect_uri', provider.redirectUrl);
    if (providerType === sdkApiCore.ProviderEnum.Tiktok) {
        baseUrl.searchParams.delete('client_id');
        baseUrl.searchParams.set('client_key', provider.clientId);
    }
    if (providerType === sdkApiCore.ProviderEnum.Google) {
        baseUrl.searchParams.set('access_type', 'offline');
    }
    // Add logic for providers that require additional parameters
    if (providerType === sdkApiCore.ProviderEnum.Apple) {
        baseUrl.searchParams.set('response_mode', APPLE_RESPONSE_MODE);
        baseUrl.searchParams.set('response_type', APPLE_RESPONSE_TYPE);
    }
    if (provider.scopes) {
        baseUrl.searchParams.set('scope', provider.scopes);
    }
    return baseUrl;
};

/** Helper function to build the OAuth base URL for a given provider. */ const getOAuthBaseUrl = (provider)=>{
    constants.assertDefined(provider.provider, 'Provider type not found');
    const providerType = provider.provider;
    if (providerType === sdkApiCore.ProviderEnum.Telegram) {
        constants.assertDefined(provider.authorizationUrl, 'Telegram authorization URL not found');
        return new URL(provider.authorizationUrl);
    }
    constants.assertDefined(provider.baseAuthUrl, 'Base auth URL not found');
    if (providerType === sdkApiCore.ProviderEnum.Shopify) {
        constants.assertDefined(provider.shopifyStore, 'Shopify store value not found in provider');
        const loginBaseUrl = provider.baseAuthUrl.replace('{{shopifyStore}}', provider.shopifyStore);
        return new URL(loginBaseUrl);
    }
    return new URL(provider.baseAuthUrl);
};

const providersRequiringPkce = [
    'twitter',
    'github'
];
/** Helper function to build the OAuth URL for a given provider. */ const buildOAuthUrl = async (/** The core instance. */ core, /** The provider to build the OAuth URL for. */ provider)=>{
    const { projectSettings } = core.state.get();
    // Check if the provider is supported
    constants.assertDefined(projectSettings, 'Project settings not found');
    constants.assertDefined(projectSettings.providers, 'Project providers not found');
    const socialProvider = projectSettings.providers.find((p)=>p.provider === provider);
    constants.assertDefined(socialProvider, `Social provider ${provider} not supported`);
    // Build the OAuth URL
    const loginBaseUrl = getOAuthBaseUrl(socialProvider);
    const socialProviderUrl = addOAuthUrlParams(socialProvider, loginBaseUrl);
    // Add PKCE and state parameters
    const usingPkce = providersRequiringPkce.includes(provider);
    const state = constants.randomString(32);
    const codeVerifier = constants.randomString(43);
    socialProviderUrl.searchParams.set('state', state);
    socialProviderUrl.searchParams.set('response_type', 'code');
    if (usingPkce) {
        const digest = await digestSHA256(codeVerifier);
        socialProviderUrl.searchParams.set('code_challenge', encodeBase64Url(digest));
        socialProviderUrl.searchParams.set('code_challenge_method', 'S256');
    }
    return {
        codeVerifier: usingPkce ? codeVerifier : undefined,
        state,
        url: socialProviderUrl
    };
};

/**
 * Initiates social authentication by redirecting to the OAuth provider.
 *
 * This function redirects the user to the specified social provider's
 * authorization page to complete OAuth authentication flow.
 * After the oauth flow is complete, the user will be redirected back to your app.
 * You can then call `detectOAuthRedirect` to check if the user got redirected back to your app due to the oauth flow,
 * and finally call `completeSocialAuthentication` to complete the social authentication flow.
 *
 * @param params.provider - The social provider to authenticate with (e.g., 'google', 'github').
 * @param params.redirectUrl - The URL to redirect back to after authentication.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 */ const authenticateWithSocial = async ({ provider, redirectUrl }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    await core.initTrack.waitForAll();
    const providerType = provider;
    const { url, state, codeVerifier } = await buildOAuthUrl(core, providerType);
    await apiClient.initAuth({
        environmentId: core.environmentId,
        oauthInitAuthRequest: {
            redirectUrl: removeDynamicOauthParamsFromUrl(redirectUrl),
            state
        },
        providerType
    });
    await core.storage.setItem(redirectStateStorageKeySchema, {
        codeVerifier,
        provider: providerType,
        state
    });
    await core.navigate(url.toString());
};

/**
 * Completes the social authentication flow after OAuth redirect.
 *
 * This function processes the OAuth callback URL with authorization codes
 * and completes the user authentication with the social provider.
 *
 * @param params.url - The callback URL containing OAuth response parameters.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the authenticated user or null.
 * @throws MissingSocialUrlParamError If required OAuth parameters are missing.
 * @throws InvalidRedirectStorageStateError If the stored state doesn't match.
 */ const completeSocialAuthentication = async ({ url }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    await core.initTrack.waitForAll();
    const dynamicOauthState = url.searchParams.get('dynamicOauthState');
    const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');
    if (!dynamicOauthState) {
        throw new MissingSocialUrlParamError('dynamicOauthState');
    }
    if (!dynamicOauthCode) {
        throw new MissingSocialUrlParamError('dynamicOauthCode');
    }
    const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageKeySchema);
    if (!storedSocialRedirectState) {
        throw new MissingRedirectStorageStateError();
    }
    if (storedSocialRedirectState.state !== dynamicOauthState) {
        throw new InvalidRedirectStorageStateError();
    }
    const { provider, codeVerifier } = storedSocialRedirectState;
    await core.storage.removeItem(redirectStateStorageKeySchema);
    let response;
    // if user is alreadyauthenticated, we're verifying the social auth to link it to the user
    if (client.user) {
        response = await apiClient.oauthVerify({
            environmentId: core.environmentId,
            oauthRequest: {
                code: dynamicOauthCode,
                codeVerifier,
                state: dynamicOauthState
            },
            providerType: provider
        });
    } else {
        // if user is not authenticated, we're signing in with the social auth
        response = await apiClient.oauthSignIn({
            environmentId: core.environmentId,
            oauthRequest: {
                captchaToken: getNetworkProviderFromNetworkId.consumeCaptchaToken(client),
                code: dynamicOauthCode,
                codeVerifier,
                state: dynamicOauthState
            },
            providerType: provider
        });
    }
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    return response.user;
};

/**
 * Detects if the current URL is an OAuth redirect from a social provider.
 *
 * This function examines the URL parameters to determine if it contains
 * OAuth callback data from a social authentication flow.
 *
 * @param params.url - The URL to check for OAuth redirect parameters.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to true if the URL is an OAuth redirect, false otherwise.
 */ const detectOAuthRedirect = async ({ url }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const dynamicOauthState = url.searchParams.get('dynamicOauthState');
    const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');
    if (!dynamicOauthState || !dynamicOauthCode) {
        return false;
    }
    // Wait for SDK to load
    await core.initTrack.waitForAll();
    const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageKeySchema);
    if (!storedSocialRedirectState || storedSocialRedirectState.state !== dynamicOauthState) {
        return false;
    }
    return true;
};

/**
 * Retrieves token balances across multiple blockchain networks.
 *
 * This function fetches cryptocurrency and token balances for the user's
 * wallet addresses across different chains, networks and addresses specified in the request.
 *
 * @param params.balanceRequest - The balance request configuration specifying which chains, networks and addresses to query.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the chain balances across multiple networks.
 */ const getMultichainBalances = async ({ balanceRequest }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.postMultichainAccountBalances({
        environmentId: core.environmentId,
        multichainAccountBalancesRequest: balanceRequest
    });
    return response.chainBalances;
};

/**
 * Allows waiting until all modules of the client have been properly initialized
 * and are ready for use.
 *
 * @returns a promise that resolves once the client is fully initialized.
 */ const waitForClientInitialized = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    await core.initTrack.waitForAll();
};

/**
 * Updates the current user's profile information.
 *
 * This function allows updating various user fields such as email, name,
 * and other profile information. Some updates may require OTP verification,
 * like email and phone number.
 *
 * @param params.userFields - The user fields to update.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to OTP verification details if verification is required, or undefined.
 */ const updateUser = async ({ userFields }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({
        includeMfaToken: true
    }, client);
    const response = await apiClient.updateSelf({
        environmentId: core.environmentId,
        userFields
    });
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    if (response.emailVerification) {
        return {
            email: response.emailVerification.email,
            verificationUUID: response.emailVerification.verificationUUID
        };
    }
    if (response.smsVerification) {
        return {
            isoCountryCode: response.smsVerification.isoCountryCode,
            phoneCountryCode: response.smsVerification.phoneCountryCode,
            phoneNumber: response.smsVerification.phoneNumber,
            verificationUUID: response.smsVerification.verificationUUID
        };
    }
    return undefined;
};

/**
 * Acknowledges that the user has viewed and saved their MFA recovery codes.
 *
 * This function marks the recovery codes as acknowledged, indicating that
 * the user has properly backed up their MFA recovery codes for account recovery.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the acknowledgment is complete.
 */ const acknowledgeRecoveryCodes = async (client = constants.getDefaultClient())=>{
    return updateUser({
        userFields: {
            mfaBackupCodeAcknowledgement: sdkApiCore.MfaBackupCodeAcknowledgement.Complete
        }
    }, client);
};

/**
 * Authenticates using an MFA recovery code.
 *
 * This function allows users to bypass normal MFA requirements by using
 * one of their backup recovery codes when none of the registered MFA methods are available.
 *
 * @param params.code - The recovery code to authenticate with.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the MFA authentication response with token.
 */ const authenticateMfaRecoveryCode = async ({ code, createMfaTokenOptions }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    try {
        const response = await apiClient.authMfaRecovery({
            environmentId: core.environmentId,
            mFAAuthRecoveryDevicePostRequest: {
                code,
                createMfaToken: createMfaTokenOptions
            }
        });
        getWalletProviderByKey.updateAuthFromVerifyResponse({
            response
        }, client);
        getWalletProviderByKey.emitEvent({
            args: {
                mfaToken: response.mfaToken
            },
            event: 'mfaCompletionSuccess'
        }, client);
        return response;
    } catch (error) {
        getWalletProviderByKey.emitEvent({
            args: {
                error
            },
            event: 'mfaCompletionFailure'
        }, client);
        throw error;
    }
};

const getPasskeyAuthenticationOptions = async ({ relatedOriginRpId } = {}, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const options = await apiClient.getPasskeyAuthenticationOptions({
        environmentId: core.environmentId,
        relatedOriginRpId
    });
    return options;
};

const serverAuthenticatePasskey = async ({ authentication, createMfaToken }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const response = await apiClient.authenticateMfaPasskeyDevice({
        environmentId: core.environmentId,
        passkeyAuthRequest: constants._extends({}, authentication, {
            createMfaToken,
            response: constants._extends({}, authentication.response, {
                clientDataJson: authentication.response.clientDataJSON
            })
        })
    });
    return response;
};

/**
 * Authenticates using a passkey for multi-factor authentication.
 *
 * This function prompts the user to authenticate with their registered
 * passkey to complete an MFA challenge and obtain an MFA token.
 *
 * @param [params.createMfaToken] - Optional configuration for MFA token creation.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the MFA authentication response.
 * @throws NoWebAuthNSupportError If WebAuthn is not supported by the browser.
 * @throws NoPasskeyCredentialsFoundError If no passkey credentials are found.
 */ const authenticatePasskeyMFA = async ({ createMfaToken, relatedOriginRpId } = {}, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    try {
        var _options_allowCredentials;
        if (!core.passkey.isSupported()) {
            throw new NoWebAuthNSupportError();
        }
        const options = await getPasskeyAuthenticationOptions({
            relatedOriginRpId
        }, client);
        const allowCredentials = (_options_allowCredentials = options.allowCredentials) == null ? void 0 : _options_allowCredentials.map((credential)=>constants._extends({}, credential, {
                type: 'public-key'
            }));
        if (!(allowCredentials == null ? void 0 : allowCredentials.length)) {
            throw new NoPasskeyCredentialsFoundError();
        }
        // Ensure allowCredentials has the required type property
        const formattedOptions = constants._extends({}, options, {
            allowCredentials
        });
        const authentication = await core.passkey.authenticate({
            optionsJSON: formattedOptions
        });
        const response = await serverAuthenticatePasskey({
            authentication,
            createMfaToken
        }, client);
        getWalletProviderByKey.updateAuthFromVerifyResponse({
            response
        }, client);
        getWalletProviderByKey.emitEvent({
            args: {
                mfaToken: response.mfaToken
            },
            event: 'mfaCompletionSuccess'
        }, client);
        return response;
    } catch (error) {
        getWalletProviderByKey.emitEvent({
            args: {
                error
            },
            event: 'mfaCompletionFailure'
        }, client);
        throw error;
    }
};

/**
 * Authenticates using a TOTP (Time-based One-Time Password) MFA device.
 *
 * This function validates a TOTP code from an authenticator app and returns
 * an MFA token upon successful authentication.
 *
 * @param params.code - The 6-digit TOTP code from the authenticator app.
 * @param [params.deviceId] - The ID of the specific TOTP device to authenticate with.
 * @param [params.createMfaTokenOptions] - Optional configuration for MFA token creation.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the MFA authentication response.
 */ const authenticateTotpMfaDevice = async ({ deviceId, code, createMfaTokenOptions }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    try {
        const response = await apiClient.authMfaTotpDevice({
            environmentId: core.environmentId,
            mFAAuthTotpDevicePostRequest: {
                code,
                createMfaToken: createMfaTokenOptions,
                id: deviceId
            }
        });
        getWalletProviderByKey.updateAuthFromVerifyResponse({
            response
        }, client);
        getWalletProviderByKey.emitEvent({
            args: {
                deviceId,
                mfaToken: response.mfaToken
            },
            event: 'mfaCompletionSuccess'
        }, client);
        return response;
    } catch (error) {
        getWalletProviderByKey.emitEvent({
            args: {
                deviceId,
                error
            },
            event: 'mfaCompletionFailure'
        }, client);
        throw error;
    }
};

/**
 * Generates new MFA recovery codes for the current user.
 *
 * This function creates a fresh set of backup codes that can be used
 * to bypass MFA requirements if none of the registered MFA methods are available.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the newly generated recovery codes.
 */ const createNewMfaRecoveryCodes = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    return apiClient.createNewRecoveryCodes({
        environmentId: core.environmentId
    });
};

/**
 * Deletes a specific MFA device from the user's account.
 *
 * This function removes a multi-factor authentication device such as
 * a TOTP authenticator from the user's registered devices.
 *
 * @param params.deviceId - The unique identifier of the MFA device to delete.
 * @param params.mfaAuthToken - The MFA authentication token required for device deletion.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the MFA device is successfully deleted.
 */ const deleteMfaDevice = async ({ deviceId, mfaAuthToken }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    constants.assertDefined(deviceId, 'deviceId is required');
    constants.assertDefined(mfaAuthToken, 'mfaAuthToken is required');
    return apiClient.deleteMfaDevice({
        environmentId: core.environmentId,
        mfaDeviceId: deviceId,
        xMfaAuthToken: mfaAuthToken
    });
};

/**
 * Retrieves all MFA devices registered for the current user.
 *
 * This function fetches the list of multi-factor authentication devices
 * associated with the user's account, such as TOTP authenticators.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an array of the user's registered MFA devices.
 */ const getMfaDevices = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const { devices } = await apiClient.getUserMfaDevices({
        environmentId: core.environmentId
    });
    return devices;
};

/**
 * Retrieves the current MFA recovery codes for the user.
 *
 * This function fetches the backup codes that can be used to bypass
 * MFA requirements if none of the registered MFA methods are available.
 * If user doesn't have any recovery codes, it will create them,
 * otherwise it will return the existing ones.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the user's MFA recovery codes.
 */ const getMfaRecoveryCodes = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    return apiClient.getRecoveryCodes({
        environmentId: core.environmentId
    });
};

/**
 * Checks if the user is still pending acknowledgment of their MFA recovery codes.
 *
 * This function determines whether the user has been presented with recovery
 * codes that they have not yet acknowledged as saved or backed up.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns True if recovery codes are pending acknowledgment, false otherwise.
 */ const isPendingRecoveryCodesAcknowledgment = (client = constants.getDefaultClient())=>{
    const user = client.user;
    constants.assertDefined(user, 'User not logged in');
    return user.mfaBackupCodeAcknowledgement !== sdkApiCore.MfaBackupCodeAcknowledgement.Complete;
};

/**
 * Checks if the user requires additional MFA authentication.
 *
 * This function determines if the current user session requires
 * additional multi-factor authentication to access certain features.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns True if the user needs additional MFA authentication, false otherwise.
 */ const isUserMissingMfaAuth = (client = constants.getDefaultClient())=>{
    var _user_scope;
    const user = client.user;
    constants.assertDefined(user, 'User not logged in');
    return Boolean((_user_scope = user.scope) == null ? void 0 : _user_scope.includes('requiresAdditionalAuth'));
};

/**
 * Registers a new TOTP (Time-based One-Time Password) MFA device.
 *
 * This function initiates the registration of a TOTP authenticator app
 * (like Google Authenticator or Authy) for multi-factor authentication.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the TOTP registration response containing setup information,
 * like the secret key and the OTP Auth URI.
 */ const registerTotpMfaDevice = async (client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    return apiClient.registerTotpMfaDevice({
        environmentId: core.environmentId
    });
};

/**
 * Sets the default MFA device for the current user.
 *
 * This function designates a specific MFA TOTP device as the primary method
 * for multi-factor authentication challenges.
 *
 * @param params.deviceId - The unique identifier of the MFA device to set as default.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the default MFA device is successfully set.
 */ const setDefaultMfaDevice = async ({ deviceId }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    constants.assertDefined(deviceId, 'deviceId is required');
    // All that this endpoint does is set the default device to the one provided.
    return apiClient.updateUserMfaDevice({
        environmentId: core.environmentId,
        mfaDeviceId: deviceId
    });
};

/**
 * Sends a one-time password (OTP) to the specified email address.
 *
 * Once you have the OTP code, you should then use `verifyOTP` to verify it and complete the authentication process.
 *
 * @param params.email - The email address to send the OTP to.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an OTPVerification object containing the email and verification UUID.
 */ const sendEmailOTP = async ({ email }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const { verificationUUID } = await apiClient.createEmailVerification({
        emailVerificationCreateRequest: {
            captchaToken: getNetworkProviderFromNetworkId.consumeCaptchaToken(client),
            email
        },
        environmentId: core.environmentId
    });
    return {
        email,
        verificationUUID
    };
};

// Source:
// https://github.com/dynamic-labs/redcoast/blob/main/apps/dashboard/src/app/routes/Configurations/Providers/components/SmsProviderSection/utils/countries.ts
// these are the countries was populated based on the wikipedia page
// referenced in twilio's docs: https://www.twilio.com/docs/voice/api/dialingpermissions-country-resource
// and this doc for country codes: https://www.itu.int/itudoc/itu-t/ob-lists/icc/e164_763.pdf
const supportedCountries = {
    AC: {
        code: '247',
        name: 'Ascension'
    },
    AD: {
        code: '376',
        name: 'Andorra'
    },
    AE: {
        code: '971',
        name: 'United Arab Emirates'
    },
    AF: {
        code: '93',
        name: 'Afghanistan'
    },
    AG: {
        code: '1268',
        name: 'Antigua and Barbuda'
    },
    AI: {
        code: '1264',
        name: 'Anguilla'
    },
    AL: {
        code: '355',
        name: 'Albania'
    },
    AM: {
        code: '374',
        name: 'Armenia'
    },
    AO: {
        code: '244',
        name: 'Angola'
    },
    AR: {
        code: '54',
        name: 'Argentina'
    },
    AS: {
        code: '1684',
        name: 'American Samoa'
    },
    AT: {
        code: '43',
        name: 'Austria'
    },
    AU: {
        code: '61',
        name: 'Australia/Cocos/Christmas Island'
    },
    AW: {
        code: '297',
        name: 'Aruba'
    },
    AZ: {
        code: '994',
        name: 'Azerbaijan'
    },
    BA: {
        code: '387',
        name: 'Bosnia and Herzegovina'
    },
    BB: {
        code: '1246',
        name: 'Barbados'
    },
    BD: {
        code: '880',
        name: 'Bangladesh'
    },
    BE: {
        code: '32',
        name: 'Belgium'
    },
    BF: {
        code: '226',
        name: 'Burkina Faso'
    },
    BG: {
        code: '359',
        name: 'Bulgaria'
    },
    BH: {
        code: '973',
        name: 'Bahrain'
    },
    BI: {
        code: '257',
        name: 'Burundi'
    },
    BJ: {
        code: '229',
        name: 'Benin'
    },
    BM: {
        code: '1441',
        name: 'Bermuda'
    },
    BN: {
        code: '673',
        name: 'Brunei'
    },
    BO: {
        code: '591',
        name: 'Bolivia'
    },
    BR: {
        code: '55',
        name: 'Brazil'
    },
    BS: {
        code: '1242',
        name: 'Bahamas'
    },
    BT: {
        code: '975',
        name: 'Bhutan'
    },
    BW: {
        code: '267',
        name: 'Botswana'
    },
    BY: {
        code: '375',
        name: 'Belarus'
    },
    BZ: {
        code: '501',
        name: 'Belize'
    },
    CA: {
        code: '1',
        name: 'Canada'
    },
    CD: {
        code: '243',
        name: 'Congo, Dem Rep'
    },
    CF: {
        code: '236',
        name: 'Central Africa'
    },
    CG: {
        code: '242',
        name: 'Congo'
    },
    CH: {
        code: '41',
        name: 'Switzerland'
    },
    CI: {
        code: '225',
        name: 'Ivory Coast'
    },
    CK: {
        code: '682',
        name: 'Cook Islands'
    },
    CL: {
        code: '56',
        name: 'Chile'
    },
    CM: {
        code: '237',
        name: 'Cameroon'
    },
    CN: {
        code: '86',
        name: 'China'
    },
    CO: {
        code: '57',
        name: 'Colombia'
    },
    CR: {
        code: '506',
        name: 'Costa Rica'
    },
    CU: {
        code: '53',
        name: 'Cuba'
    },
    CV: {
        code: '238',
        name: 'Cape Verde'
    },
    CW: {
        code: '599',
        name: 'CuraÃ§ao and Caribbean Netherlands (Bonaire, Sint Eustatius, Sint Maarten, Saba)'
    },
    CY: {
        code: '357',
        name: 'Cyprus'
    },
    CZ: {
        code: '420',
        name: 'Czech Republic'
    },
    DE: {
        code: '49',
        name: 'Germany'
    },
    DJ: {
        code: '253',
        name: 'Djibouti'
    },
    DK: {
        code: '45',
        name: 'Denmark'
    },
    DM: {
        code: '1767',
        name: 'Dominica'
    },
    DO: {
        code: '1829',
        name: 'Dominican Republic'
    },
    DZ: {
        code: '213',
        name: 'Algeria'
    },
    EC: {
        code: '593',
        name: 'Ecuador'
    },
    EE: {
        code: '372',
        name: 'Estonia'
    },
    EG: {
        code: '20',
        name: 'Egypt'
    },
    ER: {
        code: '291',
        name: 'Eritrea'
    },
    ES: {
        code: '34',
        name: 'Spain'
    },
    ET: {
        code: '251',
        name: 'Ethiopia'
    },
    FI: {
        code: '358',
        name: 'Finland/Aland Islands'
    },
    FJ: {
        code: '679',
        name: 'Fiji'
    },
    FK: {
        code: '500',
        name: 'Falkland Islands'
    },
    FM: {
        code: '691',
        name: 'Micronesia'
    },
    FO: {
        code: '298',
        name: 'Faroe Islands'
    },
    FR: {
        code: '33',
        name: 'France'
    },
    GA: {
        code: '241',
        name: 'Gabon'
    },
    GB: {
        code: '44',
        name: 'United Kingdom'
    },
    GD: {
        code: '1473',
        name: 'Grenada'
    },
    GE: {
        code: '995',
        name: 'Georgia'
    },
    GF: {
        code: '594',
        name: 'French Guiana'
    },
    GG: {
        code: '44',
        name: 'Guernsey/Jersey'
    },
    GH: {
        code: '233',
        name: 'Ghana'
    },
    GI: {
        code: '350',
        name: 'Gibraltar'
    },
    GL: {
        code: '299',
        name: 'Greenland'
    },
    GM: {
        code: '220',
        name: 'Gambia'
    },
    GN: {
        code: '224',
        name: 'Guinea'
    },
    GP: {
        code: '590',
        name: 'Guadeloupe'
    },
    GQ: {
        code: '240',
        name: 'Equatorial Guinea'
    },
    GR: {
        code: '30',
        name: 'Greece'
    },
    GT: {
        code: '502',
        name: 'Guatemala'
    },
    GU: {
        code: '1671',
        name: 'Guam'
    },
    GW: {
        code: '245',
        name: 'Guinea-Bissau'
    },
    GY: {
        code: '592',
        name: 'Guyana'
    },
    HK: {
        code: '852',
        name: 'Hong Kong'
    },
    HN: {
        code: '504',
        name: 'Honduras'
    },
    HR: {
        code: '385',
        name: 'Croatia'
    },
    HT: {
        code: '509',
        name: 'Haiti'
    },
    HU: {
        code: '36',
        name: 'Hungary'
    },
    IC: {
        code: '3491',
        name: 'Canary Islands'
    },
    ID: {
        code: '62',
        name: 'Indonesia'
    },
    IE: {
        code: '353',
        name: 'Ireland'
    },
    IL: {
        code: '972',
        name: 'Israel'
    },
    IM: {
        code: '44',
        name: 'Isle of Man'
    },
    IN: {
        code: '91',
        name: 'India'
    },
    IQ: {
        code: '964',
        name: 'Iraq'
    },
    IR: {
        code: '98',
        name: 'Iran'
    },
    IS: {
        code: '354',
        name: 'Iceland'
    },
    IT: {
        code: '39',
        name: 'Italy'
    },
    JM: {
        code: '1876',
        name: 'Jamaica'
    },
    JO: {
        code: '962',
        name: 'Jordan'
    },
    JP: {
        code: '81',
        name: 'Japan'
    },
    KE: {
        code: '254',
        name: 'Kenya'
    },
    KG: {
        code: '996',
        name: 'Kyrgyzstan'
    },
    KH: {
        code: '855',
        name: 'Cambodia'
    },
    KI: {
        code: '686',
        name: 'Kiribati'
    },
    KM: {
        code: '269',
        name: 'Comoros'
    },
    KN: {
        code: '1869',
        name: 'St Kitts and Nevis'
    },
    KP: {
        code: '850',
        name: "Korea Dem People's Rep"
    },
    KR: {
        code: '82',
        name: 'Korea Republic of'
    },
    KW: {
        code: '965',
        name: 'Kuwait'
    },
    KY: {
        code: '1345',
        name: 'Cayman Islands'
    },
    LA: {
        code: '856',
        name: 'Laos PDR'
    },
    LB: {
        code: '961',
        name: 'Lebanon'
    },
    LC: {
        code: '1758',
        name: 'St Lucia'
    },
    LI: {
        code: '423',
        name: 'Liechtenstein'
    },
    LK: {
        code: '94',
        name: 'Sri Lanka'
    },
    LR: {
        code: '231',
        name: 'Liberia'
    },
    LS: {
        code: '266',
        name: 'Lesotho'
    },
    LT: {
        code: '370',
        name: 'Lithuania'
    },
    LU: {
        code: '352',
        name: 'Luxembourg'
    },
    LV: {
        code: '371',
        name: 'Latvia'
    },
    LY: {
        code: '218',
        name: 'Libya'
    },
    MA: {
        code: '212',
        name: 'Morocco/Western Sahara'
    },
    MC: {
        code: '377',
        name: 'Monaco'
    },
    MD: {
        code: '373',
        name: 'Moldova'
    },
    ME: {
        code: '382',
        name: 'Montenegro'
    },
    MG: {
        code: '261',
        name: 'Madagascar'
    },
    MH: {
        code: '692',
        name: 'Marshall Islands'
    },
    MK: {
        code: '389',
        name: 'Republic of North Macedonia'
    },
    ML: {
        code: '223',
        name: 'Mali'
    },
    MM: {
        code: '95',
        name: 'Myanmar (Burma)'
    },
    MN: {
        code: '976',
        name: 'Mongolia'
    },
    MO: {
        code: '853',
        name: 'Macau'
    },
    MP: {
        code: '1670',
        name: 'Northern Mariana Islands'
    },
    MQ: {
        code: '596',
        name: 'Martinique'
    },
    MR: {
        code: '222',
        name: 'Mauritania'
    },
    MS: {
        code: '1664',
        name: 'Montserrat'
    },
    MT: {
        code: '356',
        name: 'Malta'
    },
    MU: {
        code: '230',
        name: 'Mauritius'
    },
    MV: {
        code: '960',
        name: 'Maldives'
    },
    MW: {
        code: '265',
        name: 'Malawi'
    },
    MX: {
        code: '52',
        name: 'Mexico'
    },
    MY: {
        code: '60',
        name: 'Malaysia'
    },
    MZ: {
        code: '258',
        name: 'Mozambique'
    },
    NA: {
        code: '264',
        name: 'Namibia'
    },
    NC: {
        code: '687',
        name: 'New Caledonia'
    },
    NE: {
        code: '227',
        name: 'Niger'
    },
    NF: {
        code: '672',
        name: 'Norfolk Island'
    },
    NG: {
        code: '234',
        name: 'Nigeria'
    },
    NI: {
        code: '505',
        name: 'Nicaragua'
    },
    NL: {
        code: '31',
        name: 'Netherlands'
    },
    NO: {
        code: '47',
        name: 'Norway'
    },
    NP: {
        code: '977',
        name: 'Nepal'
    },
    NU: {
        code: '683',
        name: 'Niue'
    },
    NZ: {
        code: '64',
        name: 'New Zealand'
    },
    OM: {
        code: '968',
        name: 'Oman'
    },
    PA: {
        code: '507',
        name: 'Panama'
    },
    PE: {
        code: '51',
        name: 'Peru'
    },
    PF: {
        code: '689',
        name: 'French Polynesia'
    },
    PG: {
        code: '675',
        name: 'Papua New Guinea'
    },
    PH: {
        code: '63',
        name: 'Philippines'
    },
    PK: {
        code: '92',
        name: 'Pakistan'
    },
    PL: {
        code: '48',
        name: 'Poland'
    },
    PM: {
        code: '508',
        name: 'St Pierre and Miquelon'
    },
    PR: {
        code: '1787',
        name: 'Puerto Rico'
    },
    PS: {
        code: '970, 972',
        name: 'Palestinian Territory'
    },
    PT: {
        code: '351',
        name: 'Portugal'
    },
    PW: {
        code: '680',
        name: 'Palau'
    },
    PY: {
        code: '595',
        name: 'Paraguay'
    },
    QA: {
        code: '974',
        name: 'Qatar'
    },
    RE: {
        code: '262',
        name: 'Reunion/Mayotte'
    },
    RO: {
        code: '40',
        name: 'Romania'
    },
    RS: {
        code: '381',
        name: 'Serbia'
    },
    RU: {
        code: '7',
        name: 'Russia/Kazakhstan'
    },
    RW: {
        code: '250',
        name: 'Rwanda'
    },
    SA: {
        code: '966',
        name: 'Saudi Arabia'
    },
    SB: {
        code: '677',
        name: 'Solomon Islands'
    },
    SC: {
        code: '248',
        name: 'Seychelles'
    },
    SD: {
        code: '249',
        name: 'Sudan'
    },
    SE: {
        code: '46',
        name: 'Sweden'
    },
    SG: {
        code: '65',
        name: 'Singapore'
    },
    SI: {
        code: '386',
        name: 'Slovenia'
    },
    SK: {
        code: '421',
        name: 'Slovakia'
    },
    SL: {
        code: '232',
        name: 'Sierra Leone'
    },
    SM: {
        code: '378',
        name: 'San Marino'
    },
    SN: {
        code: '221',
        name: 'Senegal'
    },
    SO: {
        code: '252',
        name: 'Somalia'
    },
    SR: {
        code: '597',
        name: 'Suriname'
    },
    SS: {
        code: '211',
        name: 'South Sudan'
    },
    ST: {
        code: '239',
        name: 'Sao Tome and Principe'
    },
    SV: {
        code: '503',
        name: 'El Salvador'
    },
    SY: {
        code: '963',
        name: 'Syria'
    },
    SZ: {
        code: '268',
        name: 'Swaziland'
    },
    TC: {
        code: '1649',
        name: 'Turks and Caicos Islands'
    },
    TD: {
        code: '235',
        name: 'Chad'
    },
    TG: {
        code: '228',
        name: 'Togo'
    },
    TH: {
        code: '66',
        name: 'Thailand'
    },
    TJ: {
        code: '992',
        name: 'Tajikistan'
    },
    TL: {
        code: '670',
        name: 'East Timor'
    },
    TM: {
        code: '993',
        name: 'Turkmenistan'
    },
    TN: {
        code: '216',
        name: 'Tunisia'
    },
    TO: {
        code: '676',
        name: 'Tonga'
    },
    TR: {
        code: '90',
        name: 'Turkiye'
    },
    TT: {
        code: '1868',
        name: 'Trinidad and Tobago'
    },
    TV: {
        code: '688',
        name: 'Tuvalu'
    },
    TW: {
        code: '886',
        name: 'Taiwan'
    },
    TZ: {
        code: '255',
        name: 'Tanzania'
    },
    UA: {
        code: '380',
        name: 'Ukraine'
    },
    UG: {
        code: '256',
        name: 'Uganda'
    },
    US: {
        code: '1',
        name: 'United States'
    },
    UY: {
        code: '598',
        name: 'Uruguay'
    },
    UZ: {
        code: '998',
        name: 'Uzbekistan'
    },
    VA: {
        code: '379',
        name: 'Vatican City'
    },
    VC: {
        code: '1784',
        name: 'St Vincent Grenadines'
    },
    VE: {
        code: '58',
        name: 'Venezuela'
    },
    VG: {
        code: '1284',
        name: 'Virgin Islands, British'
    },
    VI: {
        code: '1340',
        name: 'Virgin Islands, U.S.'
    },
    VN: {
        code: '84',
        name: 'Vietnam'
    },
    VU: {
        code: '678',
        name: 'Vanuatu'
    },
    WF: {
        code: '681',
        name: 'Wallis and Futuna'
    },
    WS: {
        code: '685',
        name: 'Samoa'
    },
    XK: {
        code: '383',
        name: 'Kosovo'
    },
    YE: {
        code: '967',
        name: 'Yemen'
    },
    ZA: {
        code: '27',
        name: 'South Africa'
    },
    ZM: {
        code: '260',
        name: 'Zambia'
    },
    ZW: {
        code: '263',
        name: 'Zimbabwe'
    }
};

/**
 * Sends a one-time password (OTP) via SMS to the specified phone number.
 *
 * @param params.isoCountryCode - The ISO country code for the phone number (e.g., 'US', 'CA', 'GB').
 * @param params.phoneNumber - The phone number to send the OTP to.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an OTPVerification object containing the phone details and verification UUID.
 */ const sendSmsOTP = async ({ isoCountryCode, phoneNumber }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const phoneCountryCode = supportedCountries[isoCountryCode].code;
    const { verificationUUID } = await apiClient.createSmsVerification({
        environmentId: core.environmentId,
        smsVerificationCreateRequest: {
            captchaToken: getNetworkProviderFromNetworkId.consumeCaptchaToken(client),
            isoCountryCode,
            phoneCountryCode,
            phoneNumber
        }
    });
    return {
        isoCountryCode,
        phoneCountryCode,
        phoneNumber,
        verificationUUID
    };
};

const verifyOTPForUserSignIn = async ({ otpVerification, verificationToken }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const verifyRequest = {
        verificationToken,
        verificationUUID: otpVerification.verificationUUID
    };
    if (otpVerification.email) {
        return apiClient.signInWithEmailVerification({
            emailVerificationVerifyRequest: verifyRequest,
            environmentId: core.environmentId
        });
    }
    return apiClient.signInWithSmsVerification({
        environmentId: core.environmentId,
        smsVerificationVerifyRequest: verifyRequest
    });
};

const verifyOTPForUserUpdate = async ({ otpVerification, verificationToken }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const verifyRequest = {
        verificationToken,
        verificationUUID: otpVerification.verificationUUID
    };
    if (otpVerification.email) {
        return apiClient.verifyEmailVerification({
            emailVerificationVerifyRequest: verifyRequest,
            environmentId: core.environmentId
        });
    }
    return apiClient.verifySmsVerification({
        environmentId: core.environmentId,
        smsVerificationVerifyRequest: verifyRequest
    });
};

/**
 * Verifies a one-time password (OTP) for user authentication or updates.
 *
 * This function validates the OTP code provided by the user and completes
 * the verification process for either sign-in or account updates.
 *
 * @param params.otpVerification - The OTP verification object containing verification details.
 * @param params.verificationToken - The token received from the OTP verification process.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the user object upon successful verification.
 */ const verifyOTP = async ({ otpVerification, verificationToken }, client = constants.getDefaultClient())=>{
    const verifyOTPFunction = client.user ? verifyOTPForUserUpdate : verifyOTPForUserSignIn;
    const response = await verifyOTPFunction({
        otpVerification,
        verificationToken
    }, client);
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    return response.user;
};

/**
 * Asserts that a wallet account is available and ready for signing operations.
 *
 * This function verifies that the specified wallet account is currently
 * connected and selected in the wallet app, ensuring it can perform signing operations.
 *
 * If the wallet account is not available, the user might need to reconnect it or
 * change the account in their wallet app to make it active.
 *
 * @param params.walletAccount - The wallet account to verify signing availability for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves if the wallet is available for signing.
 * @throws WalletAccountNotSelectedError If the wallet account is not currently selected.
 */ const assertWalletAccountSigningAvailability = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    const { addresses } = await walletProvider.getConnectedAddresses();
    if (!addresses.includes(walletAccount.address)) {
        throw new WalletAccountNotSelectedError({
            expectedAddress: walletAccount.address,
            selectedAddress: addresses[0]
        });
    }
};

/**
 * Asserts that a specific wallet provider method is defined, throwing an error if it's not.
 * This function acts as a type guard, narrowing the type to ensure the method exists.
 *
 * @template T - The specific wallet provider method key being checked
 * @param walletProvider - The wallet provider object to check
 * @param methodName - The name of the method to check for availability
 * @throws Throws WalletProviderMethodUnavailableError if the method is not defined
 * @example
 * ```typescript
 * const walletProvider: WalletProvider = getWalletProvider();
 * assertWalletProviderMethodDefined(walletProvider, 'connect');
 * // walletProvider.connect is now guaranteed to be defined
 * await walletProvider.connect();
 * ```
 */ function assertWalletProviderMethodDefined(walletProvider, methodName) {
    if (walletProvider[methodName] === undefined) {
        throw new WalletProviderMethodUnavailableError({
            methodName: methodName,
            walletProviderKey: walletProvider.key
        });
    }
}

const getAddressesWithTypesFromConnectionResult = (connectionResult)=>{
    return connectionResult.addresses.filter((address)=>!!address.address && !!address.type);
};

/**
 * Connects to a wallet provider and returns the connected wallet account.
 *
 * Note: This function will not verify the wallet account, use the verifyWalletAccount function to do that
 * or connectAndVerifyWithWalletProvider to do that in a single step.
 * @see verifyWalletAccount
 * @see connectAndVerifyWithWalletProvider
 *
 * @param params.walletProviderKey - The unique key identifying the wallet provider to connect to (e.g. 'metamaskevm', 'phantomsol').
 * @param [params.addToDynamicWalletAccounts] - Whether to add the connected wallet account to the user's wallet accounts. Defaults to true.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the connected wallet account.
 * @throws NoAddressFoundError If the request to connect was successful but no address is connected to your app.
 */ const connectWithWalletProvider = async ({ walletProviderKey, addToDynamicWalletAccounts = true }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey
    }, client);
    assertWalletProviderMethodDefined(walletProvider, 'connect');
    const { addresses } = await walletProvider.connect();
    const currentAddresses = getWalletProviderByKey.getWalletAccounts(client).map(({ address })=>address);
    const mainAddress = (addresses == null ? void 0 : addresses.length) ? addresses[0].address : null;
    /**
   * This error is thrown in case the wallet has no addresses connected
   * to the dapp. Then the error is thrown so the consumer can instruct the
   * user on the next steps.
   */ if (!mainAddress) {
        throw new NoAddressFoundError();
    }
    const walletAccount = {
        address: mainAddress,
        addressesWithTypes: getAddressesWithTypesFromConnectionResult({
            addresses
        }),
        chain: walletProvider.chain,
        id: getWalletProviderByKey.formatWalletAccountId({
            address: mainAddress,
            chain: walletProvider.chain,
            walletProviderKey
        }),
        lastSelectedAt: null,
        verifiedCredentialId: null,
        walletProviderKey
    };
    if (currentAddresses.includes(mainAddress)) {
        return walletAccount;
    }
    if (addToDynamicWalletAccounts) {
        getNetworkProviderFromNetworkId.setUnverifiedWalletAccounts({
            unverifiedWalletAccountsToUpdate: [
                walletAccount
            ]
        }, client);
        getWalletProviderByKey.emitWalletAccountsChangedEvent(client);
        /*
     * send information to backend to kick off background jobs
     * this is an async work, but does not need to be awaited
     */ void getNetworkProviderFromNetworkId.createVisit({
            walletAccount
        }, client);
    }
    return walletAccount;
};

const getChainIdForAccountVerification = async ({ walletProvider })=>{
    // for some chains, we don't need to specify a chain id for account verification because it's
    // not required and it might break the message signature in some wallets (e.g. Trust Wallet SOL)
    const chainsThatDontNeedChainId = [
        'BTC',
        'SOL',
        'SUI'
    ];
    if (chainsThatDontNeedChainId.includes(walletProvider.chain)) {
        return undefined;
    }
    const { networkId } = await walletProvider.getActiveNetworkId();
    if (networkId) {
        return networkId;
    }
    // default to ethereum mainnet
    if (walletProvider.chain === 'EVM') {
        return '1';
    }
    return undefined;
};

const getSignInMessage = async ({ walletAccount }, client)=>{
    var _core_metadata;
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const appUrl = (_core_metadata = core.metadata) == null ? void 0 : _core_metadata.url;
    constants.assertDefined(appUrl, 'App URL is not set');
    const url = new URL(appUrl);
    const { nonce } = await apiClient.getNonce({
        environmentId: core.environmentId
    });
    constants.assertDefined(nonce, 'Failed to get nonce');
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    const statement = getNetworkProviderFromNetworkId.createSignInMessageStatement(client);
    const messageToSign = await getNetworkProviderFromNetworkId.formatSignInMessage({
        address: walletAccount.address,
        blockchainName: constants.CHAINS_INFO_MAP[walletProvider.chain].blockchainName,
        chainId: await getChainIdForAccountVerification({
            walletProvider
        }),
        domain: url.host,
        issuedAt: new Date().toISOString(),
        nonce,
        requestId: core.environmentId,
        statement,
        uri: url.toString()
    });
    return messageToSign;
};

/**
 * Proves ownership of a wallet account by signing a verification message.
 *
 * This function generates a sign-in message and requires the user to sign it
 * with their wallet's private key, proving they control the wallet address.
 *
 * @param params.walletAccount - The wallet account to prove ownership of.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an object containing the message and signature.
 */ const proveWalletAccountOwnership = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    assertWalletProviderMethodDefined(walletProvider, 'signMessage');
    const messageToSign = await getSignInMessage({
        walletAccount
    }, client);
    const { signature } = await walletProvider.signMessage({
        message: messageToSign,
        walletAccount
    });
    return {
        messageToSign,
        signature
    };
};

/**
 * Removes an unverified wallet account from the client's state.
 */ const removeUnverifiedWalletAccount = ({ unverifiedWalletAccount }, client)=>{
    const core = constants.getCore(client);
    const previousState = core.state.get();
    const { unverifiedWalletAccounts } = core.state.get();
    const filteredUnverifiedWalletAccounts = unverifiedWalletAccounts.filter((account)=>account.id !== unverifiedWalletAccount.id);
    core.state.set({
        unverifiedWalletAccounts: filteredUnverifiedWalletAccounts
    });
    /**
   * We check before raising because the wallet account we are removing might still
   * be present in wallet accounts due to having been moved to verified credentials.
   */ getWalletProviderByKey.checkAndRaiseWalletAccountsChangedEvent({
        previousState
    }, client);
};

const isSameAddress = (left, right, chain)=>getWalletProviderByKey.normalizeAddress(left, chain) === getWalletProviderByKey.normalizeAddress(right, chain);

/**
 * Verifies ownership of a wallet account and adds it to the user's profile.
 *
 * This function requires the user to sign a message to prove wallet ownership,
 * then sets the wallet account as verified.
 *
 * @param params.walletAccount - The wallet account to verify ownership of.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the verified wallet account.
 * @throws WalletAccountAlreadyVerifiedError If the wallet is already verified.
 * @throws WalletAlreadyLinkedToAnotherUserError If the wallet is linked to another user.
 */ const verifyWalletAccount = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    var _response_user;
    if (walletAccount.verifiedCredentialId) {
        throw new WalletAccountAlreadyVerifiedError(walletAccount.address);
    }
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    const { messageToSign, signature } = await proveWalletAccountOwnership({
        walletAccount
    }, client);
    const response = await getNetworkProviderFromNetworkId.verifySignInMessage({
        addressesWithTypes: walletAccount.addressesWithTypes,
        chain: walletAccount.chain,
        messageToSign,
        signature,
        walletAddress: walletAccount.address,
        walletDisplayName: walletProvider.metadata.displayName,
        walletProviderType: walletProvider.walletProviderType
    }, client);
    const walletVerifiedCredential = (_response_user = response.user) == null ? void 0 : _response_user.verifiedCredentials.find((verifiedCredential)=>{
        var _verifiedCredential_address;
        return isSameAddress((_verifiedCredential_address = verifiedCredential.address) != null ? _verifiedCredential_address : '', walletAccount.address, walletAccount.chain);
    });
    constants.assertDefined(walletVerifiedCredential, `After verifying, still unable to find verified wallet credential for wallet account ${walletAccount.address} on chain ${walletAccount.chain}`);
    getNetworkProviderFromNetworkId.updateWalletProviderKeysForVerifiedCredentials({
        keysToUpdate: {
            [walletVerifiedCredential.id]: walletProvider.key
        }
    }, client);
    /**
   * Adds the user with the new wallet verified credential
   * This will add the new verified wallet account to the client`s state
   */ getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
    /**
   * Remove the now verified wallet account from the unverified wallet accounts
   */ removeUnverifiedWalletAccount({
        unverifiedWalletAccount: walletAccount
    }, client);
    const verifiedWalletAccount = getWalletProviderByKey.getWalletAccounts(client).find(({ address })=>isSameAddress(address, walletAccount.address, walletAccount.chain));
    constants.assertDefined(verifiedWalletAccount, `Unable to find wallet account ${walletAccount.address} on chain ${walletAccount.chain} for verified credential ${walletVerifiedCredential.id}`);
    return verifiedWalletAccount;
};

/**
 * Connects to a wallet provider and verifies ownership through message signing.
 *
 * This function combines wallet connection and verification in a single step,
 * requiring the user to sign a message to prove wallet ownership before
 * the wallet account is added to their profile.
 *
 * @param params.walletProviderKey - The unique key identifying the wallet provider to connect to.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the connected and verified wallet account.
 */ const connectAndVerifyWithWalletProvider = async ({ walletProviderKey }, client = constants.getDefaultClient())=>{
    const walletAccount = await connectWithWalletProvider({
        addToDynamicWalletAccounts: false,
        walletProviderKey
    }, client);
    await verifyWalletAccount({
        walletAccount
    }, client);
    /*
   * send information to backend to kick off background jobs
   * this is an async work, but does not need to be awaited
   */ void getNetworkProviderFromNetworkId.createVisit({
        authMode: sdkApiCore.AuthModeEnum.AndSign,
        walletAccount
    }, client);
    return walletAccount;
};

/**
 * Retrieves data for all available wallet providers that can be used for connection.
 *
 * This function returns metadata about wallet providers that users can
 * connect to, like MetaMask, Phantom, etc.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns An array of wallet provider data including chain, keys, and metadata.
 */ const getAvailableWalletProvidersData = (client = constants.getDefaultClient())=>{
    const allWalletProviders = getWalletProviderByKey.getWalletProviders(client);
    // This is to avoid returning the wallet providers that are connected via different means
    // than by the "connect" method â€” like the Dynamic Waas providers, AA providers, or WalletConnect providers.
    const filteredWalletProviders = allWalletProviders.filter((walletProvider)=>Boolean(walletProvider.connect));
    return filteredWalletProviders.map((walletProvider)=>({
            chain: walletProvider.chain,
            groupKey: walletProvider.groupKey,
            key: walletProvider.key,
            metadata: walletProvider.metadata,
            walletProviderType: walletProvider.walletProviderType
        }));
};

/**
 * Retrieves all connected addresses for a specific wallet provider.
 *
 * This function returns the list of wallet addresses that are currently
 * connected and available through the specified wallet provider.
 *
 * @param params.walletProviderKey - The unique key of the wallet provider to query.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns An array of connected wallet addresses.
 */ const getConnectedAddresses = ({ walletProviderKey }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey
    }, client);
    return walletProvider.getConnectedAddresses();
};

const getOwnerWalletAccountForSmartWalletAccount = ({ smartWalletAccount }, client = constants.getDefaultClient())=>{
    const smartWalletVerifiedCredential = getNetworkProviderFromNetworkId.getVerifiedCredentialForWalletAccount({
        walletAccount: smartWalletAccount
    }, client);
    constants.assertDefined(smartWalletVerifiedCredential == null ? void 0 : smartWalletVerifiedCredential.signerRefId, 'Invalid smart wallet account');
    return getWalletProviderByKey.getWalletAccounts(client).find((walletAccount)=>walletAccount.verifiedCredentialId === smartWalletVerifiedCredential.signerRefId);
};

const getWalletAccountAddressByType = ({ type, walletAccount })=>{
    var _walletAccount_addressesWithTypes_find, _walletAccount_addressesWithTypes;
    return (_walletAccount_addressesWithTypes = walletAccount.addressesWithTypes) == null ? void 0 : (_walletAccount_addressesWithTypes_find = _walletAccount_addressesWithTypes.find((address)=>address.type === type)) == null ? void 0 : _walletAccount_addressesWithTypes_find.address;
};

/**
 * Retrieves data for a specific wallet provider that can be used for display or connection.
 *
 * @param params.walletProviderKey - The key of the wallet provider to retrieve data for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns The data for the wallet provider.
 */ const getWalletProviderDataByKey = ({ walletProviderKey }, client = constants.getDefaultClient())=>{
    const { chain, groupKey, key, metadata, walletProviderType } = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey
    }, client);
    return {
        chain,
        groupKey,
        key,
        metadata,
        walletProviderType
    };
};

/**
 * Retrieves the network configuration data for the currently active network.
 *
 * This function returns detailed network information including RPC URLs,
 * native currency details, and block explorer URLs for the network that
 * the wallet account is currently connected to.
 *
 * @param params.walletAccount - The wallet account to get network data for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the network data, or undefined if not found.
 */ const getActiveNetworkData = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    const { networkId } = await walletProvider.getActiveNetworkId();
    const networksData = getNetworkProviderFromNetworkId.getNetworksData(client);
    const activeNetworkData = networksData.find((data)=>data.networkId === networkId && data.chain === walletProvider.chain);
    return {
        networkData: activeNetworkData
    };
};

/**
 * This function returns the network identifier that this wallet account's provider is currently connected to.
 *
 * @param params.walletAccount - The wallet account to get the network ID for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to the active network ID for the wallet account.
 */ const getActiveNetworkId = ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    return walletProvider.getActiveNetworkId();
};

/**
 * Retrieves the native token balance for a wallet account.
 *
 * This function fetches the balance of the native cryptocurrency
 * (e.g., ETH, SOL, BTC, etc.) for the specified wallet account.
 *
 * @param params.walletAccount - The wallet account to get the balance for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an object containing the balance as a string or null.
 */ const getBalance = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    const { networkId } = await walletProvider.getActiveNetworkId();
    const networkProvider = getNetworkProviderFromNetworkId.getNetworkProviderFromNetworkId({
        chain: walletProvider.chain,
        networkId
    }, client);
    return networkProvider.getBalance({
        address: walletAccount.address
    });
};

/**
 * Retrieves the native token balance for a specific address on a given network.
 *
 * This function queries the balance directly for any address without requiring
 * a connected wallet account, useful for checking balances of external addresses.
 *
 * @param params.address - The wallet address to check the balance for.
 * @param params.chain - The chain (e.g., 'EVM', 'SOL').
 * @param params.networkId - The specific network ID within the chain.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an object containing the balance as a string or null.
 */ const getBalanceForAddress = async ({ address, chain, networkId }, client = constants.getDefaultClient())=>{
    const networkProvider = getNetworkProviderFromNetworkId.getNetworkProviderFromNetworkId({
        chain,
        networkId
    }, client);
    constants.assertDefined(networkProvider, `No network found for chain ${chain} and network id ${networkId}. Please ensure you've enabled this network in the Dashboard.`);
    return networkProvider.getBalance({
        address
    });
};

/**
 * Checks if programmatic network switching is available for a wallet account.
 *
 * This function determines whether the wallet provider supports automatic
 * network switching without requiring the user to manually switch networks on their wallet app.
 *
 * @param params.walletAccount - The wallet account to check network switching support for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns True if programmatic network switching is available, false otherwise.
 */ const isProgrammaticNetworkSwitchAvailable = ({ walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey: walletAccount.walletProviderKey
    }, client);
    return walletProvider.switchActiveNetwork !== undefined;
};

/**
 * Switches the active network for a wallet account.
 *
 * This function programmatically changes the network
 * that the wallet is currently connected to.
 *
 * @param params.networkId - The identifier of the network to switch to. Should match the networkId of the network data.
 * @param params.walletAccount - The wallet account to switch networks for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the network switch is complete.
 * @throws NetworkSwitchingUnavailableError If the wallet provider doesn't support network switching.
 */ const switchActiveNetwork = async ({ networkId, walletAccount }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey: walletAccount.walletProviderKey
    }, client);
    if (walletProvider.switchActiveNetwork === undefined) {
        throw new NetworkSwitchingUnavailableError({
            extraMessages: [
                `Wallet provider ${walletAccount.walletProviderKey} does not have switchActiveNetwork method`
            ],
            originalError: null,
            walletProviderKey: walletAccount.walletProviderKey
        });
    }
    return walletProvider.switchActiveNetwork({
        networkId
    });
};

/**
 * Get the primary wallet account.
 * The primary wallet account is the one that was last selected by the user.
 * This information is stored in both unverified and verified wallet accounts.
 * This function consolidates this information to determine which wallet was most recently selected.
 */ const getPrimaryWalletAccount = (client = constants.getDefaultClient())=>{
    const walletAccounts = getWalletProviderByKey.getWalletAccounts(client);
    const sortedLastSelectedWalletAccounts = walletAccounts.filter((walletAccount)=>Boolean(walletAccount.lastSelectedAt)).sort((a, b)=>b.lastSelectedAt.getTime() - a.lastSelectedAt.getTime());
    if (sortedLastSelectedWalletAccounts.length === 0) {
        return null;
    }
    const [primaryWalletAccount] = sortedLastSelectedWalletAccounts;
    return primaryWalletAccount;
};

/**
 * Make the wallet account provided as the primary wallet account.
 */ const selectPrimaryWalletAccount = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const currentPrimaryWalletAccount = getPrimaryWalletAccount(client);
    if ((currentPrimaryWalletAccount == null ? void 0 : currentPrimaryWalletAccount.id) === walletAccount.id) {
        return;
    }
    if (walletAccount.verifiedCredentialId) {
        const apiClient = constants.createApiClient({}, client);
        const response = await apiClient.selectUserWallet({
            environmentId: core.environmentId,
            userWalletSelectionRequest: {
                walletId: walletAccount.verifiedCredentialId
            }
        });
        getWalletProviderByKey.updateAuthFromVerifyResponse({
            response
        }, client);
    } else {
        const updatedWalletAccount = constants._extends({}, walletAccount, {
            lastSelectedAt: new Date()
        });
        getNetworkProviderFromNetworkId.setUnverifiedWalletAccounts({
            unverifiedWalletAccountsToUpdate: [
                updatedWalletAccount
            ]
        }, client);
    }
};

/**
 * Removes a wallet account from the current session or user (if authenticated).
 *
 * This function disconnects and removes the specified wallet account,
 * updating both local state and server records (if there is an authenticated user).
 * For verified wallets, it will unlink them from the user's account.
 *
 * @param params.walletAccount - The wallet account to remove.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves when the wallet account is successfully removed.
 */ const removeWalletAccount = async ({ walletAccount }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    try {
        const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
            walletAccount
        }, client);
        await (walletProvider.disconnectWalletAccount == null ? void 0 : walletProvider.disconnectWalletAccount.call(walletProvider, {
            walletAccount
        }));
    } catch (error) {
        if (error instanceof getWalletProviderByKey.NoWalletProviderFoundError) {
            return;
        }
        throw error;
    }
    if (!walletAccount.verifiedCredentialId) {
        removeUnverifiedWalletAccount({
            unverifiedWalletAccount: walletAccount
        }, client);
        return;
    }
    const response = await apiClient.verifyUnlink({
        environmentId: core.environmentId,
        verifyUnlinkRequest: {
            walletId: walletAccount.verifiedCredentialId
        }
    });
    getWalletProviderByKey.updateAuthFromVerifyResponse({
        response
    }, client);
};

/**
 * Signs a message using the specified wallet account.
 *
 * This function uses the wallet's private key to cryptographically sign
 * the provided message.
 *
 * @param params.walletAccount - The wallet account to use for signing.
 * @param params.message - The message to sign.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A promise that resolves to an object containing the signature.
 */ const signMessage = async ({ walletAccount, message }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    assertWalletProviderMethodDefined(walletProvider, 'signMessage');
    const { signature } = await walletProvider.signMessage({
        message,
        walletAccount
    });
    return {
        signature
    };
};

/**
 * Finds a wallet account by address and blockchain.
 *
 * This function searches through the current session's wallet accounts
 * to find one matching the specified address and chain.
 *
 * @param params.address - The wallet address to search for.
 * @param params.chain - The blockchain the wallet belongs to.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns The matching wallet account, or undefined if not found.
 */ const getWalletAccountFromAddress = ({ address, chain }, client = constants.getDefaultClient())=>{
    const walletAccounts = getWalletProviderByKey.getWalletAccounts(client);
    return walletAccounts.find((walletAccount)=>walletAccount.address === address && walletAccount.chain === chain);
};

/**
 * Removes a listener from a wallet provider event.
 * You can alternatively use the returned function from `onWalletProviderEvent` instead of using this function.
 *
 * @param params.callback - The callback function to remove. This should be the same function that was passed to the `onWalletProviderEvent` function.
 * @see onWalletProviderEvent
 * @param params.event - The event name to remove the listener from.
 * @param params.walletProviderKey - The unique key identifying the wallet provider to remove the listener from.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 */ const offWalletProviderEvent = ({ callback, event, walletProviderKey }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey
    }, client);
    assertWalletProviderMethodDefined(walletProvider, 'events');
    // We use any here because typescript is messing up the type inference
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    walletProvider.events.off(event, callback);
};

/**
 * Listens to a wallet provider event.
 *
 * @param params.callback - The callback function to execute when the event is fired.
 * @param params.event - The event name to listen for.
 * @param params.walletProviderKey - The unique key identifying the wallet provider to listen to.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A function that can be called to remove the listener.
 */ const onWalletProviderEvent = ({ callback, event, walletProviderKey }, client = constants.getDefaultClient())=>{
    const walletProvider = getWalletProviderByKey.getWalletProviderByKey({
        walletProviderKey
    }, client);
    assertWalletProviderMethodDefined(walletProvider, 'events');
    // We use any here because typescript is messing up the type inference
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    walletProvider.events.on(event, callback);
    return ()=>{
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        walletProvider.events.off(event, callback);
    };
};

/* eslint-disable no-useless-escape */ /* eslint-disable no-restricted-globals */ /**
 * Sourced from http://detectmobilebrowsers.com/
 */ const userAgentRegex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ios|ipad|playbook|silk/i;
const userAgentRegex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
// This is a regex that covers both iphone, android and any other mobile device.
const isMobile = (maxTouchPointsOverride)=>{
    if (typeof window === 'undefined' || typeof navigator === 'undefined') {
        return false;
    }
    return userAgentRegex1.test(navigator.userAgent) || userAgentRegex2.test(navigator.userAgent.substring(0, 4)) || isIPad(maxTouchPointsOverride) || isIPhone();
};
const isIPhone = ()=>typeof window === 'undefined' || typeof navigator === 'undefined' ? false : /iPhone|ios/.test(navigator.userAgent);
/**
 * @param [optional] maxTouchPointsOverride - this is used for testing since
 * it seems that JSDOM doesn't support maxTouchPoints, so it was impossible
 * to mock it
 */ const isIPad = (maxTouchPointsOverride)=>{
    if (typeof window === 'undefined' || typeof navigator === 'undefined') {
        return false;
    }
    const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;
    return /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && maxTouchPoints === 5;
};

assertPackageVersion.assertPackageVersion(constants.name, constants.version);

exports.BaseError = constants.BaseError;
exports.InvalidExternalAuthError = constants.InvalidExternalAuthError;
exports.MfaInvalidOtpError = constants.MfaInvalidOtpError;
exports.MfaRateLimitedError = constants.MfaRateLimitedError;
exports.SandboxMaximumThresholdReachedError = constants.SandboxMaximumThresholdReachedError;
exports.getDefaultClient = constants.getDefaultClient;
Object.defineProperty(exports, "MFAAction", {
  enumerable: true,
  get: function () { return sdkApiCore.MFAAction; }
});
exports.NoNetworkProvidersError = getNetworkProviderFromNetworkId.NoNetworkProvidersError;
exports.WalletAlreadyLinkedToAnotherUserError = getNetworkProviderFromNetworkId.WalletAlreadyLinkedToAnotherUserError;
exports.getNetworksData = getNetworkProviderFromNetworkId.getNetworksData;
exports.hasExtension = getNetworkProviderFromNetworkId.hasExtension;
exports.isCaptchaRequired = getNetworkProviderFromNetworkId.isCaptchaRequired;
exports.setCaptchaToken = getNetworkProviderFromNetworkId.setCaptchaToken;
exports.getWalletAccounts = getWalletProviderByKey.getWalletAccounts;
exports.offEvent = getWalletProviderByKey.offEvent;
exports.onEvent = getWalletProviderByKey.onEvent;
exports.onceEvent = getWalletProviderByKey.onceEvent;
exports.consumeMfaToken = isMfaRequiredForAction.consumeMfaToken;
exports.getMfaMethods = isMfaRequiredForAction.getMfaMethods;
exports.isMfaRequiredForAction = isMfaRequiredForAction.isMfaRequiredForAction;
exports.NotWaasWalletAccountError = NotWaasWalletAccountError.NotWaasWalletAccountError;
exports.refreshUser = NotWaasWalletAccountError.refreshUser;
exports.InvalidParamError = InvalidParamError.InvalidParamError;
exports.ClientAlreadyInitializedError = ClientAlreadyInitializedError;
exports.InvalidRedirectStorageStateError = InvalidRedirectStorageStateError;
exports.MissingRedirectStorageStateError = MissingRedirectStorageStateError;
exports.MissingSocialUrlParamError = MissingSocialUrlParamError;
exports.NetworkSwitchingUnavailableError = NetworkSwitchingUnavailableError;
exports.NoAddressFoundError = NoAddressFoundError;
exports.NoPasskeyCredentialsFoundError = NoPasskeyCredentialsFoundError;
exports.NoSmartWalletAccountSignerFoundError = NoSmartWalletAccountSignerFoundError;
exports.NoWebAuthNSupportError = NoWebAuthNSupportError;
exports.UnavailableInServerSideError = UnavailableInServerSideError;
exports.UnrecognizedNetworkError = UnrecognizedNetworkError;
exports.UserNotAuthenticatedError = UserNotAuthenticatedError;
exports.UserRejectedError = UserRejectedError;
exports.WalletAccountAlreadyVerifiedError = WalletAccountAlreadyVerifiedError;
exports.WalletAccountNotSelectedError = WalletAccountNotSelectedError;
exports.WalletProviderMethodUnavailableError = WalletProviderMethodUnavailableError;
exports.acknowledgeRecoveryCodes = acknowledgeRecoveryCodes;
exports.assertWalletAccountSigningAvailability = assertWalletAccountSigningAvailability;
exports.assertWalletProviderMethodDefined = assertWalletProviderMethodDefined;
exports.authenticateMfaRecoveryCode = authenticateMfaRecoveryCode;
exports.authenticatePasskeyMFA = authenticatePasskeyMFA;
exports.authenticateTotpMfaDevice = authenticateTotpMfaDevice;
exports.authenticateWithSocial = authenticateWithSocial;
exports.completeSocialAuthentication = completeSocialAuthentication;
exports.connectAndVerifyWithWalletProvider = connectAndVerifyWithWalletProvider;
exports.connectWithWalletProvider = connectWithWalletProvider;
exports.createDynamicClient = createDynamicClient;
exports.createNewMfaRecoveryCodes = createNewMfaRecoveryCodes;
exports.deleteMfaDevice = deleteMfaDevice;
exports.deletePasskey = deletePasskey;
exports.detectOAuthRedirect = detectOAuthRedirect;
exports.fetchProjectSettings = fetchProjectSettings;
exports.getActiveNetworkData = getActiveNetworkData;
exports.getActiveNetworkId = getActiveNetworkId;
exports.getAvailableWalletProvidersData = getAvailableWalletProvidersData;
exports.getBalance = getBalance;
exports.getBalanceForAddress = getBalanceForAddress;
exports.getConnectedAddresses = getConnectedAddresses;
exports.getMfaDevices = getMfaDevices;
exports.getMfaRecoveryCodes = getMfaRecoveryCodes;
exports.getMultichainBalances = getMultichainBalances;
exports.getOwnerWalletAccountForSmartWalletAccount = getOwnerWalletAccountForSmartWalletAccount;
exports.getPasskeys = getPasskeys;
exports.getPrimaryWalletAccount = getPrimaryWalletAccount;
exports.getUserSocialAccounts = getUserSocialAccounts;
exports.getWalletAccountAddressByType = getWalletAccountAddressByType;
exports.getWalletAccountFromAddress = getWalletAccountFromAddress;
exports.getWalletProviderDataByKey = getWalletProviderDataByKey;
exports.initializeClient = initializeClient;
exports.isMobile = isMobile;
exports.isPendingRecoveryCodesAcknowledgment = isPendingRecoveryCodesAcknowledgment;
exports.isProgrammaticNetworkSwitchAvailable = isProgrammaticNetworkSwitchAvailable;
exports.isSignedIn = isSignedIn;
exports.isUserMissingMfaAuth = isUserMissingMfaAuth;
exports.logout = logout;
exports.offWalletProviderEvent = offWalletProviderEvent;
exports.onWalletProviderEvent = onWalletProviderEvent;
exports.proveWalletAccountOwnership = proveWalletAccountOwnership;
exports.registerPasskey = registerPasskey;
exports.registerTotpMfaDevice = registerTotpMfaDevice;
exports.removeWalletAccount = removeWalletAccount;
exports.selectPrimaryWalletAccount = selectPrimaryWalletAccount;
exports.sendEmailOTP = sendEmailOTP;
exports.sendSmsOTP = sendSmsOTP;
exports.setDefaultMfaDevice = setDefaultMfaDevice;
exports.signInWithExternalJwt = signInWithExternalJwt;
exports.signInWithPasskey = signInWithPasskey;
exports.signMessage = signMessage;
exports.switchActiveNetwork = switchActiveNetwork;
exports.updateUser = updateUser;
exports.verifyOTP = verifyOTP;
exports.verifyWalletAccount = verifyWalletAccount;
exports.waitForClientInitialized = waitForClientInitialized;
