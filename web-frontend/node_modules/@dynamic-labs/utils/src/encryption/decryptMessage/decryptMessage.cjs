'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var DecryptionError = require('../../errors/DecryptionError.cjs');

/**
 * Decrypts an encrypted message using AES-GCM encryption with a shared secret key.
 *
 * @param sharedSecret - The shared secret key in hexadecimal format
 * @param message - The encrypted message in base64 format
 * @param iv - The initialization vector in hexadecimal format
 * @param additionalData - Additional data to include in the decryption
 * @returns A Promise that resolves to the decrypted message as a string
 */
const decryptMessage = (sharedSecret, message, iv, additionalData) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const decoder = new TextDecoder();
        const sharedSecretByteArray = new Uint8Array((_b = (_a = decodeURIComponent(sharedSecret)
            .match(/.{1,2}/g)) === null || _a === void 0 ? void 0 : _a.map((byte) => parseInt(byte, 16))) !== null && _b !== void 0 ? _b : []);
        // Import the ArrayBuffer as a CryptoKey
        const sharedSecretCryptoKey = yield crypto.subtle.importKey('raw', sharedSecretByteArray.buffer, 'AES-GCM', true, ['encrypt', 'decrypt']);
        const decryptParams = {
            iv: hexToUint8Array(decodeURIComponent(iv)),
            name: 'AES-GCM',
        };
        if (additionalData) {
            decryptParams.additionalData = additionalData;
        }
        const decryptedData = yield crypto.subtle.decrypt(decryptParams, sharedSecretCryptoKey, base64ToArrayBuffer(decodeURIComponent(message)));
        return decoder.decode(new Uint8Array(decryptedData));
    }
    catch (error) {
        // Failed to decrypt the message
        if (error &&
            typeof error === 'object' &&
            'name' in error &&
            typeof error.name === 'string') {
            throw new DecryptionError.DecryptionError(error.name);
        }
        throw error;
    }
});
const hexToUint8Array = (hex) => {
    if (hex.length % 2 !== 0) {
        throw new Error('Hex string must have an even number of characters');
    }
    if (!/^[0-9A-Fa-f]+$/.test(hex)) {
        throw new Error('Invalid hex characters');
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
};
const base64ToArrayBuffer = (base64) => {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
};

exports.decryptMessage = decryptMessage;
