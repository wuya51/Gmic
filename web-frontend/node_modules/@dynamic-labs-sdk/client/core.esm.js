import { assertPackageVersion } from '@dynamic-labs-sdk/assert-package-version';
import { B as BaseError, a as getCore, d as assertDefined, b as getBuffer, n as name, v as version } from './constants.esm.js';
export { A as APIError, e as CHAINS_INFO_MAP, j as ClientNotFoundError, l as DYNAMIC_ICONIC_SPRITE_URL, D as DYNAMIC_SDK_API_VERSION, V as ValueMustBeDefinedError, c as createApiClient, k as getChainFromVerifiedCredentialChain, g as getDefaultClient, i as isCookieEnabled } from './constants.esm.js';
import { F as FETCH_PROJECT_SETTINGS_TRACKER_KEY, c as createStorageKeySchema, q as getNetworkProviders, N as NoNetworkProvidersError } from './getNetworkProviderFromNetworkId.esm.js';
export { C as CannotTrackError, r as InvalidStorageSet, e as consumeCaptchaToken, d as createLocalStorageAdapter, a as createLogger, h as createSignInMessageStatement, b as createStorage, g as createVisit, j as formatSignInMessage, t as getNetworkProviderBuilderRegistry, m as getNetworkProviderFromNetworkId, k as getVerifiedCredentialForWalletAccount, p as hasExtension, o as setCaptchaToken, f as setUnverifiedWalletAccounts, s as subscribeWithSelector, u as updateWalletProviderKeysForVerifiedCredentials, v as verifySignInMessage } from './getNetworkProviderFromNetworkId.esm.js';
import { b as getWalletProviderByKey, k as createRuntimeServiceAccessKey } from './getWalletProviderByKey.esm.js';
export { I as InvalidWalletProviderKeyError, N as NoWalletProviderFoundError, W as WalletProviderPriority, e as emitEvent, c as emitWalletAccountsChangedEvent, f as formatWalletAccountId, l as formatWalletProviderKey, a as getWalletProviderFromWalletAccount, q as getWalletProviderRegistry, h as getWalletProviders, m as normalizeWalletNameWithChain, p as splitWalletProviderKey, u as updateAuthFromVerifyResponse } from './getWalletProviderByKey.esm.js';
export { c as consumeMfaTokenIfRequiredForAction, g as getSignedSessionId } from './getSignedSessionId.esm.js';
import * as z from 'zod/mini';
import EventEmitter from 'eventemitter3';
export { f as filterDuplicates } from './filterDuplicates.esm.js';
import '@dynamic-labs/sdk-api-core';
import 'buffer';
import './isMfaRequiredForAction.esm.js';

class ClientsDoNotMatchError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'clients_do_not_match_error',
            docsUrl: null,
            name: 'ClientsDoNotMatchError',
            shortMessage: 'Clients do not match'
        });
    }
}

class MethodNotImplementedError extends BaseError {
    constructor(methodName){
        super({
            cause: null,
            code: 'method_not_implemented_error',
            docsUrl: null,
            name: 'MethodNotImplementedError',
            shortMessage: `This method is not implemented: ${methodName}`
        });
    }
}

class MultipleClientsFoundError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'multiple_clients_found_error',
            docsUrl: null,
            name: 'MultipleClientsFoundError',
            shortMessage: 'Multiple Dynamic clients have been initialized. Please provide the intended client for this action explicitly'
        });
    }
}

/**
 * Registers an extension to the client.
 *
 * Other extensions can be aware of which extensions are present,
 * and allows creating dependencies between extensions.
 *
 * @param client - The client instance.
 * @param extensionKey - The key of the extension to register.
 * @returns The client instance.
 */ const registerExtension = ({ extensionKey }, client)=>{
    const core = getCore(client);
    core.extensions.add(extensionKey);
};

const waitForProjectSettings = async (client)=>{
    const core = getCore(client);
    const projectSettingsTracker = core.initTrack.getTracker(FETCH_PROJECT_SETTINGS_TRACKER_KEY);
    assertDefined(projectSettingsTracker, 'Project settings tracker not found');
    await projectSettingsTracker.promise;
    assertDefined(client.projectSettings, 'Project settings still not available after awaiting its tracker');
    return client.projectSettings;
};

const createBaseNetworkProvider = (chain, networkData)=>({
        blockExplorerUrls: networkData.blockExplorerUrls,
        chain,
        displayName: networkData.displayName,
        iconUrl: networkData.iconUrl,
        id: `${chain}-${networkData.networkId}`,
        nativeCurrency: networkData.nativeCurrency,
        networkId: networkData.networkId,
        rpcUrls: networkData.rpcUrls,
        testnet: networkData.testnet
    });

const networkRegistryStorageKeySchema = createStorageKeySchema({
    key: 'lastKnownNetworkRegistry',
    schema: z.record(z.string(), z.string())
});

/**
 * Creates the registry that keeps tabs on which wallet provider is
 * connected to which network.
 *
 * Reminder that this will not be used for chains that have an internal way to
 * switch networks (ex EVM).
 */ const createLastKnownNetworkRegistry = (client)=>{
    const core = getCore(client);
    const walletProviderKeyToNetworkId = new Map();
    const getNetworkId = async ({ walletProviderKey })=>{
        // Priorities:
        // 1. In memory
        // 2. Storage
        // 3. First available network for this wallet's chain
        if (walletProviderKeyToNetworkId.has(walletProviderKey)) {
            return {
                networkId: walletProviderKeyToNetworkId.get(walletProviderKey)
            };
        }
        const storageRecords = await core.storage.getItem(networkRegistryStorageKeySchema);
        if (storageRecords && storageRecords[walletProviderKey]) {
            const networkId = storageRecords[walletProviderKey];
            walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
            return {
                networkId
            };
        }
        const walletProvider = getWalletProviderByKey({
            walletProviderKey
        }, client);
        const networkProviders = getNetworkProviders(client);
        if (networkProviders.length === 0) {
            throw new NoNetworkProvidersError();
        }
        const defaultNetworkProvider = networkProviders.find((networkProvider)=>networkProvider.chain === walletProvider.chain);
        assertDefined(defaultNetworkProvider, `No networks found for chain ${walletProvider.chain}`);
        walletProviderKeyToNetworkId.set(walletProviderKey, defaultNetworkProvider.networkId);
        // No need to set in storage, as we're just falling back to the default
        return {
            networkId: defaultNetworkProvider.networkId
        };
    };
    const setNetworkId = async ({ networkId, walletProviderKey })=>{
        walletProviderKeyToNetworkId.set(walletProviderKey, networkId);
        await core.storage.setItem(networkRegistryStorageKeySchema, Object.fromEntries(walletProviderKeyToNetworkId.entries()));
    };
    return {
        getNetworkId,
        setNetworkId
    };
};

const getLastKnownNetworkRegistry = createRuntimeServiceAccessKey('last-known-network-registry', (client)=>createLastKnownNetworkRegistry(client));

const formatWalletProviderGroupKey = (walletName)=>walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();

/* eslint-disable no-restricted-globals */ const getInjectedProviderFromWindow = (path)=>{
    if (typeof window === 'undefined') {
        return null;
    }
    // Traverse the path safely
    const target = path.split('.').reduce(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    (acc, key)=>acc == null ? null : acc[key], window);
    if (typeof target !== 'object' || target === null) {
        return null;
    }
    if (Array.isArray(target)) {
        return target.length > 0 ? target[0] : null;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const providersArray = target.providers;
    if (providersArray && Array.isArray(providersArray)) {
        return providersArray.length > 0 ? providersArray[0] : null;
    }
    return target;
};

const getActiveNetworkIdFromLastKnownRegistry = async ({ client, walletProviderKey })=>{
    const networkRegistry = getLastKnownNetworkRegistry(client);
    return networkRegistry.getNetworkId({
        walletProviderKey
    });
};

const switchActiveNetworkInLastKnownRegistry = async ({ client, networkId, walletProviderKey })=>{
    const networkRegistry = getLastKnownNetworkRegistry(client);
    await networkRegistry.setNetworkId({
        networkId,
        walletProviderKey
    });
};

/**
 * Takes a callback that registers handlers for the external wallet provider.
 * Returns both a getter of an eventEmitter that can be exposed via the wallet provider
 * and a callback that will be used to destroy the listeners.
 */ const createWalletProviderEventEmitter = ({ removeEventListeners, setupEventListeners, supportedEvents = [
    'accountsChanged',
    'disconnected',
    'networkChanged'
] })=>{
    let eventEmitter;
    /** Value returned by setupEventListeners */ let setupReturnValue;
    const handleAccountsChanged = (params)=>{
        assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('accountsChanged', params);
    };
    const handleDisconnected = ()=>{
        assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('disconnected');
    };
    const handleNetworkChanged = (params)=>{
        assertDefined(eventEmitter, 'Event emitter not defined');
        eventEmitter.emit('networkChanged', params);
    };
    const cleanupEventEmitter = ()=>{
        if (!eventEmitter) {
            return;
        }
        removeEventListeners({
            handleAccountsChanged,
            handleDisconnected,
            handleNetworkChanged,
            setupReturnValue
        });
        eventEmitter = undefined;
    };
    const getEventEmitter = ()=>{
        if (!eventEmitter) {
            eventEmitter = new EventEmitter();
            setupReturnValue = setupEventListeners({
                handleAccountsChanged,
                handleDisconnected,
                handleNetworkChanged
            });
        }
        return Object.assign(eventEmitter, {
            supportedEvents
        });
    };
    return {
        cleanupEventEmitter,
        getEventEmitter
    };
};

const bufferToBase64 = (buf)=>{
    const binstr = Array.prototype.map.call(buf, (ch)=>String.fromCharCode(ch)).join('');
    return getBuffer().from(binstr, 'binary').toString('base64');
};

assertPackageVersion(name, version);

export { ClientsDoNotMatchError, MethodNotImplementedError, MultipleClientsFoundError, assertDefined, bufferToBase64, createBaseNetworkProvider, createRuntimeServiceAccessKey, createStorageKeySchema, createWalletProviderEventEmitter, formatWalletProviderGroupKey, getActiveNetworkIdFromLastKnownRegistry, getBuffer, getCore, getInjectedProviderFromWindow, getLastKnownNetworkRegistry, getNetworkProviders, registerExtension, switchActiveNetworkInLastKnownRegistry, waitForProjectSettings };
