import { g as getDefaultClient, a as getCore, B as BaseError, d as assertDefined, k as getChainFromVerifiedCredentialChain, _ as _extends, i as isCookieEnabled } from './constants.esm.js';
import { WalletProviderEnum, JwtVerifiedCredentialFormatEnum } from '@dynamic-labs/sdk-api-core';

/**
 * Sefelly sets the cookie in the browser.
 */ const setCookie = (cookie)=>{
    // eslint-disable-next-line no-restricted-globals
    document.cookie = cookie;
};

/**
 * Adds an event listener for Dynamic client events.
 *
 * This function allows you to listen for various events emitted by the Dynamic client,
 * such as authentication state changes, wallet connections, and more.
 *
 * @param params.event - The event name to listen for.
 * @param params.listener - The callback function to execute when the event is fired.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A function that can be called to remove the listener.
 */ const onEvent = ({ event, listener }, client = getDefaultClient())=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.on(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Removes an event listener from Dynamic client events.
 *
 * This function unsubscribes a previously registered event listener
 * from the specified Dynamic client event.
 *
 * @param params.event - The event name to remove the listener from.
 * @param params.listener - The callback function to remove.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 */ const offEvent = ({ event, listener }, client = getDefaultClient())=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.off(event, listener);
};
/**
 * Adds a one-time event listener for Dynamic client events.
 *
 * This function listens for an event that will automatically remove itself
 * after being triggered once.
 *
 * @param params.event - The event name to listen for.
 * @param params.listener - The callback function to execute when the event is fired.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns A function that can be called to remove the listener before it fires.
 */ const onceEvent = ({ event, listener }, client = getDefaultClient())=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.once(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Emits a Dynamic client event.
 *
 * This function triggers an event that will be received by all registered
 * listeners for the specified event type.
 *
 * @param params.event - The event name to emit.
 * @param params.args - The arguments to pass to event listeners.
 * @param client - The Dynamic client instance.
 */ const emitEvent = ({ event, args }, client)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.emit(event, args);
};

class InvalidWalletProviderKeyError extends BaseError {
    constructor(value){
        super({
            cause: null,
            code: 'invalid_wallet_provider_key',
            docsUrl: null,
            name: 'InvalidWalletProviderKeyError',
            shortMessage: `Invalid wallet provider key: ${value}. Key must be in the format of <normalizedWalletNameWithChain>:<walletProviderType>[:<suffix>]`
        });
    }
}

const splitWalletProviderKey = (walletProviderKey)=>{
    const [normalizedWalletNameWithChain, walletProviderType, suffix, ...rest] = walletProviderKey.split(':');
    if (!normalizedWalletNameWithChain || !Object.values(WalletProviderEnum).includes(walletProviderType) || rest.length > 0) {
        throw new InvalidWalletProviderKeyError(walletProviderKey);
    }
    return {
        normalizedWalletNameWithChain,
        suffix,
        walletProviderType: walletProviderType
    };
};

const normalizeAddress = (address, chain)=>{
    let normalizedAddress = address;
    if (normalizedAddress == null ? void 0 : normalizedAddress.startsWith('0x')) {
        normalizedAddress = normalizedAddress.slice(2);
    }
    /**
   * These are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md
   * see also: https://github.com/ChainAgnostic/namespaces
   * note: no standard namespace currently exists for flow
   */ const chainsThatRequireLowercaseAddress = [
        'EVM',
        'FLOW'
    ];
    normalizedAddress = chainsThatRequireLowercaseAddress.includes(chain) ? normalizedAddress == null ? void 0 : normalizedAddress.toLowerCase() : normalizedAddress;
    return normalizedAddress;
};

const formatWalletAccountId = ({ address, chain, walletProviderKey })=>{
    const { normalizedWalletNameWithChain } = splitWalletProviderKey(walletProviderKey);
    const normalizedAddress = normalizeAddress(address, chain);
    return `${normalizedWalletNameWithChain}:${normalizedAddress}`;
};

const convertUnverifiedWalletAccountToWalletAccount = ({ unverifiedWalletAccount })=>({
        address: unverifiedWalletAccount.address,
        addressesWithTypes: unverifiedWalletAccount.addressesWithTypes,
        chain: unverifiedWalletAccount.chain,
        id: formatWalletAccountId({
            address: unverifiedWalletAccount.address,
            chain: unverifiedWalletAccount.chain,
            walletProviderKey: unverifiedWalletAccount.walletProviderKey
        }),
        lastSelectedAt: unverifiedWalletAccount.lastSelectedAt,
        verifiedCredentialId: null,
        walletProviderKey: unverifiedWalletAccount.walletProviderKey
    });

/**
 * Format the raw wallet name and chain to get the value we can use for
 * verified credentials' `walletName` field.
 */ const normalizeWalletNameWithChain = ({ displayName, chain })=>{
    const sanitizedWalletName = displayName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    const chainLowered = chain.toLocaleLowerCase();
    if (sanitizedWalletName.endsWith(chainLowered)) {
        return sanitizedWalletName;
    }
    return `${sanitizedWalletName}${chainLowered}`;
};

/**
 * Assembles the wallet provider key from the wallet name, chain, and wallet provider type.
 *
 * The suffix is optional and can be used to add a uniquely identifying string to the key, which
 * might be necessary for some wallet providers (like Wallet Connect).
 *
 * IMPORTANT: Do NOT add a suffix unless absolutely necessary, as it will cause the wallet account
 * to not be able to find its wallet provider when connecting to a new device (it won't be possible
 * to determine the full key just from the Verified Credential data).
 */ const formatWalletProviderKey = ({ suffix, chain, displayName, walletProviderType })=>{
    const normalizedNameWithChain = normalizeWalletNameWithChain({
        chain,
        displayName
    });
    return `${normalizedNameWithChain}:${walletProviderType}${suffix ? `:${suffix}` : ''}`;
};

const getWalletProviderKeyFromVerifiedCredential = ({ verifiedCredential }, client)=>{
    const core = getCore(client);
    const { walletProviderKeyMap } = core.state.get();
    const storedWalletProviderKey = walletProviderKeyMap[verifiedCredential.id];
    if (storedWalletProviderKey) {
        return {
            walletProviderKey: storedWalletProviderKey
        };
    }
    /**
   * We fallback to comprising the wallet provider key from walletName and walletProvider.
   *
   * Some wallet provider types (like Wallet Connect) also use a special suffix for their wallet provider
   * keys, so this won't be enough for them.
   * Therefore, for those specific wallet providers, the wallet account will remain without a wallet provider
   * and will require reconnection.
   * Read walletProvider.types.ts for more info.
   */ assertDefined(verifiedCredential.walletName, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletName`);
    assertDefined(verifiedCredential.walletProvider, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing walletProvider`);
    assertDefined(verifiedCredential.chain, `Failed to get wallet provider for verified credential with ID ${verifiedCredential.id}: missing chain`);
    /**
   * Historically, walletNames did not include the chain name as a suffix.
   * This piece of logic simply ensures we normalize any legacy walletNames to conform.
   */ const chain = getChainFromVerifiedCredentialChain(verifiedCredential.chain);
    const walletProviderKey = formatWalletProviderKey({
        chain,
        displayName: verifiedCredential.walletName,
        walletProviderType: verifiedCredential.walletProvider
    });
    return {
        walletProviderKey
    };
};

const convertVerifiedCredentialToWalletAccount = ({ verifiedCredential }, client)=>{
    assertDefined(verifiedCredential.address, 'Missing address in verified credential');
    assertDefined(verifiedCredential.chain, 'Missing chain in verified credential');
    const chain = getChainFromVerifiedCredentialChain(verifiedCredential.chain);
    const { walletProviderKey } = getWalletProviderKeyFromVerifiedCredential({
        verifiedCredential
    }, client);
    const walletAccountId = formatWalletAccountId({
        address: verifiedCredential.address,
        chain,
        walletProviderKey
    });
    var _verifiedCredential_lastSelectedAt;
    return {
        address: verifiedCredential.address,
        addressesWithTypes: verifiedCredential.walletAdditionalAddresses,
        chain,
        id: walletAccountId,
        lastSelectedAt: (_verifiedCredential_lastSelectedAt = verifiedCredential.lastSelectedAt) != null ? _verifiedCredential_lastSelectedAt : null,
        verifiedCredentialId: verifiedCredential.id,
        walletProviderKey
    };
};

const getWalletAccountsFromState = ({ unverifiedWalletAccounts, user }, client)=>{
    const walletAccountsMap = new Map();
    /**
   * Handle the unverified wallet accounts before the user verified credentials
   * so the later verified wallet accounts can override the unverified wallet accounts
   */ unverifiedWalletAccounts.forEach((unverifiedWalletAccount)=>{
        const walletAccount = convertUnverifiedWalletAccountToWalletAccount({
            unverifiedWalletAccount
        });
        walletAccountsMap.set(walletAccount.id, walletAccount);
    });
    var _user_verifiedCredentials;
    /**
   * Handle user verified credentials
   */ const verifiedCredentials = (_user_verifiedCredentials = user == null ? void 0 : user.verifiedCredentials) != null ? _user_verifiedCredentials : [];
    verifiedCredentials.filter((verified)=>verified.format === JwtVerifiedCredentialFormatEnum.Blockchain).forEach((verifiedWalletAccount)=>{
        const walletAccount = convertVerifiedCredentialToWalletAccount({
            verifiedCredential: verifiedWalletAccount
        }, client);
        walletAccountsMap.set(walletAccount.id, walletAccount);
    });
    return Array.from(walletAccountsMap.values());
};

/**
 * Retrieves all wallet accounts associated with the current session.
 *
 * This function returns both verified and unverified wallet accounts,
 * combining data from user credentials and local unverified accounts.
 * You can differentiate between verified and unverified wallet accounts by
 * checking the `verifiedCredentialId` property.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns An array of wallet accounts associated with the session.
 */ const getWalletAccounts = (client = getDefaultClient())=>{
    const core = getCore(client);
    const { unverifiedWalletAccounts, user } = core.state.get();
    return getWalletAccountsFromState({
        unverifiedWalletAccounts,
        user
    }, client);
};

class NoWalletProviderFoundError extends BaseError {
    constructor({ walletProviderKey }){
        super({
            cause: null,
            code: 'no_wallet_provider_found_error',
            docsUrl: null,
            name: 'NoWalletProviderFoundError',
            shortMessage: `No wallet provider found with key: ${walletProviderKey}`
        });
    }
}

/**
 * Creates a service accessor function that manages service instantiation and caching.
 * The returned function will either retrieve an existing service from the registry or
 * create a new one using the provided builder function.
 *
 * @template - The type of service to be created/accessed
 * @param key - Unique identifier for the service in the registry
 * @param builder - Function that creates the service instance when called with a DynamicClient
 */ const createRuntimeServiceAccessKey = (key, builder)=>(client)=>{
        const { runtimeServices } = getCore(client);
        const currentService = runtimeServices.getByKey(key);
        if (currentService) {
            return currentService;
        }
        const service = builder(client);
        runtimeServices.register(key, service);
        return service;
    };

/**
 * Creates a new wallet provider registry that manages wallet providers with priority-based registration.
 *
 * @returns The wallet provider registry instance
 *
 * @example
 * ```typescript
 * const registry = createWalletProviderRegistry();
 *
 * registry.register({
 *   priority: WalletProviderPriority.WALLET_SDK,
 *   walletProvider: myWalletProvider
 * });
 *
 * const provider = registry.getByKey('my-wallet-key');
 * const providers = registry.listProviders();
 * ```
 */ const createWalletProviderRegistry = (client)=>{
    const registry = new Map();
    return {
        getByKey: (key)=>{
            var _registry_get;
            return (_registry_get = registry.get(key)) == null ? void 0 : _registry_get.walletProvider;
        },
        listProviders: ()=>Array.from(registry.values()).map((v)=>v.walletProvider),
        register: (args)=>{
            const existingEntry = registry.get(args.walletProvider.key);
            if (existingEntry) {
                if (existingEntry.priority < args.priority) {
                    registry.set(args.walletProvider.key, args);
                    emitEvent({
                        args: {
                            walletProviderKey: args.walletProvider.key
                        },
                        event: 'walletProviderChanged'
                    }, client);
                }
            } else {
                registry.set(args.walletProvider.key, args);
                emitEvent({
                    args: {
                        walletProvider: args.walletProvider
                    },
                    event: 'walletProviderRegistered'
                }, client);
                emitEvent({
                    args: {
                        walletProviderKey: args.walletProvider.key
                    },
                    event: 'walletProviderChanged'
                }, client);
            }
        },
        unregister: (key)=>{
            registry.delete(key);
            emitEvent({
                args: {
                    walletProviderKey: key
                },
                event: 'walletProviderUnregistered'
            }, client);
        }
    };
};

/**
 * This function provides access to a shared instance of the wallet provider registry.
 *
 * It ensures that the same registry instance is used throughout the client to maintaining
 * consistency of registered wallet providers across different parts of the codebase.
 *
 * @returns The wallet provider registry instance
 *
 * @example
 * ```typescript
 * // Get the registry instance
 * const registry = getWalletProviderRegistry();
 *
 * // Register a wallet provider
 * registry.register({
 *   priority: WalletProviderPriority.WALLET_SDK,
 *   walletProvider: myWalletProvider
 * });
 *
 * // Retrieve a specific provider
 * const provider = registry.getByKey('metamaskevm');
 * ```
 */ const getWalletProviderRegistry = createRuntimeServiceAccessKey('walletProviderRegistry', (client)=>createWalletProviderRegistry(client));

var WalletProviderPriority;
(function(WalletProviderPriority) {
    /**
   * Highest priority should be used by wallet providers that implement
   * the most reliable wallet integration.
   * example: The SDK provided by the wallet provider.
   */ WalletProviderPriority[WalletProviderPriority["WALLET_SDK"] = 100] = "WALLET_SDK";
    /**
   * Medium priority should be used by wallet providers that implement
   * a wallet integration via some reliable standard.
   * example: A wallet provider that uses EIP6963 announcement.
   */ WalletProviderPriority[WalletProviderPriority["WALLET_SELF_ANNOUNCEMENT_STANDARD"] = 50] = "WALLET_SELF_ANNOUNCEMENT_STANDARD";
    /**
   * Low priority should be used by wallet providers that implement
   * a wallet integration on a less reliable standard.
   * example: A wallet provider that uses window.ethereum, where the
   * window key can be overridden by other extensions.
   */ WalletProviderPriority[WalletProviderPriority["WINDOW_INJECT"] = 20] = "WINDOW_INJECT";
})(WalletProviderPriority || (WalletProviderPriority = {}));

const getWalletProviderFromWalletAccount = ({ walletAccount }, client)=>{
    const walletProviderRegistry = getWalletProviderRegistry(client);
    const walletProvider = walletProviderRegistry.getByKey(walletAccount.walletProviderKey);
    if (!walletProvider) {
        throw new NoWalletProviderFoundError({
            walletProviderKey: walletAccount.walletProviderKey
        });
    }
    return walletProvider;
};

const DYNAMIC_AUTH_COOKIE_NAME = 'DYNAMIC_JWT_TOKEN';

/**
 * Emits the `walletAccountsChanged` event.
 */ const emitWalletAccountsChangedEvent = (client)=>{
    const walletAccounts = getWalletAccounts(client);
    emitEvent({
        args: {
            walletAccounts
        },
        event: 'walletAccountsChanged'
    }, client);
};

const checkAndRaiseWalletAccountsChangedEvent = ({ previousState }, client)=>{
    const core = getCore(client);
    const walletAccountsHashBefore = getWalletAccountsHash(previousState, client);
    const walletAccountsHashAfter = getWalletAccountsHash(core.state.get(), client);
    if (walletAccountsHashBefore !== walletAccountsHashAfter) {
        emitWalletAccountsChangedEvent(client);
    }
};
const getWalletAccountsHash = (state, client)=>getWalletAccountsFromState(state, client).map((walletAccount)=>JSON.stringify(walletAccount)).sort().join('-');

const updateAuthFromVerifyResponse = ({ response }, client)=>{
    const core = getCore(client);
    const previousState = _extends({}, core.state.get());
    const { user, minifiedJwt, jwt, expiresAt, mfaToken } = response;
    // Expires at is in seconds, so we need to convert it to milliseconds
    const sessionExpiresAt = new Date(expiresAt * 1000);
    const newState = {
        legacyToken: jwt != null ? jwt : null,
        sessionExpiresAt: sessionExpiresAt,
        token: minifiedJwt != null ? minifiedJwt : null,
        user
    };
    // only override the mfaToken if a new one is provided in the response
    if (mfaToken) {
        newState.mfaToken = mfaToken;
    }
    core.state.set(newState);
    /**
   * For customers using a sandbox environment with cookies enabled, we need to set the cookie
   * programmatically because Redcoast won't set the cookie via headers. We set the cookie programmatically
   * so customers can access the cookie from document.cookie consistently between sandbox and live environments.
   */ if (minifiedJwt && isCookieEnabled(client)) {
        const expireDate = sessionExpiresAt.toUTCString();
        setCookie(`${DYNAMIC_AUTH_COOKIE_NAME}=${minifiedJwt}; expires=${expireDate}; path=/; SameSite=Lax`);
    }
    checkAndRaiseWalletAccountsChangedEvent({
        previousState
    }, client);
};

/**
 * Get all available wallet providers to interact with internally.
 */ const getWalletProviders = (client)=>{
    const walletProviderRegistry = getWalletProviderRegistry(client);
    return walletProviderRegistry.listProviders();
};

const getWalletProviderByKey = ({ walletProviderKey }, client)=>{
    const walletProviders = getWalletProviders(client);
    const walletProvider = walletProviders.find((walletProvider)=>walletProvider.key === walletProviderKey);
    if (!walletProvider) {
        throw new NoWalletProviderFoundError({
            walletProviderKey
        });
    }
    return walletProvider;
};

export { DYNAMIC_AUTH_COOKIE_NAME as D, InvalidWalletProviderKeyError as I, NoWalletProviderFoundError as N, WalletProviderPriority as W, getWalletProviderFromWalletAccount as a, getWalletProviderByKey as b, emitWalletAccountsChangedEvent as c, checkAndRaiseWalletAccountsChangedEvent as d, emitEvent as e, formatWalletAccountId as f, getWalletAccounts as g, getWalletProviders as h, onceEvent as i, onEvent as j, createRuntimeServiceAccessKey as k, formatWalletProviderKey as l, normalizeWalletNameWithChain as m, normalizeAddress as n, offEvent as o, splitWalletProviderKey as p, getWalletProviderRegistry as q, setCookie as s, updateAuthFromVerifyResponse as u };
