'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var useDynamicEvents = require('../../utils/hooks/events/useDynamicEvents/useDynamicEvents.cjs');
var ErrorContext = require('../ErrorContext/ErrorContext.cjs');
var dynamicEvents = require('../../events/dynamicEvents.cjs');

const ViewContext = React.createContext(undefined);
const ViewContextProvider = ({ children, initialViewType }) => {
    var _a;
    const [stack, setStack] = React.useState([]);
    const initialView = React.useMemo(() => ({ type: initialViewType }), [initialViewType]);
    const view = (_a = stack[stack.length - 1]) !== null && _a !== void 0 ? _a : initialView;
    const { clearError } = ErrorContext.useErrorContext();
    const pushView = React.useCallback((type, props, events) => {
        if (view.type === type)
            return;
        clearError();
        // If the stack was "empty" (i.e. showing a default view), let's make sure the stack
        // reflects this by having this default view as the first item in the stack
        setStack((stack) => {
            if (stack.length === 0)
                return [{ type: initialViewType }, { events, props, type }];
            else
                return [...stack, { events, props, type }];
        });
    }, [clearError, view.type, initialViewType]);
    const replaceView = React.useCallback((type, props, events) => {
        if (view.type === type)
            return;
        clearError();
        setStack((prev) => {
            if (prev.length <= 1) {
                return [{ type: initialViewType }, { events, props, type }];
            }
            return [...prev.slice(0, -1), { events, props, type }];
        });
    }, [clearError, initialViewType, view.type]);
    const canGoBack = stack.length > 1;
    const goBack = React.useCallback(() => {
        if (!canGoBack)
            return;
        clearError();
        setStack((prev) => prev.slice(0, -1));
        dynamicEvents.dynamicEvents.emit('goBack');
    }, [canGoBack, clearError]);
    const clearStackAndPush = React.useCallback((type, props, events) => {
        clearError();
        setStack([{ events, props, type }]);
    }, [clearError]);
    const clearStackAndPushInitialView = React.useCallback(() => {
        clearError();
        setStack((stack) => {
            if (stack.length > 0)
                return [];
            return stack;
        });
    }, [clearError]);
    useDynamicEvents.useInternalDynamicEvents('logout', clearStackAndPushInitialView);
    // Wait for the auth flow animation transition to finish before clearing the stack
    useDynamicEvents.useInternalDynamicEvents('authFlowClose', () => setTimeout(clearStackAndPushInitialView, 100));
    const value = React.useMemo(() => ({
        canGoBack: stack.length > 1,
        clearStackAndPush,
        clearStackAndPushInitialView,
        goBack,
        pushView,
        replaceView,
        stack,
        view,
    }), [
        clearStackAndPushInitialView,
        goBack,
        clearStackAndPush,
        pushView,
        view,
        stack,
        replaceView,
    ]);
    return jsxRuntime.jsx(ViewContext.Provider, { value: value, children: children });
};
const useViewContext = () => {
    const context = React.useContext(ViewContext);
    if (context === undefined) {
        throw new Error('usage of useViewContext not wrapped in `ViewContextProvider`.');
    }
    return context;
};

exports.ViewContext = ViewContext;
exports.ViewContextProvider = ViewContextProvider;
exports.useViewContext = useViewContext;
