'use strict';

var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var buffer = require('buffer');

var name = "@dynamic-labs-sdk/client";
var version = "0.1.0-alpha.28";
var dependencies = {
    "@dynamic-labs/sdk-api-core": "0.0.818"};

const getCore = (client)=>{
    // @ts-expect-error - this was hidden from the public API
    return client.__core;
};

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

const getDetails = ({ details, cause })=>{
    if (cause instanceof BaseError) {
        return cause.details;
    }
    if (cause == null ? void 0 : cause.message) {
        return cause.message;
    }
    return details;
};
/**
 * Formats the error message with all available information
 */ const formatMessage = ({ shortMessage, details, docsUrl, metaMessages })=>{
    return [
        shortMessage,
        '',
        ...metaMessages ? [
            ...metaMessages,
            ''
        ] : [],
        ...docsUrl ? [
            `Docs: ${docsUrl}`
        ] : [],
        ...details ? [
            `Details: ${details}`
        ] : [],
        `Version: ${version}`,
        `Timestamp: ${new Date().toISOString()}`
    ].join('\n');
};
/**
 * Base error class that provides structured error handling with detailed information
 */ class BaseError extends Error {
    /**
   * Walks the cause chain of the error and returns the root error
   */ walk() {
        const cause = this.cause;
        if (cause instanceof BaseError) {
            return cause.walk();
        }
        return cause;
    }
    toString() {
        return this.formattedMessage;
    }
    constructor(args){
        const details = getDetails(args);
        const formattedMessage = formatMessage(_extends({}, args, {
            details
        }));
        var _args_shortMessage;
        super((_args_shortMessage = args.shortMessage) != null ? _args_shortMessage : formattedMessage, args.cause ? {
            cause: args.cause
        } : undefined);
        this.name = 'BaseError';
        this.formattedMessage = formattedMessage;
        this.details = details;
        var _args_name;
        this.name = (_args_name = args.name) != null ? _args_name : this.name;
        var _args_cause;
        this.cause = (_args_cause = args.cause) != null ? _args_cause : this.cause;
        this.code = args.code;
    }
}

class ClientNotFoundError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'client_not_found_error',
            docsUrl: null,
            name: 'ClientNotFoundError',
            shortMessage: 'No Dynamic client has been created yet. Make sure you have called createDynamicClient() first.'
        });
    }
}

let defaultClient = null;
let numOfInitializedClients = 0;
/**
 * Returns the DynamicClient instance that was initialized with createDynamicClient.
 *
 * If more than one instance of DynamicClient was initialized, you should not use this function.
 * Instead, you should pass the client instance you stored to the function that needs it.
 */ const getDefaultClient = ()=>{
    if (!defaultClient) {
        throw new ClientNotFoundError();
    }
    if (numOfInitializedClients > 1) {
        const core = getCore(defaultClient);
        core.logger.debug('Multiple instances of DynamicClient found. If you are only using one client (recommended), make sure you are not calling ' + '"createDynamicClient" multiple times. If you are using multiple clients, make sure you are passing which client to use as ' + 'the last param of all Dynamic functions.');
    }
    return defaultClient;
};
const setDefaultClient = (client)=>{
    defaultClient = client;
    numOfInitializedClients++;
};

const DYNAMIC_API_VERSION_HEADER = 'x-dyn-api-version';
const DYNAMIC_REQUEST_ID_HEADER = 'x-dyn-request-id';
const DYNAMIC_SDK_VERSION_HEADER = 'x-dyn-version';
const MFA_TOKEN_HEADER = 'x-mfa-auth-token';
const SESSION_PUBLIC_KEY_HEADER = 'x-dyn-session-public-key';
const DYNAMIC_SDK_API_VERSION = dependencies['@dynamic-labs/sdk-api-core'];
const CLIENT_SDK_NAME = 'ClientSDK';

const randomString = (length)=>{
    const CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    let result = '';
    for(let i = length; i > 0; --i){
        result += CHARS[Math.floor(Math.random() * CHARS.length)];
    }
    return result;
};

class ValueMustBeDefinedError extends BaseError {
    constructor(message){
        super({
            cause: null,
            code: 'value_must_be_defined_error',
            docsUrl: null,
            name: 'ValueMustBeDefined',
            shortMessage: message
        });
    }
}

/**
 * Asserts that a value is not null or undefined, throwing an error if it is.
 * This function acts as a type guard, narrowing the type to exclude null and undefined.
 *
 * @template T - The type of the value being checked
 * @param value - The value to check for null or undefined
 * @param message - The error message to throw if the value is null or undefined
 * @throws Throws an error with the provided message if value is null or undefined
 * @example
 * ```typescript
 * const maybeString: string | null = getValue();
 * assertDefined(maybeString, 'String value is required');
 * // maybeString is now typed as string (null is excluded)
 * ```
 */ function assertDefined(value, message) {
    if (value === null || value === undefined) {
        throw new ValueMustBeDefinedError(message);
    }
}

/**
 * Returns true if the client is using Dynamic cookies or a BYO JWT cookie.
 */ const isCookieEnabled = (client)=>{
    var _securitySettings_auth, _securitySettings_externalAuth;
    assertDefined(client.projectSettings, 'Project settings are not defined');
    const securitySettings = client.projectSettings.security;
    if (!securitySettings) return false;
    // client uses Dynamic cookies
    const dynamicCookiesEnabled = (((_securitySettings_auth = securitySettings.auth) == null ? void 0 : _securitySettings_auth.storage) || []).includes(sdkApiCore.AuthStorageEnum.Cookie);
    // BYO JWT client puts their non-Dynamic JWT in a cookie
    const byoJwtCookieEnabled = Boolean((_securitySettings_externalAuth = securitySettings.externalAuth) == null ? void 0 : _securitySettings_externalAuth.cookieName);
    // should return true for both of these scenarios
    // because we also need to do `credentials: true` in api.ts when
    // a byo jwt client sets their named cookie for their jwt and
    // needs to send it to our backend
    return dynamicCookiesEnabled || byoJwtCookieEnabled;
};

const getBuffer = ()=>typeof Buffer !== 'undefined' ? Buffer : buffer.Buffer;

const getSessionKeys = (client)=>{
    const core = getCore(client);
    const encodedKeys = core.state.get().sessionKeys;
    if (!encodedKeys) {
        return undefined;
    }
    try {
        const decodedKeys = JSON.parse(getBuffer().from(encodedKeys, 'base64').toString());
        return decodedKeys;
    } catch (error) {
        core.logger.error('Error decoding session keys', error);
        return undefined;
    }
};

class APIError extends BaseError {
    static async fromResponse(response) {
        const errorBody = await response.json();
        if ('code' in errorBody && typeof errorBody.code === 'string' && 'error' in errorBody && typeof errorBody.error === 'string') {
            return new APIError(errorBody.error, errorBody.code);
        }
        return null;
    }
    constructor(message, code){
        super({
            cause: null,
            code,
            docsUrl: null,
            name: 'APIError',
            shortMessage: message
        });
    }
}

class InvalidExternalAuthError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'invalid_external_auth_error',
            docsUrl: 'https://www.dynamic.xyz/docs/external-auth/third-party-auth-overview',
            name: 'InvalidExternalAuthError',
            shortMessage: 'Error authenticating with external JWT'
        });
    }
}

class MfaInvalidOtpError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'mfa_invalid_otp_error',
            docsUrl: null,
            name: 'MfaInvalidOtpError',
            shortMessage: 'Invalid OTP'
        });
    }
}

class MfaRateLimitedError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'mfa_rate_limited_error',
            docsUrl: null,
            name: 'MfaRateLimitedError',
            shortMessage: 'Rate limited'
        });
    }
}

class SandboxMaximumThresholdReachedError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'sandbox_maximum_threshold_reached_error',
            docsUrl: 'https://www.dynamic.xyz/docs/developer-dashboard/sandbox-vs-live#sandbox-vs-live',
            name: 'SandboxMaximumThresholdReachedError',
            shortMessage: 'Your sandbox environment has reached the maximum MAU. Please use a live environment for production traffic.'
        });
    }
}

/**
 * Default error mapper for the client that handles common API error codes.
 *
 * This mapper transforms specific API error codes into more specific error types:
 * - `mfa_invalid_code` → `MfaInvalidOtpError`
 * - `mfa_rate_limited` → `MfaRateLimitedError`
 *
 * @param error - The error to be mapped
 * @returns A transformed error if the error code matches a known pattern, or null if no transformation is needed
 *
 * @example
 * ```typescript
 * // This will be automatically applied to all API errors
 * const apiClient = createApiClient({}, client);
 *
 * // The clientErrorMapper will automatically convert mfa_invalid_code errors
 * // to MfaInvalidOtpError instances
 * ```
 */ const clientErrorMapper = (error)=>{
    if (error instanceof APIError) {
        if (error.code === 'mfa_invalid_code') {
            return new MfaInvalidOtpError({
                cause: error
            });
        }
        if (error.code === 'mfa_rate_limited') {
            return new MfaRateLimitedError({
                cause: error
            });
        }
        if (error.code === 'invalid_external_auth') {
            return new InvalidExternalAuthError({
                cause: error
            });
        }
        if (error.code === 'sandbox_maximum_threshold_reached') {
            return new SandboxMaximumThresholdReachedError({
                cause: error
            });
        }
    }
    return null;
};

/**
 * Creates middleware that converts HTTP error responses to APIError instances
 * and optionally applies custom error mappers to transform them into specific error types.
 *
 * @param options.errorMappers - Array of error mappers to apply to API errors
 * @returns A middleware function that handles error conversion and mapping
 */ const createConvertToApiErrorMiddleware = ({ errorMappers = [] })=>({
        post: async (context)=>{
            if (context.response.status >= 400) {
                const apiError = await APIError.fromResponse(context.response);
                if (apiError) {
                    let errorToThrow = apiError;
                    for (const mapper of errorMappers){
                        const newError = mapper(apiError);
                        if (newError) {
                            errorToThrow = newError;
                            break;
                        }
                    }
                    throw errorToThrow;
                }
            }
            return context.response;
        }
    });

/**
 * Returns a new instance of the SDK API client.
 *
 * This is not meant for storing, as it is very light we can create it whenever needed.
 */ const createApiClient = (options = {}, client)=>{
    var _getSessionKeys;
    const core = getCore(client);
    const coreState = core.state.get();
    const settings = {
        basePath: core.apiBaseUrl,
        headers: _extends({
            'Content-Type': 'application/json',
            [DYNAMIC_API_VERSION_HEADER]: DYNAMIC_SDK_API_VERSION,
            [DYNAMIC_REQUEST_ID_HEADER]: randomString(50),
            [DYNAMIC_SDK_VERSION_HEADER]: `${CLIENT_SDK_NAME}/${version}`
        }, core.getApiHeaders(), options.headers)
    };
    if (client.token) {
        settings.headers.Authorization = `Bearer ${client.token}`;
    }
    if (client.projectSettings && isCookieEnabled(client)) {
        settings.credentials = 'include';
    }
    if (options.includeMfaToken && coreState.mfaToken) {
        settings.headers[MFA_TOKEN_HEADER] = coreState.mfaToken;
    }
    const sessionPublicKey = (_getSessionKeys = getSessionKeys(client)) == null ? void 0 : _getSessionKeys.publicKey;
    // This check is required to avoid overriding the session public key header
    // that is set by any of our other SDKs using the Dynamic Client SDK.
    const isSessionPublicKeyHeaderPresent = settings.headers[SESSION_PUBLIC_KEY_HEADER] !== undefined;
    if (sessionPublicKey && !isSessionPublicKeyHeaderPresent) {
        settings.headers[SESSION_PUBLIC_KEY_HEADER] = sessionPublicKey;
    }
    return new sdkApiCore.SDKApi(new sdkApiCore.Configuration(_extends({}, settings, {
        fetchApi: core.fetch,
        middleware: [
            createConvertToApiErrorMiddleware({
                errorMappers: [
                    ...options.errorMappers || [],
                    clientErrorMapper
                ]
            })
        ]
    })));
};

const CHAINS_INFO_MAP = {
    ALGO: {
        apiChainName: 'algo',
        blockchainName: 'Algorand',
        verifiedCredentialChainName: 'algorand'
    },
    APTOS: {
        apiChainName: 'aptos',
        blockchainName: 'Aptos',
        verifiedCredentialChainName: 'aptos'
    },
    BTC: {
        apiChainName: 'bitcoin',
        blockchainName: 'Bitcoin',
        verifiedCredentialChainName: 'bip122'
    },
    COSMOS: {
        apiChainName: 'cosmos',
        blockchainName: 'Cosmos',
        verifiedCredentialChainName: 'cosmos'
    },
    EVM: {
        apiChainName: 'evm',
        // eslint-disable-next-line custom-rules/ban-ethereum-eth-terms
        blockchainName: 'Ethereum',
        verifiedCredentialChainName: 'eip155'
    },
    FLOW: {
        apiChainName: 'flow',
        blockchainName: 'Flow',
        verifiedCredentialChainName: 'flow'
    },
    SOL: {
        apiChainName: 'solana',
        blockchainName: 'Solana',
        verifiedCredentialChainName: 'solana',
        waasChainNameOverride: 'SVM'
    },
    SPARK: {
        apiChainName: 'spark',
        blockchainName: 'Spark',
        verifiedCredentialChainName: 'spark'
    },
    STARK: {
        apiChainName: 'starknet',
        blockchainName: 'Starknet',
        verifiedCredentialChainName: 'starknet'
    },
    SUI: {
        apiChainName: 'sui',
        blockchainName: 'Sui',
        verifiedCredentialChainName: 'sui'
    },
    TON: {
        apiChainName: 'ton',
        blockchainName: 'TON',
        verifiedCredentialChainName: 'ton'
    },
    TRON: {
        apiChainName: 'tron',
        blockchainName: 'Tron',
        verifiedCredentialChainName: 'tron'
    }
};

const getChainFromVerifiedCredentialChain = (verifiedCredentialChain)=>{
    const chains = Object.keys(CHAINS_INFO_MAP);
    const chain = chains.find((chain)=>CHAINS_INFO_MAP[chain].verifiedCredentialChainName === verifiedCredentialChain);
    assertDefined(chain, `Unknown chain: ${verifiedCredentialChain}`);
    return chain;
};

const SDK_API_CORE_VERSION = dependencies['@dynamic-labs/sdk-api-core'];
const DYNAMIC_ICONIC_SPRITE_URL = 'https://iconic.dynamic-static-assets.com/icons/sprite.svg';

exports.APIError = APIError;
exports.BaseError = BaseError;
exports.CHAINS_INFO_MAP = CHAINS_INFO_MAP;
exports.CLIENT_SDK_NAME = CLIENT_SDK_NAME;
exports.ClientNotFoundError = ClientNotFoundError;
exports.DYNAMIC_ICONIC_SPRITE_URL = DYNAMIC_ICONIC_SPRITE_URL;
exports.DYNAMIC_SDK_API_VERSION = DYNAMIC_SDK_API_VERSION;
exports.InvalidExternalAuthError = InvalidExternalAuthError;
exports.MfaInvalidOtpError = MfaInvalidOtpError;
exports.MfaRateLimitedError = MfaRateLimitedError;
exports.SDK_API_CORE_VERSION = SDK_API_CORE_VERSION;
exports.SandboxMaximumThresholdReachedError = SandboxMaximumThresholdReachedError;
exports.ValueMustBeDefinedError = ValueMustBeDefinedError;
exports._extends = _extends;
exports.assertDefined = assertDefined;
exports.createApiClient = createApiClient;
exports.getBuffer = getBuffer;
exports.getChainFromVerifiedCredentialChain = getChainFromVerifiedCredentialChain;
exports.getCore = getCore;
exports.getDefaultClient = getDefaultClient;
exports.getSessionKeys = getSessionKeys;
exports.isCookieEnabled = isCookieEnabled;
exports.name = name;
exports.randomString = randomString;
exports.setDefaultClient = setDefaultClient;
exports.version = version;
