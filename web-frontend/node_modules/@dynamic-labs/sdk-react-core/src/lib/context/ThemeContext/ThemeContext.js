'use client'
import { jsx } from 'react/jsx-runtime';
import { createContext, useState, useRef, useCallback, useEffect, useMemo, useContext } from 'react';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import '../ViewContext/ViewContext.js';
import '../../shared/logger.js';
import '@dynamic-labs/wallet-book';
import { isSSR } from '../../shared/utils/functions/isSSR/isSSR.js';
import '@dynamic-labs/utils';
import '../../utils/constants/colors.js';
import '../../utils/constants/values.js';
import '@dynamic-labs/sdk-api-core';
import '../../shared/consts/index.js';
import { getThemeConfig, themesData } from './themesData.js';
import { findOrCreateLinkTag, findOrCreateStyleTag, buildStylesheet } from './utils/stylesheetBuilder/stylesheetBuilder.js';

const ThemeContext = createContext(undefined);
const ThemeContextProvider = ({ customerTheme, designSettings, children }) => {
    const [theme, _setTheme] = useState(customerTheme || getThemeConfig(designSettings === null || designSettings === void 0 ? void 0 : designSettings.modal));
    const linkTag = useRef(findOrCreateLinkTag());
    const styleTag = useRef(findOrCreateStyleTag());
    const setTheme = useCallback((newTheme) => {
        _setTheme(newTheme);
        // SSR won't have document defined, so we can't run this logic in server side
        if (isSSR() ||
            linkTag.current === undefined ||
            styleTag.current === undefined)
            return;
        document.body.dataset.dynamicTheme = newTheme.theme.name;
        document.body.dataset.dynamicThemeBrand = newTheme.brandStyle;
        const linkHref = newTheme.template === 'default'
            ? ''
            : `https://app.dynamic.xyz/assets/templates/${newTheme.template}.css`;
        if (linkTag.current.href !== linkHref)
            linkTag.current.href = linkHref;
        const builtStylesheet = buildStylesheet(newTheme);
        if (styleTag.current.innerHTML === builtStylesheet)
            return;
        styleTag.current.innerHTML = builtStylesheet;
    }, []);
    const changeTheme = useCallback((passedTheme, footerColor) => {
        var _a;
        const selectedTheme = (_a = themesData.themes) === null || _a === void 0 ? void 0 : _a[passedTheme];
        const updatedThemeData = Object.assign(Object.assign({}, theme), { theme: Object.assign(Object.assign({}, selectedTheme), { colors: Object.assign(Object.assign({}, selectedTheme.colors), { ternary: footerColor !== null && footerColor !== void 0 ? footerColor : selectedTheme.colors.ternary }) }) });
        setTheme(updatedThemeData);
    }, [setTheme, theme]);
    const changeTemplate = useCallback((template) => setTheme(Object.assign(Object.assign({}, theme), { template })), [setTheme, theme]);
    const changeBorder = useCallback((border) => setTheme(Object.assign(Object.assign({}, theme), { border })), [setTheme, theme]);
    const changeView = useCallback((view) => setTheme(Object.assign(Object.assign({}, theme), { view })), [setTheme, theme]);
    const changePrimaryColor = useCallback((customColor) => setTheme(Object.assign(Object.assign({}, theme), { customColor })), [setTheme, theme]);
    const changeBrandStyle = useCallback((brandStyle) => setTheme(Object.assign(Object.assign({}, theme), { brandStyle })), [setTheme, theme]);
    // This hook changes theme when customerTheme prop changes
    // It can be changed by customer code so useEffect makes sense here
    useEffect(() => setTheme(customerTheme || getThemeConfig(designSettings === null || designSettings === void 0 ? void 0 : designSettings.modal)), [customerTheme, designSettings === null || designSettings === void 0 ? void 0 : designSettings.modal, setTheme]);
    const value = useMemo(() => ({
        changeBorder,
        changeBrandStyle,
        changePrimaryColor,
        changeTemplate,
        changeTheme,
        changeView,
        theme,
    }), [
        theme,
        changeBorder,
        changeBrandStyle,
        changeTemplate,
        changeTheme,
        changePrimaryColor,
        changeView,
    ]);
    return (jsx(ThemeContext.Provider, { value: value, children: children }));
};
const useThemeContext = () => {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error('useThemeContext must be used within a ThemeContextProvider');
    }
    return context;
};

export { ThemeContext, ThemeContextProvider, useThemeContext };
