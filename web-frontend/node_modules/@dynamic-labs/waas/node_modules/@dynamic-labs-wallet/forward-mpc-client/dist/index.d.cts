import { EventEmitter } from 'eventemitter3';
import { HashAlgorithm, BaseWebSocketMessage } from '@dynamic-labs-wallet/forward-mpc-shared';
export { BaseWebSocketMessage, ErrorResponse, HandshakeV1RequestMessage, HandshakeV1ResponseMessage, SignMessageV1RequestMessage, SignMessageV1ResponseMessage, WebSocketError, WebSocketErrorType } from '@dynamic-labs-wallet/forward-mpc-shared';
import { SigningAlgorithm } from '@dynamic-labs-wallet/core';

/**
 * Configuration for attestation verification
 */
interface AttestationVerificationConfig {
    /** Expected PCR8 value for the enclave */
    expectedPcr8: string;
    /** Whether to perform strict certificate validation */
    strictCertValidation?: boolean;
    /** Maximum age of attestation document in milliseconds */
    maxAge?: number;
}

interface ForwardMPCClientOptions {
    reconnectAttempts?: number;
    reconnectInterval?: number;
    connectionTimeout?: number;
    heartbeatInterval?: number;
    attestationConfig?: AttestationVerificationConfig;
    attestationVerifier?: any;
}
interface ClientEvents {
    connected: () => void;
    disconnected: () => void;
    error: (error: Error) => void;
    message: (message: BaseWebSocketMessage) => void;
}
declare class ForwardMPCClient extends EventEmitter {
    private ws;
    private url;
    private options;
    private attestationVerifier;
    private isConnected;
    private messageId;
    private pendingRequests;
    private sharedSecret;
    private decapsulationKey;
    private connectionId;
    private handshakeNonce;
    constructor(url: string, options?: ForwardMPCClientOptions);
    connect(): Promise<void>;
    disconnect(): void;
    private cleanup;
    /**
     * Ensures the WebSocket connection is active and handshake is completed.
     * Automatically connects and performs handshake if needed.
     * @returns Object containing the shared secret and connection ID
     * @throws Error if connection or handshake fails
     */
    ensureWsConnection(): Promise<{
        sharedSecret: Uint8Array;
        connectionId: string;
    }>;
    private handleMessage;
    private sendRequest;
    private serializeMessage;
    private deserializeMessage;
    handshake(): Promise<any>;
    signMessage(params: {
        keyshare: any;
        message: Uint8Array | string;
        relayDomain: string;
        signingAlgo: SigningAlgorithm;
        hashAlgo?: HashAlgorithm;
        derivationPath?: Uint32Array;
        tweak?: Uint8Array;
        roomUuid: string;
    }): Promise<any>;
    get connected(): boolean;
    /**
     * Generate a unique connection ID
     */
    /**
     * Verify attestation document from handshake response
     * Uses base64-encoded attestation document directly
     */
    private verifyAttestationDocument;
}

export { type ClientEvents, ForwardMPCClient, type ForwardMPCClientOptions };
