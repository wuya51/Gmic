'use client';
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
import { createWalletClient, custom, toHex, toBytes } from 'viem';
import { eventListenerHandlers, logger } from '@dynamic-labs/wallet-connector-core';
import { EthereumWalletConnector, chainsMap } from '@dynamic-labs/ethereum-core';
import { getBaseAccountProvider } from './helpers.js';
export class BaseAccountEvmWalletConnector extends EthereumWalletConnector {
    get baseAccountProvider() {
        return getBaseAccountProvider(this.props);
    }
    async getConnectedAccounts() {
        try {
            const accounts = await this.baseAccountProvider.request({
                method: 'eth_accounts'
            });
            if (accounts[0]) {
                this.setActiveAccount(this.parseAddress(accounts[0]));
            }
            return accounts.map(this.parseAddress);
        } catch (error) {
            logger.error('Error getting connected accounts', error);
            return [];
        }
    }
    async getAddress() {
        try {
            const [address] = await this.baseAccountProvider.request({
                method: 'eth_requestAccounts'
            });
            if (!address) {
                throw new Error('No address found');
            }
            const parsedAddress = this.parseAddress(address);
            this.setActiveAccount(parsedAddress);
            return parsedAddress;
        } catch (error) {
            logger.error('Error requesting address', error);
            return;
        }
    }
    async signMessage(messageToSign) {
        try {
            const [address] = await this.baseAccountProvider.request({
                method: 'eth_requestAccounts'
            });
            if (!address) {
                throw new Error('No address found');
            }
            const parsedAddress = this.parseAddress(address);
            const signature = await this.baseAccountProvider.request({
                method: 'personal_sign',
                params: [
                    toHex(toBytes(messageToSign)),
                    parsedAddress
                ]
            });
            return signature;
        } catch (err) {
            logger.error('Error signing message', err);
            return undefined;
        }
    }
    setupEventListeners() {
        const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
        this.baseAccountProvider.on('accountsChanged', handleAccountChange);
        this.baseAccountProvider.on('chainChanged', handleChainChange);
        this.baseAccountProvider.on('disconnect', handleDisconnect);
        this.teardownEventListeners = ()=>{
            this.baseAccountProvider.removeListener('accountsChanged', handleAccountChange);
            this.baseAccountProvider.removeListener('chainChanged', handleChainChange);
            this.baseAccountProvider.removeListener('disconnect', handleDisconnect);
        };
    }
    getWalletClient(chainId) {
        return createWalletClient({
            account: this.getActiveAccount(),
            chain: chainId ? chainsMap[chainId] : this.getActiveChain(),
            transport: custom(this.baseAccountProvider, this.providersConfig.httpTransportConfig)
        });
    }
    constructor(props){
        super(_extends({}, props, {
            metadata: {
                id: 'baseAccount',
                name: 'Base Account',
                icon: 'https://base.org/favicon.ico'
            }
        }));
        this.name = 'Base Account';
        this.canConnectViaCustodialService = true;
        this.props = props;
    }
}
