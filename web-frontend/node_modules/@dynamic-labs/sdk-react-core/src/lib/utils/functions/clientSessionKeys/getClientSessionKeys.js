'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { StorageService, tracing } from '@dynamic-labs/utils';
import { CLIENT_SESSION_KEYS, CLIENT_SESSION_KEYS_STORAGE_OPTIONS } from '../../constants/sessionStorage.js';
import { p256Sign, p256Keygen, toEncodedFormat } from '../keyService/keyService.js';
import '@dynamic-labs/iconic';
import '@dynamic-labs/wallet-connector-core';
import 'react';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import { logger } from '../../../shared/logger.js';
import '@dynamic-labs/wallet-book';
import '../../constants/colors.js';
import '../../constants/values.js';
import '@dynamic-labs/sdk-api-core';
import '../../../shared/consts/index.js';
import { clientSessionKeyLogScope } from './constants.js';

const getClientSessionKeys = () => {
    const sessionKeysSS = StorageService.getItem(CLIENT_SESSION_KEYS, CLIENT_SESSION_KEYS_STORAGE_OPTIONS);
    const decodedSessionKeys = sessionKeysSS
        ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
        : undefined;
    return decodedSessionKeys;
};
const generateKeyPair = () => __awaiter(void 0, void 0, void 0, function* () {
    const { private: privateKey, public: publicKey, privateJwk, } = yield p256Keygen();
    // convert to base64 and store the session keys in session storage
    StorageService.setItem(CLIENT_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateJwk, false), CLIENT_SESSION_KEYS_STORAGE_OPTIONS);
    logger.instrument('[SessionChaining] Generated new session key pair', {
        key: 'generated_session_key_pair',
        sessionPublicKey: publicKey,
        time: 0,
    });
    tracing.logEvent(clientSessionKeyLogScope, 'Generated new session key pair', tracing.formatObject({
        publicKey,
    }));
    return { privateKey, privateKeyJwk: privateJwk, publicKey };
});
const generateSessionSignature = (_a) => __awaiter(void 0, [_a], void 0, function* ({ privateKeyJwk, sessionId, }) { return p256Sign(privateKeyJwk, sessionId); });
const generateClientSessionKeys = () => __awaiter(void 0, void 0, void 0, function* () {
    // check if session keys are already stored in session storage
    const clientSessionKeysSS = getClientSessionKeys();
    tracing.logEvent(clientSessionKeyLogScope, 'getClientSessionKeys', tracing.formatObject({
        hasDecodedSessionKeys: Boolean(clientSessionKeysSS),
        publicKey: clientSessionKeysSS === null || clientSessionKeysSS === void 0 ? void 0 : clientSessionKeysSS.publicKey,
    }));
    let publicKey;
    if (clientSessionKeysSS) {
        ({ publicKey } = clientSessionKeysSS);
    }
    else {
        ({ publicKey } = yield generateKeyPair());
    }
    return { publicKey };
});
const getClientSessionPublicKey = () => {
    const clientSessionKeys = getClientSessionKeys();
    return clientSessionKeys === null || clientSessionKeys === void 0 ? void 0 : clientSessionKeys.publicKey;
};
const getClientSessionSignature = (_b) => __awaiter(void 0, [_b], void 0, function* ({ sessionId, }) {
    const clientSessionKeys = getClientSessionKeys();
    if (!clientSessionKeys) {
        throw new Error('Client session keys not found');
    }
    const { publicKey, privateKeyJwk } = clientSessionKeys;
    const sessionSignature = yield generateSessionSignature({
        privateKeyJwk,
        sessionId,
    });
    return { publicKey, sessionSignature };
});
const clearClientSessionKeys = () => {
    const clientSessionKeys = getClientSessionKeys();
    logger.instrument('[SessionChaining] Clearing client session keys', {
        key: 'clearing_client_session_keys',
        sessionPublicKey: clientSessionKeys === null || clientSessionKeys === void 0 ? void 0 : clientSessionKeys.publicKey,
        time: 0,
    });
    StorageService.removeItem(CLIENT_SESSION_KEYS, CLIENT_SESSION_KEYS_STORAGE_OPTIONS);
};

export { clearClientSessionKeys, generateClientSessionKeys, generateKeyPair, generateSessionSignature, getClientSessionKeys, getClientSessionPublicKey, getClientSessionSignature };
