'use strict';

var constants = require('./constants.cjs.js');
var EventEmitter = require('eventemitter3');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var getWalletProviderByKey = require('./getWalletProviderByKey.cjs.js');

/**
 * Shallow compare two objects.
 *
 * Source: https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts
 */ const isEqualShallow = (objA, objB)=>{
    if (Object.is(objA, objB)) return true;
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return objA === objB;
    }
    if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for (const [key, value] of objA){
            if (!Object.is(value, objB.get(key))) return false;
        }
        return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for (const value of objA){
            if (!objB.has(value)) return false;
        }
        return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) return false;
    for (const keyA of keysA){
        if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
            return false;
        }
    }
    if (objA.constructor !== objB.constructor) return false;
    return true;
};

/**
 * Allows subscribing to a slice of the state.
 * The slice is a computation of the states.
 *
 * The callback will only be called when the slice has changed.
 * Change is determined by shallow comparison.
 *
 * Returns a function to unsubscribe the callback.
 */ const subscribeWithSelector = (observable, selector)=>(callback)=>{
        let lastSlice = selector(observable.get());
        return observable.subscribe((value)=>{
            const nextSlice = selector(value);
            if (isEqualShallow(nextSlice, lastSlice)) return;
            lastSlice = nextSlice;
            callback(nextSlice);
        });
    };

/* eslint-disable no-restricted-globals -- this is the abstraction for localStorage */ /**
 * Creates a localStorage adapter
 */ const createLocalStorageAdapter = ()=>({
        getItem: async (key)=>localStorage.getItem(key),
        removeItem: async (key)=>localStorage.removeItem(key),
        setItem: async (key, value)=>localStorage.setItem(key, value)
    });

class InvalidStorageSet extends constants.BaseError {
    constructor({ key, value }){
        super({
            cause: null,
            code: 'invalid_storage_set',
            docsUrl: null,
            metaMessages: [
                `key: ${key}`,
                value
            ],
            name: 'InvalidStorageSet',
            shortMessage: 'Tried to store a value that does not match the schema'
        });
    }
}

/**
 * Returns whether the given string is a valid ISO date string.
 *
 * Does not support timezone offsets.
 */ const isValidDateISOString = (value)=>{
    const date = new Date(value);
    return !isNaN(date.getTime()) && date.toISOString() === value;
};

const DATE_PREFIX = '__DATE__';
const formatForStorage = (value)=>{
    const item = {
        value
    };
    return JSON.stringify(item, (_, entry)=>{
        // You might think that entry here would be a Date and one could simply do "entry instanceof Date",
        // but actually it will be a string already (no idea why JSON.stringify does this)
        if (isValidDateISOString(entry)) {
            return `${DATE_PREFIX}${entry}`;
        }
        return entry;
    });
};
const parseFromStorage = (value)=>{
    try {
        const parsed = JSON.parse(value, (_, entry)=>{
            if (typeof entry === 'string' && entry.startsWith(DATE_PREFIX)) {
                return new Date(entry.slice(DATE_PREFIX.length));
            }
            return entry;
        });
        return parsed;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
        return null;
    }
};

/**
 * Creates a Storage service to interact with storage adapter
 */ const createStorage = ({ prefix = '', storageAdapter })=>{
    const getPrefixedKey = (key)=>prefix ? `${prefix}_${key}` : key;
    return {
        getItem: async (storageKeySchema)=>{
            const rawItem = await storageAdapter.getItem(getPrefixedKey(storageKeySchema.key));
            const parsedItem = rawItem ? parseFromStorage(rawItem) : null;
            /**
       * The item saved to localStorage may be malformed.
       * In this case, we remove it and return null.
       */ if (parsedItem !== null) {
                const parsed = storageKeySchema.schema.safeParse(parsedItem.value);
                if (parsed.success) {
                    return parsed.data;
                }
            }
            /**
       * The item saved to localStorage may be malformed.
       * In this case, we remove it and return null.
       */ await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
            return null;
        },
        removeItem: async (storageKeySchema)=>{
            await storageAdapter.removeItem(getPrefixedKey(storageKeySchema.key));
        },
        setItem: async (storageKeySchema, value)=>{
            const parsed = storageKeySchema.schema.safeParse(value);
            if (!parsed.success) {
                throw new InvalidStorageSet({
                    key: storageKeySchema.key,
                    value: JSON.stringify(value)
                });
            }
            const item = formatForStorage(parsed.data);
            await storageAdapter.setItem(getPrefixedKey(storageKeySchema.key), item);
        }
    };
};

const createStorageKeySchema = (params)=>{
    return params;
};

const REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY = 'refresh-user-state-from-cookie';
const INITIALIZE_STORAGE_SYNC_TRACKER_KEY = 'initialize-storage-sync';
const FETCH_PROJECT_SETTINGS_TRACKER_KEY = 'fetch-project-settings';
const GENERATE_SESSION_KEYS_TRACKER_KEY = 'generate-session-keys';

class CannotTrackError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'cannot_track_error',
            docsUrl: null,
            name: 'CannotTrackError',
            shortMessage: 'All track calls must be performed in the same node tick'
        });
    }
}

/**
 * Log levels and their corresponding numeric values
 */ const LOG_LEVELS = {
    debug: 0,
    error: 3,
    info: 1,
    warn: 2
};
// Assign to avoid lint errors
const defaultConsole = console;
/**
 * Creates a logger instance with configurable log level and event emission capabilities.
 * @returns A logger instance with debug, info, warn, and error methods
 */ const createLogger = (options = {})=>{
    const eventEmitter = new EventEmitter.EventEmitter();
    var _options_level;
    // Default to 'debug' if no level is provided
    const minLevel = (_options_level = options.level) != null ? _options_level : 'warn';
    // Helper to decide if we should log based on current log level
    const shouldLog = (level)=>{
        return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];
    };
    // Helper to format the log message
    const formatMessage = (level, message)=>{
        const timestamp = new Date().toISOString();
        return `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    };
    // Unified logger function that checks the level and calls the appropriate console method
    const log = (level, consoleMethod, message, ...args)=>{
        eventEmitter.emit('log', level, message, ...args);
        if (!shouldLog(level)) return;
        consoleMethod(formatMessage(level, message), ...args);
    };
    return {
        debug: (message, ...args)=>log('debug', defaultConsole.debug, message, ...args),
        error: (message, ...args)=>log('error', defaultConsole.error, message, ...args),
        info: (message, ...args)=>log('info', defaultConsole.info, message, ...args),
        off: eventEmitter.off.bind(eventEmitter),
        on: eventEmitter.on.bind(eventEmitter),
        warn: (message, ...args)=>log('warn', defaultConsole.warn, message, ...args)
    };
};

class NoNetworkProvidersError extends constants.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_network_providers',
            docsUrl: null,
            name: 'NoNetworkProvidersError',
            shortMessage: 'No networks were registered in the client'
        });
    }
}

class WalletAlreadyLinkedToAnotherUserError extends constants.BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'wallet_already_linked_to_another_user_error',
            docsUrl: null,
            name: 'WalletAlreadyLinkedToAnotherUserError',
            shortMessage: 'This wallet is already linked to another user'
        });
    }
}

const isCaptchaRequired = (client = constants.getDefaultClient())=>{
    var _projectSettings_security_hCaptcha;
    const projectSettings = client.projectSettings;
    constants.assertDefined(projectSettings, 'Project settings are not available');
    var _projectSettings_security_hCaptcha_enabled;
    return (_projectSettings_security_hCaptcha_enabled = (_projectSettings_security_hCaptcha = projectSettings.security.hCaptcha) == null ? void 0 : _projectSettings_security_hCaptcha.enabled) != null ? _projectSettings_security_hCaptcha_enabled : false;
};

/**
 * Retrieves the current captcha token from the client state and sets it to null.
 */ const consumeCaptchaToken = (client)=>{
    const core = constants.getCore(client);
    const captchaToken = core.state.get().captchaToken;
    if (isCaptchaRequired(client)) {
        constants.assertDefined(captchaToken, 'Captcha token is required');
    }
    core.state.set({
        captchaToken: null
    });
    return captchaToken != null ? captchaToken : undefined;
};

/**
 * Sets the given captcha token in the client state.
 *
 * @param params.captchaToken - The captcha token to set.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 */ const setCaptchaToken = ({ captchaToken }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    core.state.set({
        captchaToken
    });
};

/**
 * Checks if a specific extension has been applied to the Dynamic client.
 *
 * Extensions add optional features to the Dynamic SDK,
 * such as EVM, Solana, or other chain support.
 *
 * @param params.extensionKey - The unique key identifying the extension to check for.
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns True if the extension is applied, false otherwise.
 */ const hasExtension = ({ extensionKey }, client = constants.getDefaultClient())=>{
    const core = constants.getCore(client);
    return core.extensions.has(extensionKey);
};

/*  
  In older SDK versions we used to have the concept of "connect-only" vs "connect-and-sign". 
  The only difference in backend is it stores some extra data for connect-only, 
  so we can just default to using it.
*/ const createVisit = async ({ walletAccount, authMode = sdkApiCore.AuthModeEnum.Only }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const walletProvider = getWalletProviderByKey.getWalletProviderFromWalletAccount({
        walletAccount
    }, client);
    try {
        const walletName = getWalletProviderByKey.normalizeWalletNameWithChain({
            chain: walletProvider.chain,
            displayName: walletProvider.metadata.displayName
        });
        const connectRequest = {
            address: walletAccount.address,
            authMode,
            // eslint-disable-next-line custom-rules/ban-chain-enum
            chain: walletProvider.chain,
            provider: walletProvider.walletProviderType,
            walletName
        };
        await apiClient.createVisit({
            connectRequest,
            environmentId: core.environmentId
        });
    } catch (error) {
        core.logger.error('Error creating visit', {
            error
        });
    }
};

/**
 * Updates the unverified wallet account in the client state.
 * This will add new wallet accounts and override those with matching ids,
 * but will leave other preexisting wallet accounts unchanged.
 */ const setUnverifiedWalletAccounts = ({ unverifiedWalletAccountsToUpdate }, client)=>{
    if (unverifiedWalletAccountsToUpdate.length === 0) {
        return;
    }
    const core = constants.getCore(client);
    const unverifiedWalletAccountsToUpdateIds = unverifiedWalletAccountsToUpdate.map(({ id })=>id);
    const filteredUnverifiedWalletAccounts = core.state.get().unverifiedWalletAccounts.filter((unverifiedWalletAccount)=>!unverifiedWalletAccountsToUpdateIds.includes(unverifiedWalletAccount.id));
    core.state.set({
        unverifiedWalletAccounts: [
            ...filteredUnverifiedWalletAccounts,
            ...unverifiedWalletAccountsToUpdate
        ]
    });
};

/**
 * Formats a sign in message to prove ownership of an address.
 */ const formatSignInMessage = async ({ domain, blockchainName, address, uri, chainId, nonce, issuedAt, requestId, statement, resources })=>{
    // This format follows the sign-in with ethereum (SIWE) standard,
    // but we are using it also for non-ethereum wallets for now (eg. Solana)
    // for more context on format and fields, please see:
    // https://docs.login.xyz/general-information/siwe-overview/eip-4361
    const header = `${domain} wants you to sign in with your ${blockchainName} account:`;
    const prefix = [
        header,
        address
    ].join('\n');
    // If there is a statement, we want to add a gap between the prefix and the statement
    // two times '\n', first to move statement to next line and second to add a gap between prefix and statement
    const prefixWithStatementGap = statement ? '\n\n' : '\n';
    const prefixWithStatement = `${[
        prefix,
        statement
    ].join(prefixWithStatementGap)}\n`;
    const suffixFields = [];
    suffixFields.push(`URI: ${uri}`);
    suffixFields.push('Version: 1');
    if (chainId) {
        suffixFields.push(`Chain ID: ${chainId}`);
    }
    suffixFields.push(`Nonce: ${nonce}`);
    if (issuedAt) {
        suffixFields.push(`Issued At: ${issuedAt}`);
    }
    if (requestId) {
        suffixFields.push(`Request ID: ${requestId}`);
    }
    if (resources == null ? void 0 : resources.length) {
        suffixFields.push(`Resources:${resources.map((resource)=>'\n- ' + resource).join()}`);
    }
    const suffix = suffixFields.join('\n');
    return [
        prefixWithStatement,
        suffix
    ].join('\n');
};

const createSignInMessageStatement = (client)=>{
    var _core_metadata, _client_projectSettings;
    const core = constants.getCore(client);
    var _core_metadata_name;
    const appName = (_core_metadata_name = (_core_metadata = core.metadata) == null ? void 0 : _core_metadata.name) != null ? _core_metadata_name : (_client_projectSettings = client.projectSettings) == null ? void 0 : _client_projectSettings.general.displayName;
    return `Welcome to ${appName}. Signing is the only way we can truly know that you are the owner of the wallet you are connecting. Signing is a safe, gas-less transaction that does not in any way give ${appName} permission to perform any transactions with your wallet.`;
};

/**
 * Check if the given value is an Error object
 */ const isError = (error)=>error instanceof Error;

/**
 * Check if the given value is an Error object with a specific code
 */ const isErrorWithCode = (error, code)=>{
    if (!isError(error)) return false;
    return 'code' in error && error.code === code;
};

/**
 * Verifies a sign in message by calling either the verifyLink or verify API function,
 * depending on whether the user is signing in or updating their account.
 *
 * Does NOT call updateAuthFromVerifyResponse, it should be called from the return of this function.
 */ const verifySignInMessage = async ({ messageToSign, walletAddress, addressesWithTypes, signature, chain, walletDisplayName, walletProviderType }, client)=>{
    const core = constants.getCore(client);
    const apiClient = constants.createApiClient({}, client);
    const walletName = getWalletProviderByKey.normalizeWalletNameWithChain({
        chain,
        displayName: walletDisplayName
    });
    const verifyApiFunction = client.user ? apiClient.verifyLink.bind(apiClient) : apiClient.verify.bind(apiClient);
    try {
        return await verifyApiFunction({
            environmentId: core.environmentId,
            verifyRequest: {
                // mapping to handle typecasting for address type
                additionalWalletAddresses: addressesWithTypes == null ? void 0 : addressesWithTypes.map((address)=>({
                        address: address.address,
                        publicKey: address.publicKey,
                        type: address.type
                    })),
                captchaToken: consumeCaptchaToken(client),
                // eslint-disable-next-line custom-rules/ban-chain-enum
                chain: chain,
                messageToSign,
                publicWalletAddress: walletAddress,
                signedMessage: signature,
                walletName,
                walletProvider: walletProviderType
            }
        });
    } catch (error) {
        if (isErrorWithCode(error, 'reassign_wallet_confirm') || isErrorWithCode(error, 'merge_accounts_confirmation')) {
            throw new WalletAlreadyLinkedToAnotherUserError({
                cause: error
            });
        }
        throw error;
    }
};

const updateWalletProviderKeysForVerifiedCredentials = ({ keysToUpdate }, client)=>{
    const core = constants.getCore(client);
    core.state.set({
        walletProviderKeyMap: constants._extends({}, core.state.get().walletProviderKeyMap, keysToUpdate)
    });
};

const getVerifiedCredentialForWalletAccount = ({ walletAccount }, client)=>{
    var _client_user;
    return (_client_user = client.user) == null ? void 0 : _client_user.verifiedCredentials.find((vc)=>vc.id === walletAccount.verifiedCredentialId);
};

/**
 * Maps the chain name from the API to the SDK chain name
 */ const getSdkChainFromApiChainName = (chainName)=>{
    const chains = Object.keys(constants.CHAINS_INFO_MAP);
    const chain = chains.find((chain)=>constants.CHAINS_INFO_MAP[chain].apiChainName === chainName);
    return chain || null;
};

/**
 * Retrieves all available network configurations from project settings.
 *
 * This function returns detailed configuration data for all networks enabled
 * in your Dynamic project, including RPC URLs, native currencies, and metadata.
 *
 * @param [client] - The Dynamic client instance. Only required when using multiple Dynamic clients.
 * @returns An array of network configuration data for all enabled networks.
 */ const getNetworksData = (client = constants.getDefaultClient())=>{
    const { state } = constants.getCore(client);
    const { projectSettings } = state.get();
    constants.assertDefined(projectSettings, 'projectSettings not found');
    const networks = projectSettings.networks;
    if (!networks) {
        return [];
    }
    const networksData = networks.map((network)=>{
        var _network_networks;
        if (!network.chainName) return [];
        const chain = getSdkChainFromApiChainName(network.chainName);
        if (!(network == null ? void 0 : (_network_networks = network.networks) == null ? void 0 : _network_networks.length) || !chain) return [];
        return network.networks.map((networkConfiguration)=>{
            var _networkConfiguration_privateCustomerRpcUrls, _networkConfiguration_rpcUrls, _networkConfiguration_isTestnet;
            return {
                blockExplorerUrls: networkConfiguration.blockExplorerUrls,
                chain,
                cluster: networkConfiguration.cluster,
                displayName: networkConfiguration.vanityName || networkConfiguration.name,
                genesisHash: networkConfiguration.genesisHash,
                iconUrl: networkConfiguration.iconUrls[0],
                nativeCurrency: {
                    decimals: networkConfiguration.nativeCurrency.decimals,
                    iconUrl: networkConfiguration.nativeCurrency.iconUrl,
                    name: networkConfiguration.nativeCurrency.name,
                    symbol: networkConfiguration.nativeCurrency.symbol
                },
                networkId: networkConfiguration.networkId,
                rpcUrls: {
                    http: [
                        ...(_networkConfiguration_privateCustomerRpcUrls = networkConfiguration.privateCustomerRpcUrls) != null ? _networkConfiguration_privateCustomerRpcUrls : [],
                        ...(_networkConfiguration_rpcUrls = networkConfiguration.rpcUrls) != null ? _networkConfiguration_rpcUrls : []
                    ]
                },
                testnet: (_networkConfiguration_isTestnet = networkConfiguration.isTestnet) != null ? _networkConfiguration_isTestnet : false
            };
        });
    }).flat();
    return networksData;
};

const createNetworkProviderBuilderRegistry = ()=>{
    const registry = new Map();
    return {
        get: ()=>registry,
        register: (networkProviderBuilder)=>{
            registry.set(networkProviderBuilder.chain, networkProviderBuilder);
        }
    };
};

const getNetworkProviderBuilderRegistry = getWalletProviderByKey.createRuntimeServiceAccessKey('networkProviderBuilderRegistry', createNetworkProviderBuilderRegistry);

/**
 * Retrieves all registered network providers for enabled chains.
 */ const getNetworkProviders = (client)=>{
    const networkProviderBuilderRegistry = getNetworkProviderBuilderRegistry(client);
    const registeredNetworkProviderBuilders = Array.from(networkProviderBuilderRegistry.get().values());
    const networksData = getNetworksData(client);
    const networkProviders = registeredNetworkProviderBuilders.map(({ builder, chain })=>{
        const networksDataForChain = networksData.filter((networkData)=>networkData.chain === chain);
        return networksDataForChain.map(builder);
    });
    return networkProviders.flat();
};

const getNetworkProviderFromNetworkId = ({ networkId, chain }, client)=>{
    const networkProviders = getNetworkProviders(client);
    if (networkProviders.length === 0) {
        throw new NoNetworkProvidersError();
    }
    const networkProvider = networkProviders.find((networkProvider)=>networkProvider.networkId === networkId && networkProvider.chain === chain);
    constants.assertDefined(networkProvider, `No network provider found for chain ${chain} with network id ${networkId}`);
    return networkProvider;
};

exports.CannotTrackError = CannotTrackError;
exports.FETCH_PROJECT_SETTINGS_TRACKER_KEY = FETCH_PROJECT_SETTINGS_TRACKER_KEY;
exports.GENERATE_SESSION_KEYS_TRACKER_KEY = GENERATE_SESSION_KEYS_TRACKER_KEY;
exports.INITIALIZE_STORAGE_SYNC_TRACKER_KEY = INITIALIZE_STORAGE_SYNC_TRACKER_KEY;
exports.InvalidStorageSet = InvalidStorageSet;
exports.NoNetworkProvidersError = NoNetworkProvidersError;
exports.REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY = REFRESH_USER_STATE_FROM_COOKIE_TRACKER_KEY;
exports.WalletAlreadyLinkedToAnotherUserError = WalletAlreadyLinkedToAnotherUserError;
exports.consumeCaptchaToken = consumeCaptchaToken;
exports.createLocalStorageAdapter = createLocalStorageAdapter;
exports.createLogger = createLogger;
exports.createSignInMessageStatement = createSignInMessageStatement;
exports.createStorage = createStorage;
exports.createStorageKeySchema = createStorageKeySchema;
exports.createVisit = createVisit;
exports.formatSignInMessage = formatSignInMessage;
exports.getNetworkProviderBuilderRegistry = getNetworkProviderBuilderRegistry;
exports.getNetworkProviderFromNetworkId = getNetworkProviderFromNetworkId;
exports.getNetworkProviders = getNetworkProviders;
exports.getNetworksData = getNetworksData;
exports.getVerifiedCredentialForWalletAccount = getVerifiedCredentialForWalletAccount;
exports.hasExtension = hasExtension;
exports.isCaptchaRequired = isCaptchaRequired;
exports.isEqualShallow = isEqualShallow;
exports.setCaptchaToken = setCaptchaToken;
exports.setUnverifiedWalletAccounts = setUnverifiedWalletAccounts;
exports.subscribeWithSelector = subscribeWithSelector;
exports.updateWalletProviderKeysForVerifiedCredentials = updateWalletProviderKeysForVerifiedCredentials;
exports.verifySignInMessage = verifySignInMessage;
