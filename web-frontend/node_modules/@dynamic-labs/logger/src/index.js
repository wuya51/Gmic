'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import EventEmitter from 'eventemitter3';
import { MetaData } from './MetaData/MetaData.js';
import { LogLevel } from './types.js';
export { LogLevel } from './types.js';
import { createCircularReferenceReplacer } from './utils/createCircularReferenceReplacer.js';
import { mapLogLevel } from './utils/mapLogLevel.js';
import { processArgs } from './utils/processArgs.js';

/* eslint-disable @typescript-eslint/no-explicit-any, no-console */
const IGNORE_MESSAGES = ['Failed to send logs to server'];
const messageQueue = [];
class Logger {
    constructor(name, level) {
        this.name = name;
        this._level = undefined;
        this.metaData = new MetaData();
        this._level = level;
        if (typeof window !== 'undefined' && window.localStorage !== undefined) {
            // Don't unset the value if it's already set
            Logger.troubleshootModeEnabled =
                Logger.troubleshootModeEnabled ||
                    window.localStorage.getItem('dynamic_enableTroubleshootMode') ===
                        'true';
            window.enableTroubleshootMode = () => {
                window.localStorage.setItem('dynamic_enableTroubleshootMode', 'true');
                Logger.troubleshootModeEnabled = true;
            };
            window.disableTroubleshootMode = () => {
                window.localStorage.removeItem('dynamic_enableTroubleshootMode');
                Logger.troubleshootModeEnabled = false;
            };
        }
    }
    static setEmitErrors(emit) {
        if (emit !== undefined) {
            Logger.globalKeys.emitErrors = emit;
        }
    }
    static setEnvironmentId(environmentId) {
        if (environmentId !== undefined) {
            Logger.globalKeys.environmentId = environmentId;
        }
    }
    getNameArray(name) {
        return Array.isArray(name) ? name : [name];
    }
    createLogger(name, level) {
        return new Logger([...this.getNameArray(this.name), ...this.getNameArray(name)], level !== null && level !== void 0 ? level : this.level);
    }
    get logLevel() {
        return LogLevel[this.level];
    }
    setLogLevel(level) {
        this._level = mapLogLevel(level);
    }
    static setLogLevel(level) {
        Logger.globalLogLevel = mapLogLevel(level);
    }
    static resetLogLevel() {
        Logger.globalLogLevel = undefined;
    }
    get level() {
        var _a;
        if (Logger.globalLogLevel && !this._level) {
            return Logger.globalLogLevel;
        }
        if (this._level === undefined &&
            typeof process !== 'undefined' &&
            ((_a = process.env) === null || _a === void 0 ? void 0 : _a['NODE_ENV']) !== 'production') {
            return LogLevel.DEBUG;
        }
        if (this._level === undefined) {
            return LogLevel.WARN;
        }
        return this._level;
    }
    formatMessage(level, message) {
        var _a;
        if (message instanceof Error) {
            message = message.stack;
        }
        else if (
        // Handle Error-Like Objects
        message instanceof Object &&
            Object.prototype.hasOwnProperty.call(message, 'stack')) {
            message = message.stack;
        }
        else if (message instanceof Object) {
            message = JSON.stringify(message, createCircularReferenceReplacer());
        }
        const names = (Array.isArray(this.name) ? this.name : [this.name]).map((name) => `[${name}]`);
        return `${names.join('')} [${(_a = LogLevel[level]) !== null && _a !== void 0 ? _a : 'TROUBLESHOOTING'}]: ${message}`;
    }
    captureAndSend(level, message, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Logger.globalKeys.emitErrors &&
                !IGNORE_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.toString()) &&
                typeof window !== 'undefined') {
                this.emitHttpLogs(level, message, { args });
            }
        });
    }
    emitHttpLogs(level, message, { args = [], transformMeta = (meta) => meta }) {
        messageQueue.push({ args, level, message, stack: new Error().stack });
        if (messageQueue.length === 1) {
            /**
             * Batching the logs to send them in a single request
             * https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide#batching_operations
             *
             * Essentially, multiple calls to log in the same event loop will be batched into a single request
             */
            queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const messages = [];
                messageQueue.forEach((msg) => {
                    var _a, _b, _c, _d, _e, _f;
                    const body = {};
                    const { objectArgs, remainingArgs } = processArgs(msg);
                    Object.assign(body, ...objectArgs);
                    Object.assign(body, {
                        level: LogLevel[msg.level],
                        message: [msg.message, ...remainingArgs].join(' '),
                        meta: transformMeta(Logger.globalMetaData.merge(this.metaData).get()),
                        stack: msg.stack,
                        url: {
                            hostname: (_a = window.location) === null || _a === void 0 ? void 0 : _a.hostname,
                            origin: (_b = window.location) === null || _b === void 0 ? void 0 : _b.origin,
                            pathname: (_c = window.location) === null || _c === void 0 ? void 0 : _c.pathname,
                            port: (_d = window.location) === null || _d === void 0 ? void 0 : _d.port,
                            protocol: (_e = window.location) === null || _e === void 0 ? void 0 : _e.protocol,
                        },
                        userAgent: (_f = window.navigator) === null || _f === void 0 ? void 0 : _f.userAgent,
                    });
                    messages.push(body);
                });
                try {
                    if (!((_a = Logger.globalKeys) === null || _a === void 0 ? void 0 : _a.environmentId)) {
                        throw new Error('Environment ID not set');
                    }
                    yield fetch(`https://logs.dynamicauth.com/api/v1/${(_b = Logger.globalKeys) === null || _b === void 0 ? void 0 : _b.environmentId}`, {
                        body: JSON.stringify(messages),
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        method: 'POST',
                        mode: 'cors',
                        referrerPolicy: 'origin-when-cross-origin',
                    });
                }
                catch (error) {
                    this.debug('Failed to send logs to server', error);
                }
                messageQueue.length = 0;
            }));
        }
    }
    /**
     * Emits an INFO type message to the backend for analysis and debugging
     */
    instrument(message, options) {
        return this.emitHttpLogs(LogLevel.INFO, message, {
            args: [options],
            // Don't send any meta to avoid storing PII
            transformMeta: () => undefined,
        });
    }
    log(level, message, ...args) {
        const enableTroubleshootMode = typeof window !== 'undefined' && Logger.troubleshootModeEnabled;
        if (!enableTroubleshootMode &&
            (level < this.level || level === LogLevel.MUTE)) {
            return;
        }
        Logger.events.emit('log', level, message, ...args);
        const fmtMsg = this.formatMessage(level, message);
        switch (level) {
            case LogLevel.WARN:
                console.warn(fmtMsg, ...args);
                break;
            case LogLevel.ERROR:
                console.error(fmtMsg, ...args);
                break;
            default:
                console.log(fmtMsg, ...args);
        }
        if (level === LogLevel.ERROR) {
            this.captureAndSend(level, message, ...args);
        }
    }
    logVerboseTroubleshootingMessage(message, ...args) {
        this.log(-1, message, ...args);
    }
    debug(message, ...args) {
        this.log(LogLevel.DEBUG, message, ...args);
    }
    info(message, ...args) {
        this.log(LogLevel.INFO, message, ...args);
    }
    warn(message, ...args) {
        this.log(LogLevel.WARN, message, ...args);
    }
    error(message, ...args) {
        this.log(LogLevel.ERROR, message, ...args);
    }
}
Logger.globalLogLevel = undefined;
Logger.globalKeys = {
    emitErrors: true,
};
Logger.troubleshootModeEnabled = false;
Logger.globalMetaData = new MetaData();
Logger.events = new EventEmitter();

export { Logger };
